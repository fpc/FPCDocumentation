<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="fcl">

<!--
  ====================================================================
    db
  ====================================================================
-->

<module name="db">
<short>Database access layer</short>
<descr>
The <file>db</file> unit provides the basis for all database access
mechanisms. It introduces abstract classes, on which all database 
access mechanisms are based: <link id="TDataset"/> representing a 
set of records from a database, <link id="TField"/> which represents
the contents of a field in a record, <link id="TDatasource"/> which
acts as an event distributor on behalf of a dataset and <link id="TParams"/>
which can be used to parametrize queries. The databases connections 
themselves are abstracted in the <link id="TDatabase"/> class.
</descr>

<!-- constant Visibility: default
     Declaration: dsMaxBufferCount = MAXINT div 8 -->
<element name="dsMaxBufferCount">
<short>Maximum data buffers count for dataset</short>
</element>

<!-- constant Visibility: default
     Declaration: dsMaxStringSize = 8192 -->
<element name="dsMaxStringSize">
<short>Maximum size of string fields</short>
</element>

<!-- constant Visibility: default
     Declaration: YesNoChars : Array[Boolean] of Char = ('N','Y' ) -->
<element name="YesNoChars">
<short>Array of characters mapping a boolean to Y/N</short>
</element>

<!-- constant Visibility: default
     Declaration: SQLDelimiterCharacters = [';',',',' ','(',')',#13,#10,#9] -->
<element name="SQLDelimiterCharacters">
<short>SQL statement delimiter token characters</short>
</element>

<!-- alias type Visibility: default
     Declaration: LargeInt = Int64 -->
<element name="LargeInt">
<short>Large (64-bit) integer</short>
</element>

<!-- pointer type Visibility: default
     Declaration: PLargeInt = ^LargeInt -->
<element name="PLargeInt">
<short>Pointer to Large (64-bit) integer</short>
</element>

<!-- array type Visibility: default
     Declaration: TStringFieldBuffer = Array[0..dsMaxStringSize] of Char -->
<element name="TStringFieldBuffer">
<short>Type to access string field content buffers as an array of characters</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TDataSetState = (dsInactive,dsBrowse,dsEdit,dsInsert,dsSetKey,
                 dsCalcFields,dsFilter,dsNewValue,dsOldValue,dsCurValue,
                 dsBlockRead,dsInternalCalc,dsOpening) -->
<element name="TDataSetState">
<short>Current state of the dataset</short>
<descr>
<p>
<var>TDataSetState</var> describes the current state of the dataset. During
it's lifetime, the dataset's state is described by these enumerated values.
</p>
<p>
Some state are not used in the default TDataset implementation, and are only
used by certain descendents.
</p>
</descr>
<seealso>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsInactive -->
<element name="TDataSetState.dsInactive">
<short>The dataset is not active. No data is available.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsBrowse -->
<element name="TDataSetState.dsBrowse">
<short>The dataset is active, and the cursor can be used to navigate the data.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsEdit -->
<element name="TDataSetState.dsEdit">
<short>The dataset is in editing mode: the current record can be modified.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsInsert -->
<element name="TDataSetState.dsInsert">
<short>The dataset is in insert mode: the current record is a new record
which can be edited.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsSetKey -->
<element name="TDataSetState.dsSetKey">
<short>The dataset is calculating the primary key.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsCalcFields -->
<element name="TDataSetState.dsCalcFields">
<short>The dataset is calculating it's calculated fields.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsFilter -->
<element name="TDataSetState.dsFilter">
<short>The dataset is filtering records.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsNewValue -->
<element name="TDataSetState.dsNewValue">
<short>The dataset is showing the new values of a record.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsOldValue -->
<element name="TDataSetState.dsOldValue">
<short>The dataset is showing the old values of a record.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsCurValue -->
<element name="TDataSetState.dsCurValue">
<short>The dataset is showing the current values of a record.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsBlockRead -->
<element name="TDataSetState.dsBlockRead">
<short>The dataset is open, but no events are transferred to datasources.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsInternalCalc -->
<element name="TDataSetState.dsInternalCalc">
<short>The dataset is calculating it's internally calculated fields.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dsOpening -->
<element name="TDataSetState.dsOpening">
<short>The dataset is currently opening, but is not yet completely open.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TDataEvent = (deFieldChange,deRecordChange,deDataSetChange,
              deDataSetScroll,deLayoutChange,deUpdateRecord,
              deUpdateState,deCheckBrowseMode,dePropertyChange,
              deFieldListChange,deFocusControl,deParentScroll,
              deConnectChange,deReconcileError,deDisabledStateChange) -->
<element name="TDataEvent">
<short>Various events that are sent to datasources</short>
<descr>
<var>TDataEvent</var> describes the various events that can be sent to
<link id="TDatasource"/> instances connected to a <link id="TDataset"/>
instance.
</descr>
<seealso>
<link id="TDatasource"/>
<link id="TDataset"/>
<link id="TDataLink"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: deFieldChange -->
<element name="TDataEvent.deFieldChange">
<short>A field value changed</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deRecordChange -->
<element name="TDataEvent.deRecordChange">
<short>The current record changed</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deDataSetChange -->
<element name="TDataEvent.deDataSetChange">
<short>The dataset property changed</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deDataSetScroll -->
<element name="TDataEvent.deDataSetScroll">
<short>The dataset scrolled to another record</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deLayoutChange -->
<element name="TDataEvent.deLayoutChange">
<short>The layout properties of one of the fields changed</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deUpdateRecord -->
<element name="TDataEvent.deUpdateRecord">
<short>The record is being updated</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deUpdateState -->
<element name="TDataEvent.deUpdateState">
<short>The dataset state is updated</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deCheckBrowseMode -->
<element name="TDataEvent.deCheckBrowseMode">
<short>The browse mode is being checked</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: dePropertyChange -->
<element name="TDataEvent.dePropertyChange">
<short>Unused</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deFieldListChange -->
<element name="TDataEvent.deFieldListChange">
<short>Event sent when the list of fields of a dataset changes</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deFocusControl -->
<element name="TDataEvent.deFocusControl">
<short>Event sent whenever a control connected to a field should be focused</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deParentScroll -->
<element name="TDataEvent.deParentScroll">
<short>Unused</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deConnectChange -->
<element name="TDataEvent.deConnectChange">
<short>Unused</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deReconcileError -->
<element name="TDataEvent.deReconcileError">
<short>Unused</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: deDisabledStateChange -->
<element name="TDataEvent.deDisabledStateChange">
<short>Unused</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TUpdateStatus = (usUnmodified,usModified,usInserted,usDeleted) -->
<element name="TUpdateStatus">
<short>Record update status</short>
<descr>
<var>TUpdateStatus</var> determines the current state of the record buffer,
if updates have not yet been applied to the database.
</descr>
<seealso>
<link id="TDataset.UpdateStatus"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: usUnmodified -->
<element name="TUpdateStatus.usUnmodified">
<short>Record is unmodified</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: usModified -->
<element name="TUpdateStatus.usModified">
<short>Record exists in the database but is locally modified</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: usInserted -->
<element name="TUpdateStatus.usInserted">
<short>Record does not yet exist in the database, but is locally inserted</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: usDeleted -->
<element name="TUpdateStatus.usDeleted">
<short>Record exists in the database, but is locally deleted.</short>
</element>

<!-- set type Visibility: default
     Declaration: TUpdateStatusSet= Set of (usUnmodified,usModified,usInserted,usDeleted) -->
<element name="TUpdateStatusSet">
<short>Set of update states</short>
<descr>
<var>TUpdateStatusSet</var> is a set of <link id="TUpdateStatus"/> values.
</descr>
</element>

<!-- enumeration type Visibility: default
     Declaration: TUpdateMode = (upWhereAll,upWhereChanged,upWhereKeyOnly) -->
<element name="TUpdateMode">
<short>Update mode</short>
<descr>
<var>TUpdateMode</var> determines how the <var>WHERE</var> clause of update queries 
for SQL databases should be constructed.
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: upWhereAll -->
<element name="TUpdateMode.upWhereAll">
<short>Use all old field values</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: upWhereChanged -->
<element name="TUpdateMode.upWhereChanged">
<short>Use only old field values of modified fields</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: upWhereKeyOnly -->
<element name="TUpdateMode.upWhereKeyOnly">
<short>Only use key fields in the where clause.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TResolverResponse = (rrSkip,rrAbort,rrMerge,rrApply,rrIgnore) -->
<element name="TResolverResponse">
<short>Resolver response code</short>
<descr>
<var>TResolverResponse</var> is used to indicate what should happen to a
pending change that could not be resolved. It is used in callbacks.
</descr>
</element>

<!-- enumeration value Visibility: default
     Declaration: rrSkip -->
<element name="TResolverResponse.rrSkip">
<short>Skip the current update, leave it in the change log.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: rrAbort -->
<element name="TResolverResponse.rrAbort">
<short>Abort the whole update process, no error message is displayed (no
<var>EAbort</var> exception raised).</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: rrMerge -->
<element name="TResolverResponse.rrMerge">
<short>Merge the update with existing changes on the server.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: rrApply -->
<element name="TResolverResponse.rrApply">
<short>Replace the update with new values applied by the event handler</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: rrIgnore -->
<element name="TResolverResponse.rrIgnore">
<short>Ignore the error and remove update from change log</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TProviderFlag = (pfInUpdate,pfInWhere,pfInKey,pfHidden) -->
<element name="TProviderFlag">
<short>What to odo with fields when applying updates</short>
<descr>
<var>TProviderFlag</var> describes how the field should be used when
applying updates from a dataset to the database. Each field of a <link
id="TDataset"/> has one or more of these flags.
</descr>
<seealso>
<link id="TProviderFlags"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: pfInUpdate -->
<element name="TProviderFlag.pfInUpdate">
<short>Changes to the field should be propagated to the database.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: pfInWhere -->
<element name="TProviderFlag.pfInWhere">
<short>Field should be used in the WHERE clause of an update statement in
case of <var>upWhereChanged</var>.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: pfInKey -->
<element name="TProviderFlag.pfInKey">
<short>Field is a key field and used in the WHERE clause of an update statement</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: pfHidden -->
<element name="TProviderFlag.pfHidden">
<short></short>
</element>

<!-- set type Visibility: default
     Declaration: TProviderFlags= Set of (pfInUpdate,pfInWhere,pfInKey,pfHidden) -->
<element name="TProviderFlags">
<short>Set of <link id="TProviderFlag"/> flags</short>
<descr>
<var>TProviderFlags</var> is used for the <link id="TField.ProviderFlags"/>
property to describe the role of the field when applying updates to a
database.
</descr>
<seealso>
<link id="TField.ProviderFlags"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TFieldDefs
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFieldDefs">
<short>Collection of <var>TFieldDef</var> instances.</short>
<descr>
<var>TFieldDefs</var> is used by each <var>TDataset</var> instance to keep a description of the data that it manages; 
for each field in a record that makes up the underlying data, the <var>TFieldDefs</var> instance keeps an instance of <var>TFieldDef</var> that describes the field's contents.
For any internally calculated fields of the dataset, a <var>TFieldDef</var> instance is kept as well. This collection is filled by descendent classes of <var>TDataset</var> as soon as the 
dataset is opened; it is cleared when the dataset closes. After the collection was populated, the dataset creates <var>TField</var> instances based on all the definitions in the collections. 
If persistent fields were used, the contents of the fielddefs collection is compared to the field components that are present in the dataset. If the collection contains more field definitions than Field
components, these extra fields will not be available in the dataset.
</descr>
<seealso>
<link id="TFieldDef"/>
<link id="TDataset"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TField">
<short>Provide access to the contents of a single field in a record</short>
<descr>
<p>
<var>TField</var> is an abstract class that defines access methods for a field in a record, controlled by a <link id="TDataset"/> instance.
It provides methods and properties to access the contents of the field in the current record. Reading one of the AsXXX properties
of <var>TField</var> will access the field contents and return the contents as the desired type. Writing one of the AsXXX properties will
write a value to the buffer represented by the <var>TField</var> instance.
</p>
<p>
<var>TField</var> is an abstract class, meaning that it should never be created directly. <var>TDataset</var> instances always create one
of the descendent classes of TField, depending on the type of the underlying data. 
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TFieldDef"/>
<link id="TFields"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TFields
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFields">
<short>Collection of <link id="#fcl.db.TField"/> instances</short>
<descr>
<var>TFields</var> mimics a <var>TCollection</var> class for the <link id="TDataset.Fields">Fields</link> property of <link id="TDataset"/> instance.
Since <link id="TField"/> is a descendent of <var>TComponent</var>, it cannot be an item of a collection, and must be managed by another class.
</descr>
<seealso>
<link id="TField"/>
<link id="TDataset"/>
<link id="TDataset.Fields"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDataSet
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDataSet">
<short>Base class for records-based data-access</short>
<descr>
<p><var>TDataset</var> is the main class of the <file>db</file> unit. This abstract class provides all basic funtionality to access data stored in tabular format:
The data consists of records, and the data in each record is organised in several fields.</p>
<p>
<var>TDataset</var> has a buffer to cache a few records in memory, this buffer is used by <var>TDatasource</var> to create the ability to use data-aware components.</p>
<p><var>TDataset</var> is an abstract class, which provides the basic functionality to access, navigate through the data and - in case read-write access is available, 
edit existing or add new records.  
</p>
<p>
<var>TDataset</var> is an abstract class: it does not have the knowledge to store or load the records from whatever medium the records are stored on.
Descendants add the functionality to load and save the data. Therefor <var>TDataset</var> is never used directly, one always instantiates a descendent class.
</p>
<p>
Initially, no data is available: the dataset is inactive. The <link id="TDataset.Open">Open</link> method must be used to fetch data into memory. 
After this command, the data is available in memory for browsing or editing purposes: The dataset is active (indicated by the <link id="TDataset.Active"/> property).
Likewise, the <link id="TDataset.Close">Close</link> method can be used to remove the data from memory. Any changes not yet saved to the underlying medium will be lost.
</p>
<p>
Data is expected to be in tabular format, where each row represents a record. The dataset has an idea of a cursor: this is the current position of the
data cursor in the set of rows. Only the data of the current record is available for display or editing purposes. Through the <link id="TDataset.Next">Next</link>, 
<link id="TDataset.Prev">Prev</link>, <link id="TDataset.First">First</link> and <link id="TDataset.Last">Last</link> methods, it is possible to navigate through 
the records. The <link id="TDataset.EOF">EOF</link> property will be <var>True</var> if the last row has been reached. Likewise, the <link id="TDataset.BOF">BOF</link> 
property will return <var>True</var> if the first record in the dataset has been rechaed when navigating backwards. If both proprties are empty, then there is no data 
available. For dataset descendents that support counting the number of records, the <link id="TDataset.RecordCount">RecordCount</link> will be zero.
</p>
<p>
The <link id="TDataset.Append">Append</link> and <link id="TDataset.Insert">Insert</link> methods can be used to insert new records to the set of records. 
The <link id="TDataset.Delete"/> statement is used to delete the current record, and the <link id="TDataset.Edit">Edit</link> command must be used to set the 
dataset in editing mode: the contents of the current record can then be changed. Any changes made to the current record (be it a new or existing record) must be
saved by the <link id="TDataset.Post">Post</link> method, or can be undone using the <link id="TDataset.Cancel">Cancel</link> method.
</p>
<p>
The data in the various fields properties is available through the <link id="TDataset.Fields">Fields</link> array property, giving indexed access to all the 
fields in a record. The contents of a field is always readable. If the dataset is in one of the editing modes, then the fields can also be written to.
</p>
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDataBase
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDataBase">
<short>Base class for connecting a FreePascal application to an external Database engine</short>
<descr>
<p>
<var>TDatabase</var> is a component whose purpose is to provide a connection to an external database engine, not to provide the database itself. 
This class provides generic methods for attachment to databases and querying their contents; the details of the actual connection are handled by 
database-specific components (such as SQLDb for SQL-based databases, or DBA for DBASE/FoxPro style databases).
</p>
<p>
Like <link id="TDataset"/>, TDatabase is an abstract class. It provides methods to keep track of datasets connected to the database, 
and to close these datasets when the connection to the database is closed. To this end, it introduces a <link id="TDatabase.Connected">Connected</link> 
boolean property, which indicates whether a connection to the database is established or not. The actual logic to establish a connection to
a database must be implemented by descendent classes.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatabase"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDatasource
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDatasource">
<short>Component representing the link between a local (GUI) component and a dataset</short>
<descr>
<var>TDatasource</var> is a mediating component: it handles communication between any DB-Aware component (often edit controls on a form) and a <link id="TDataset"/> instance.
Any database aware component should never communicate with a dataset directly. Instead, it should communicate with a <link id="TDatasource"/> instance. The TDataset instance
will communicate with the TDatasource instance, which will notify every component attached to it. Vice versa, any component that wishes to make changes to the dataset, will 
notify the TDatasource instance, which will then (if needed) notify the TDataset instance. The datasource can be disabled, in which case all communication between the 
dataset and the DB-AWare components is suspended until the datasource is again enabled.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatalink"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDetailDataLink
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDetailDataLink">
<short>Represents the link between a detail data source and a master datasource.</short>
<descr>
<var>TDetailDataLink</var> handles the communication between a detail dataset and the master datasource in a master-detail relationship between datasets.
It should never be used in an application, and should only be used by component writers that wish to provide master-detail functionality for TDataset descendents.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatasource"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDBTransaction
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDBTransaction">
<short>Encapsulate a transaction</short>
<descr>
<var>TDBTransaction</var> encapsulates a SQL transaction. It is an abstract class, and should be used by component creators that wish to encapsulate transactions in a class.
The <var>TDBTransaction</var> class offers functionality to refer to a <link id="TDatabase"/> instance, and to keep track of <var>TDataset</var> instances which are connected 
to the transaction.
</descr>
<seealso>
<link id="TDatabase"/>
<link id="TDataset"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.EDatabaseError
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="EDatabaseError">
<short>Base class for all database-related errors</short>
<descr>
<var>EDatabaseError</var> is the base class from which database-related exception classes should derive. It is raised by the <link id="DatabaseError"/> call.
</descr>
<seealso>
<link id="DatabaseError"/>
<link id="DatabaseErrorFmt"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.EUpdateError
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="EUpdateError">
<short>Error raised when updating data during a post operation.</short>
<descr>
<var>EupdateError</var> is an exception used by the TProvider database support. It should never be raised directly.
</descr>
<seealso>
<link id="EDatabaseError"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(NativeError: String;Context: String;ErrCode: Integer;
                  PrevError: Integer;E: Exception) -->
<element name="EUpdateError.Create">
<short>Create a new EUpdateError instance</short>
<descr>
<var>Create</var> instantiates a new <var>EUpdateError</var> object and populates the various properties with the
<var>NativeError</var>, <var>Context</var>, <var>ErrCode</var> and <var>PrevError</var> parameters. The <var>E</var> 
parameter is the actual exception that occurred while the update operation was attempted. The exception object <var>E</var>
will be freed if the <var>EUpdateError</var> instance is freed.
</descr>
<seealso>
<link id="EDatabaseError"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: NativeError: String -->
<element name="EUpdateError.Create.NativeError">
<short>Native error description.</short>
</element>

<!-- argument Visibility: default
     Declaration: Context: String -->
<element name="EUpdateError.Create.Context">
<short>Context in which error occurred, if applicable</short>
</element>

<!-- argument Visibility: default
     Declaration: ErrCode: Integer -->
<element name="EUpdateError.Create.ErrCode">
<short>Numerical error code, if applicable</short>
</element>

<!-- argument Visibility: default
     Declaration: PrevError: Integer -->
<element name="EUpdateError.Create.PrevError">
<short>Previous error number</short>
</element>

<!-- argument Visibility: default
     Declaration: E: Exception -->
<element name="EUpdateError.Create.E">
<short>Actual exception object.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="EUpdateError.Destroy">
<short>Free the EupdateError instance</short>
<descr>
<var>Destroy</var> frees the original exception object (if there was one) and then calls the inherited destructor.
</descr>
<errors>
If the original exception object was already freed, an error will occur.
</errors>
<seealso>
<link id="EUpdateError.OriginalException"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Context : String -->
<element name="EUpdateError.Context">
<short>Context in which exception occurred.</short>
<descr>
A description of the context in which the original exception was raised.
</descr>
<seealso>
<link id="EUpdateError.OriginalException"/>
<link id="EUpdateError.ErrorCode"/>
<link id="EUpdateError.PreviousError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: ErrorCode : Integer -->
<element name="EUpdateError.ErrorCode">
<short>Numerical error code.</short>
<descr>
<var>ErrorCode</var> is a numerical error code, provided by the native data access layer, to describe the error.
It may or not be filled.
</descr>
<seealso>
<link id="EUpdateError.OriginalException"/>
<link id="EUpdateError.Context"/>
<link id="EUpdateError.PreviousError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OriginalExcaption : Exception -->
<element name="EUpdateError.OriginalExcaption">
<short>Original exception object, if available.</short>
<descr>
<var>OriginalException</var> is the original exception object as raised by the database access layer.
It may or may not be available.
</descr>
<seealso>
<link id="EUpdateError.ErrorCode"/>
<link id="EUpdateError.Context"/>
<link id="EUpdateError.PreviousError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: PreviousError : Integer -->
<element name="EUpdateError.PreviousError">
<short>Previous error number</short>
<descr>
<var>PreviousError</var> is used to order the errors which occurred during an update operation.
</descr>
<seealso>
<link id="EUpdateError.ErrorCode"/>
<link id="EUpdateError.Context"/>
<link id="EUpdateError.OriginalException"/>
</seealso>
</element>

<!-- "class of" type Visibility: default
     Declaration: TFieldClass = Class of TField -->
<element name="TFieldClass">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TFieldType = (ftUnknown,ftString,ftSmallint,ftInteger,ftWord,ftBoolean,
              ftFloat,ftCurrency,ftBCD,ftDate,ftTime,ftDateTime,ftBytes,
              ftVarBytes,ftAutoInc,ftBlob,ftMemo,ftGraphic,ftFmtMemo,
              ftParadoxOle,ftDBaseOle,ftTypedBinary,ftCursor,
              ftFixedChar,ftWideString,ftLargeint,ftADT,ftArray,
              ftReference,ftDataSet,ftOraBlob,ftOraClob,ftVariant,
              ftInterface,ftIDispatch,ftGuid,ftTimeStamp,ftFMTBcd,
              ftFixedWideChar,ftWideMemo) -->
<element name="TFieldType">
<short>Field data type description</short>
<descr>
<var>TFieldType</var> indicates the type of a <link id="TField"/> underlying data, in the <link id="TField.Datatype">DataType</link> property.
</descr>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftUnknown -->
<element name="TFieldType.ftUnknown">
<short>Unknown data type</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftString -->
<element name="TFieldType.ftString">
<short>String data value (ansistring)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftSmallint -->
<element name="TFieldType.ftSmallint">
<short>Small integer value(1 byte, signed)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftInteger -->
<element name="TFieldType.ftInteger">
<short>Regular integer value (4 bytes, signed)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftWord -->
<element name="TFieldType.ftWord">
<short>Word-sized value(2 bytes, unsigned)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftBoolean -->
<element name="TFieldType.ftBoolean">
<short>Boolean value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftFloat -->
<element name="TFieldType.ftFloat">
<short>Floating point value (double)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftCurrency -->
<element name="TFieldType.ftCurrency">
<short>Currency value (4 decimal points)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftBCD -->
<element name="TFieldType.ftBCD">
<short>Binary Coded Decimal value (DECIMAL and NUMERIC SQL types)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftDate -->
<element name="TFieldType.ftDate">
<short>Date value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftTime -->
<element name="TFieldType.ftTime">
<short>Time value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftDateTime -->
<element name="TFieldType.ftDateTime">
<short>Date/Time (timestamp) value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftBytes -->
<element name="TFieldType.ftBytes">
<short>Array of bytes value, fixed size (unytped)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftVarBytes -->
<element name="TFieldType.ftVarBytes">
<short>Array of bytes value, variable size (untyped)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftAutoInc -->
<element name="TFieldType.ftAutoInc">
<short>Auto-increment integer value (4 bytes)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftBlob -->
<element name="TFieldType.ftBlob">
<short>Binary data value (no type, no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftMemo -->
<element name="TFieldType.ftMemo">
<short>Binary text data (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftGraphic -->
<element name="TFieldType.ftGraphic">
<short>Graphical data value (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftFmtMemo -->
<element name="TFieldType.ftFmtMemo">
<short>Formatted memo ata value (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftParadoxOle -->
<element name="TFieldType.ftParadoxOle">
<short>Paradox OLE field data (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftDBaseOle -->
<element name="TFieldType.ftDBaseOle">
<short>Paradox OLE field data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftTypedBinary -->
<element name="TFieldType.ftTypedBinary">
<short>Binary typed data (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftCursor -->
<element name="TFieldType.ftCursor">
<short>Cursor data value (no size)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftFixedChar -->
<element name="TFieldType.ftFixedChar">
<short>Fixed character array (string)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftWideString -->
<element name="TFieldType.ftWideString">
<short>Widestring (2 bytes per character)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftLargeint -->
<element name="TFieldType.ftLargeint">
<short>Large integer value (8-byte)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftADT -->
<element name="TFieldType.ftADT">
<short>ADT value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftArray -->
<element name="TFieldType.ftArray">
<short>Array data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftReference -->
<element name="TFieldType.ftReference">
<short>Reference data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftDataSet -->
<element name="TFieldType.ftDataSet">
<short>Dataset data (blob)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftOraBlob -->
<element name="TFieldType.ftOraBlob">
<short>Oracle BLOB data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftOraClob -->
<element name="TFieldType.ftOraClob">
<short>Oracle CLOB data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftVariant -->
<element name="TFieldType.ftVariant">
<short>Variant data value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftInterface -->
<element name="TFieldType.ftInterface">
<short>interface data value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftIDispatch -->
<element name="TFieldType.ftIDispatch">
<short>Dispatch data value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftGuid -->
<element name="TFieldType.ftGuid">
<short>GUID data value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftTimeStamp -->
<element name="TFieldType.ftTimeStamp">
<short>Timestamp data value</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftFMTBcd -->
<element name="TFieldType.ftFMTBcd">
<short>Formatted BCD (Binary Coded Decimal) value.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftFixedWideChar -->
<element name="TFieldType.ftFixedWideChar">
<short>Fixed wide character date (2 bytes per character)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ftWideMemo -->
<element name="TFieldType.ftWideMemo">
<short>Widestring memo data</short>
</element>

<!-- array type Visibility: default
     Declaration: TFieldMap = Array[TFieldType] of Byte -->
<element name="TFieldMap">
<short>Array type with <var>TFieldType</var> as index type.</short>
<descr>
<var>TFieldMap</var> is no longer used.
</descr>
<seealso>
<link id="TFieldType"/>
</seealso>
</element>

<!-- "type" alias type Visibility: default
     Declaration: TDateTimeAlias = TDateTime -->
<element name="TDateTimeAlias">
<short>Alias for <var>TDateTime</var> type</short>
<descr>
<var>TDateTimeAlias</var> is no longer used.
</descr>
</element>

<!-- pointer type Visibility: default
     Declaration: PDateTimeRec = ^TdateTimeRec -->
<element name="PDateTimeRec">
<short>Pointer to <var>TDateTimeRec</var> record</short>
<seealso>
<link id="TDateTimeRec"/>
</seealso>
</element>

<!-- record type Visibility: default
     Declaration: TDateTimeRec = record
end
 -->
<element name="TDateTimeRec">
<short>Date/Time record</short>
<descr>
<var>TDateTimeRec</var> was used by older <link id="TDataset"/> implementations to store date/time values. Newer implementations use the <var>TDateTime</var>.
This type should no longer be used.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default
     Declaration: Date : LongInt -->
<element name="TDateTimeRec.Date">
<short>Date value</short>
</element>

<!-- variable Visibility: default
     Declaration: Time : LongInt -->
<element name="TDateTimeRec.Time">
<short>Time value</short>
</element>

<!-- variable Visibility: default
     Declaration: DateTime : TDateTimeAlias -->
<element name="TDateTimeRec.DateTime">
<short>Date/time value</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TFieldAttribute = (faHiddenCol,faReadonly,faRequired,faLink,faUnNamed,
                   faFixed) -->
<element name="TFieldAttribute">
<short>Field attributes</short>
<descr>
<var>TFieldAttribute</var> is used to denote some attributes of a field in a database. It is used in the <link id="TFieldDef.Attributes">Attributes</link>
property of <link id="TFieldDef"/>.
</descr>
<seealso>
<link id="TFieldAttributes"/>
<link id="TFieldDef.Attributes"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: faHiddenCol -->
<element name="TFieldAttribute.faHiddenCol">
<short>Field is a hidden column (used to construct a unique key)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: faReadonly -->
<element name="TFieldAttribute.faReadonly">
<short>Field is read-only</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: faRequired -->
<element name="TFieldAttribute.faRequired">
<short>Field is required</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: faLink -->
<element name="TFieldAttribute.faLink">
<short>Field is a link field for other datasets</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: faUnNamed -->
<element name="TFieldAttribute.faUnNamed">
<short>Field has no original name</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: faFixed -->
<element name="TFieldAttribute.faFixed">
<short>Fixed length field</short>
</element>

<!-- set type Visibility: default
     Declaration: TFieldAttributes= Set of (faHiddenCol,faReadonly,faRequired,faLink,
                          faUnNamed,faFixed) -->
<element name="TFieldAttributes">
<short>Set of <var>TFieldAttribute</var> values.</short>
<descr>
<var>TFieldAttributes</var> is used in the <link id="TFieldDef.Attributes"/> property to denote additional attributes of the underlying field.
</descr>
<seealso>
<link id="TFieldDef.Attributes"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TNamedItem
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TNamedItem">
<short>Named collection item</short>
<descr>
<var>NamedItem</var> is a <link id="#rtl.classes.TCollectionItem">TCollectionItem</link> descendent which introduces a <link id="TNamedItem.Name">Name</link> property.
It automatically returns the value of the <var>Name</var> property as the value of the <link id="TNamedItem.DisplayName">DisplayName</link> property.
</descr>
<seealso>
<link id="TNamedItem.DisplayName">DisplayName</link>
<link id="TNamedItem.Name">Name</link>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DisplayName : String -->
<element name="TNamedItem.DisplayName">
<short>Display name</short>
<descr>
<var>DisplayName</var> is declared in <link id="#rtl.classes.TCollectionItem">TCollectionItem</link>, and is made public in <var>TNamedItem</var>.
The value equals the value of the <link id="TNamedItem.Name">Name</link> property.
</descr>
<seealso>
<link id="TNamedItem.Name">Name</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Name : String -->
<element name="TNamedItem.Name">
<short>Name of the item</short>
<descr>
<var>Name</var> is the name of the item in the collection. This property is also used as the vaulue for the  <link id="TNamedItem.DisplayName">DisplayName</link> property.
If the <var>TNamedItem</var> item is owned by a <link id="TDefCollection"/> collection, then the name must be unique, i.e. each <var>Name</var> value may appear only once in the collection.
</descr>
<seealso>
<link id="TNamedItem.DisplayName">DisplayName</link>
<link id="TDefCollection"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDefCollection
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDefCollection">
<short>Definition collection</short>
<descr>
<var>TDefCollection</var> is a parent class for the <link id="TFieldDefs"/> and <link id="TIndexDefs"/> collections: It holds a set of named 
definitions on behalf of a <link id="TDataset"/> component. To this end, it introduces a <link id="TDefCollection.Dataset">dataset</link>
property, and a mechanism to notify the dataset of any updates in the collection. It is supposed to hold items of class <link id="TNamedItem"/>, so the <link id="TDefCollection.Find"/> method can find items by named.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor create(ADataset: TDataSet;AOwner: TPersistent;
                  AClass: TCollectionItemClass) -->
<element name="TDefCollection.create">
<short>Instantiate a new <var>TDefCollection</var> instance.</short>
<descr>
<var>Create</var> saves the <var>ADataset</var> and <var>AOwner</var> components in local variables for later reference, 
and then calls the inherited <var>Create</var> with <var>AClass</var> as a parameter.
<var>AClass</var> should at least be of type <var>TNamedItem</var>. <var>ADataset</var> is the dataset on whose behalf 
the collection is managed. <var>AOwner</var> is the owner of the collection, normally this is the form or datamodule 
on which the dataset is dropped.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TNamedItem"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataset: TDataSet -->
<element name="TDefCollection.create.ADataset">
<short>Dataset to manage definitions for</short>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TPersistent -->
<element name="TDefCollection.create.AOwner">
<short>Owner of the items in the collection.</short>
</element>

<!-- argument Visibility: default
     Declaration: AClass: TCollectionItemClass -->
<element name="TDefCollection.create.AClass">
<short>Item class for Add call.</short>
</element>

<!-- function Visibility: public
     Declaration: function Find(const AName: String) : TNamedItem -->
<element name="TDefCollection.Find">
<short>Find an item by name</short>
<descr>
<var>Find</var> searches for an item in the collection with name <var>AName</var> and returns the item if it is found. 
If no item with the requested name is found, <var>Nil</var> is returned. The search is performed case-insensitive.
</descr>
<errors>
If no item with matching name is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TNamedItem.Name"/>
<link id="TDefCollection.IndexOf"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDefCollection.Find.Result">
<short>Item matching <var>AName</var></short>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TDefCollection.Find.AName">
<short>Name to search for in collection.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetItemNames(List: TStrings) -->
<element name="TDefCollection.GetItemNames">
<short>Return a list of all names in the collection</short>
<descr>
<var>GetItemNames</var> fills <var>List</var> with the names of all items in the collection. It clears the list first.
</descr>
<errors>
If <var>List</var> is not a valid <var>TStrings</var> instance, an exception will occur.
</errors>
<seealso>
<link id="TNamedItem.Name"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: List: TStrings -->
<element name="TDefCollection.GetItemNames.List">
<short>List to fill with the names of the items in the collection.</short>
</element>

<!-- function Visibility: public
     Declaration: function IndexOf(const AName: String) : LongInt -->
<element name="TDefCollection.IndexOf">
<short>Find location of item by name</short>
<descr>
<var>IndexOf</var> searches in the collection for an item whose
<var>Name</var> property matches <var>AName</var> and returns the index of the item if it finds one. 
If no item is found, -1 is returned. The search is performed case-insensitive.
</descr>
<seealso>
<link id="TDefCollection.Find"/>
<link id="TNamedItem.Name"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDefCollection.IndexOf.Result">
<short>Index of the found item, or -1 if none was found.</short>
</element> 

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TDefCollection.IndexOf.AName">
<short>Name to look for. (case insensitive)</short>
</element>

<!-- property Visibility: public
     Declaration: Dataset : TDataSet -->
<element name="TDefCollection.Dataset">
<short>Dataset this collection manages definitions for.</short>
<descr>
<var>Dataset</var> is the dataset this collection manages definitions for. 
It must be supplied when the collection is created and cannot cgange during the lifetime of the collection.
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Updated : Boolean -->
<element name="TDefCollection.Updated">
<short>Has one of the items been changed</short>
<descr>
<var>Changed</var> indicates whether the collection has changed: an item was added or removed, or one of the properties of the items was changed.
</descr>
<seealso>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TFieldDef
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFieldDef">
<short>Class to describe one field in a record in a dataset</short>
<descr>
<var>TFieldDef</var> is used to describe the fields that are present in the data underlying the dataset.
For each field in the underlying field, an <var>TFieldDef</var> instance is created when the dataset is opened.
This class offers almost no methods, it is mainly a storage class, to store all relevant properties of fields in
a record (name, data type, size, required or not, etc.)
</descr>
<seealso>
<link id="TDataset.FieldDefs"/>
<link id="TFieldDefs"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor create(ACollection: TCollection);  Override -->
<element name="TFieldDef.create">
<short>Constructor for <var>TFieldDef</var>.</short>
<descr>
<p>
<var>Create</var> is the constructor for the <var>TFieldDef</var> class.
</p>
<p>If a simple call is used, with a single argument <var>ACollection</var>, the inherited <var>Create</var> is called and the 
Field number is set to the incremented current index.</p>
<p>If the more complicated call is used, with multiple arguments, then after the inherited <var>Create</var> call, the 
<link id="TFieldDef.name">Name</link>, <link id="TFieldDef.Datatype">datatype</link>, <link id="TFieldDef.Size">size</link>, 
<link id="TFieldDef.Precision">precision</link>, <link id="TFieldDef.FieldNo">FieldNo</link> and the <link id="TFieldDef.Required">Required</link> 
property are all set according to the passsed arguments.</p>
</descr>
<errors>
If a duplicate name is passed, then an exception will occur.
</errors>
<seealso>
<link id="TFieldDef.name">Name</link>
<link id="TFieldDef.Datatype">datatype</link>
<link id="TFieldDef.Size">size</link>
<link id="TFieldDef.Precision">precision</link>
<link id="TFieldDef.FieldNo">FieldNo</link>
<link id="TFieldDef.Required">Required</link> 
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ACollection: TCollection -->
<element name="TFieldDef.create.ACollection">
<short>TFieldDefs instance to which to append the definition, or <var>Nil</var></short>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TFieldDefs -->
<element name="TFieldDef.Create.AOwner">
<short>Owner of the fielddef.</short>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TFieldDef.Create.AName">
<short>Name of the field</short>
</element>

<!-- argument Visibility: default
     Declaration: ADataType: TFieldType -->
<element name="TFieldDef.Create.ADataType">
<short>Data type of the field</short>
</element>

<!-- argument Visibility: default
     Declaration: ASize: Integer -->
<element name="TFieldDef.Create.ASize">
<short>Storage size for the field contents, or zero for fixed-size fields</short>
</element>

<!-- argument Visibility: default
     Declaration: ARequired: Boolean -->
<element name="TFieldDef.Create.ARequired">
<short>Is the fields required or not</short>
</element>

<!-- argument Visibility: default
     Declaration: AFieldNo: LongInt -->
<element name="TFieldDef.Create.AFieldNo">
<short>Number of the field</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TFieldDef.Destroy">
<short>Free the TFieldDef instance</short>
<descr>
<var>Destroy</var> destroys the TFieldDef instance. It simply calls the inherited destructor.
</descr>
<seealso>
<link id="TFieldDef.Create"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Assign(APersistent: TPersistent);  Override -->
<element name="TFieldDef.Assign">
<short>Assign the contents of one TFieldDef instance to another.</short>
<descr>
<var>Assign</var> assigns all published properties of <var>APersistent</var> to the current instance, if <var>APersistent</var> is an instance of class <var>TFieldDef</var>.
</descr>
<errors>
If <var>APersistent</var> is not of class <link id="TFieldDef"/>, then an exception will be raised.
</errors>
</element>

<!-- argument Visibility: default
     Declaration: APersistent: TPersistent -->
<element name="TFieldDef.Assign.APersistent">
<short><var>TFieldDef</var> instance to copy data from.</short>
</element>

<!-- function Visibility: public
     Declaration: function CreateField(AOwner: TComponent) : TField -->
<element name="TFieldDef.CreateField">
<short>Create <var>TField</var> instance based on definitions in current <var>TFieldDef</var> instance.</short>
<descr>
<p>
<var>CreateField</var> determines, based on the <link id="TFieldDef.Datatype">DataType</link> what <link id="TField"/> descendent it
should create, and then returns a newly created instance of this class. It sets the appropriate defaults for the <link id="TField.Size">
Size</link>, <link id="TField.FieldName">FieldName</link>, <link id="TField.FieldNo">FieldNo</link>, <link id="TField.Precision">Precision</link>, 
<link id="TField.ReadOnly">ReadOnly</link> and <link id="TField.Required">Required</link> properties of the newly created instance.  
It should nver be necessary to use this call in an end-user program, only <var>TDataset</var> descendent classes should use this call.
</p>
<p>
The newly created field is owned by the component instance passed in the <var>AOwner</var> parameter.
</p>
<p>
The <link id="DefaultFieldClasses"/> array is used to determine which TField Descendent class should be used when creating the TField 
instance, but descendents of TDataset may override the values in that array.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DefaultFieldClasses"/>
<link id="TField"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TFieldDef.CreateField.Result">
<short>Instance of TField corresponding to the field definition</short>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TFieldDef.CreateField.AOwner">
<short>Owner for the new <var>TField</var> instance.</short>
</element>

<!-- property Visibility: public
     Declaration: FieldClass : TFieldClass -->
<element name="TFieldDef.FieldClass">
<short>TField class used for this fielddef</short>
<descr>
<var>FieldClass</var> is the class of the <var>TField</var> instance that is created by the <link id="TFieldDef.CreateField">CreateField</link> class.
The return value is retrieved from the <var>TDataset</var> instance the <var>TFieldDef</var> instance is associated with. If there is no TDataset 
instance available, the return value is <var>Nil</var>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TFieldDef.CreateField">CreateField</link>
<link id="TField"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldNo : LongInt -->
<element name="TFieldDef.FieldNo">
<short>Field number</short>
<descr>
<var>FieldNo</var> is the number of the field in the data structure where the dataset contents comes from, for instance in a DBase file.
If the underlying data layer does not support the concept of field number, a sequential number is assigned.
</descr>
<seealso>
</seealso></element>

<!-- property Visibility: public
     Declaration: InternalCalcField : Boolean -->
<element name="TFieldDef.InternalCalcField">
<short>Is this a definition of an internally calculated field ?</short>
<descr>
<var>Internalcalc</var> is <var>True</var> if the fielddef instance represents an internally calculated field: for internally calculated fields, 
storage must be rovided by the underlying data mechanism.
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Required : Boolean -->
<element name="TFieldDef.Required">
<short>Is the field required ?</short>
<descr>
<var>Required</var> is set to <var>True</var> if the field requires a value when posting data to the dataset. If no value was entered, the dataset will raise an excepion when the record is posted.
The <var>Required</var> property is usually initialized based on the definition of the field in the underlying database. For SQL-based databases, a field declared as <var>NOT NULL</var> will result 
in a <var>Required</var> property of <var>True</var>.
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Attributes : TFieldAttributes -->
<element name="TFieldDef.Attributes">
<short>Additional attributes of the field.</short>
<descr>
<var>Attributes</var> contain additional attributes of the field. 
It shares the <var>faRequired</var> attribute with the <var>Required</var> property.
</descr>
<seealso>
<link id="TFieldDef.Required"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DataType : TFieldType -->
<element name="TFieldDef.DataType">
<short>Data type for the field</short>
<descr>
<var>DataType</var> contains the data type of the field's contents. Based on this property,
the <var>FieldClass</var> property determines what kind of field class mustbe used to represent this field.
</descr>
<seealso>
<link id="TFieldDef.FieldClass"/>
<link id="TFieldDef.CreateField"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Precision : LongInt -->
<element name="TFieldDef.Precision">
<short>Precision used in BCD (Binary Coded Decimal) fields</short>
<descr>
<var>Precision</var> is the number of digits used in a BCD (Binary Coded Decimal) field. It is not the 
number of digits after the decimal separator, but the total number of digits.
</descr>
<seealso>
<link id="TFieldDef.Size"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Size : Integer -->
<element name="TFieldDef.Size">
<short>Size of the buffer needed to store the data of the field</short>
<descr>
<var>Size</var> indicates the size of the buffer needed to hold data for the field. 
For types with a fixed size (such as integer, word or data/time) the size can be zero: the buffer mechaism reserves automatically enough heap memory. 
For types which can have various sizes (blobs, string types), the Size property tells the buffer mechanism how many bytes are needed 
to hold the data for the field. For BCD fields, the size property indicates
the number of decimals after the decimal separator.
</descr>
<seealso>
<link id="TFieldDef.Precision"/>
<link id="TFieldDef.DataType"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ADataSet: TDataSet) -->
<element name="TFieldDefs.Create">
<short>Create a new instance of <var>TFieldDefs</var></short>
<descr>
<var>Create</var> is used to create a new instance of <var>TFieldDefs</var>. The <var>ADataset</var> argument contains the dataset instance for which
the collection contains the field definitions. 
</descr>
<seealso>
<link id="TFieldDef"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataSet: TDataSet -->
<element name="TFieldDefs.Create.ADataSet">
<short>Dataset for which to maintain field definitions.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Add(const AName: String;ADataType: TFieldType;ASize: Word;
             ARequired: Boolean);  Overload -->
<element name="TFieldDefs.Add">
<short>Add a new field definition to the collection.</short>
<descr>
<var>Add</var> adds a new item to the collection and fills in the <var>Name</var>, <var>DataType</var>, <var>Size</var> and <var>Required</var> properties
of the newly added item with the provided parameters.
</descr>
<errors>
If an item with name <var>AName</var> already exists in the collection, then an exception will be raised.
</errors>
<seealso>
<link id="TFieldDefs.AddFieldDef"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TFieldDefs.Add.AName">
<short>Value for the <var>Name</var> property of the new item.</short>
</element>

<!-- argument Visibility: default
     Declaration: ADataType: TFieldType -->
<element name="TFieldDefs.Add.ADataType">
<short>Value for the <var>DataType</var> property of the new item.</short>
</element>

<!-- argument Visibility: default
     Declaration: ASize: Word -->
<element name="TFieldDefs.Add.ASize">
<short>Value for the <var>Size</var> property of the new item.</short>
</element>

<!-- argument Visibility: default
     Declaration: ARequired: Boolean -->
<element name="TFieldDefs.Add.ARequired">
<short>Value for the <var>Required</var> property of the new item.</short>
</element>

<!-- function Visibility: public
     Declaration: function AddFieldDef : TFieldDef -->
<element name="TFieldDefs.AddFieldDef">
<short>Add new <var>TFieldDef</var></short>
<descr>
<var>AddFieldDef</var> creates a new <var>TFieldDef</var> item and returns the instance.
</descr>
<seealso>
<link id="TFieldDefs.Add"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TFieldDefs.AddFieldDef.Result">
<short>Newly created <var>TFieldDef</var> instance.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Assign(FieldDefs: TFieldDefs);  Overload -->
<element name="TFieldDefs.Assign">
<short>Copy all items from one dataset to another</short>
<descr>
<var>Assign</var> simply calls inherited <var>Assign</var> with the <var>FieldDefs</var> argument.
</descr>
<seealso>
<link id="TFieldDef.Assign"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: FieldDefs: TFieldDefs -->
<element name="TFieldDefs.Assign.FieldDefs">
<short>FieldDefs to copy items from</short>
</element>

<!-- function Visibility: public
     Declaration: function Find(const AName: String) : TFieldDef -->
<element name="TFieldDefs.Find">
<short>Find item by name</short>
<descr>
<var>Find</var> simply calls the inherited <link id="TDefCollection.Find"/> to find an item with name <var>AName</var> and typecasts the result
to <var>TFieldDef</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="TDefCollection.Find"/>
<link id="TNamedItem.Name"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TFieldDefs.Find.Result">
<short>TFieldDef instance with name <var>AName</var> or <var>Nil</var></short>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TFieldDefs.Find.AName">
<short>Name to search for</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Update;  Overload -->
<element name="TFieldDefs.Update">
<short>Force update of definitions</short>
<descr>
<var>Update</var> notifies the dataset that the field definitions are updated, if it was not yet notified.
</descr>
<seealso>
<link id="TDefCollection.Updated"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function MakeNameUnique(const AName: String) : String;  Virtual -->
<element name="TFieldDefs.MakeNameUnique">
<short>Create a unique field name starting from a base name</short>
<descr>
<var>MakeNameUnique</var> uses <var>AName</var> to construct a name of a field that is not yet in the collection. If <var>AName</var> 
is not yet in the collection, then <var>AName</var> is returned. if a field definition with field name equal to <var>AName</var> 
already exists, then a new name is constructed by appending a sequence number to <var>AName</var> till the resulting name does 
not appear in the list of field definitions.
</descr>
<seealso>
<link id="TFieldDefs.Find"/>
<link id="TFieldDef.Name"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TFieldDefs.MakeNameUnique.Result">
<short>Unique name, based on <var>AName</var></short>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TFieldDefs.MakeNameUnique.AName">
<short>Start of fieldname.</short>
</element>

<!-- property Visibility: public
     Declaration: HiddenFields : Boolean -->
<element name="TFieldDefs.HiddenFields">
<short>Should field instances be created for hidden fields</short>
<descr>
<var>HiddenFields</var> determines whether a field is created for fielddefs that have the <var>faHiddenCol</var> attribute set.
If set to <var>False</var> (the default) then no <var>TField</var> instances will be created for hidden fields. If it is set 
to <var>True</var>, then a TField instance will be created for hidden fields.
</descr>
<seealso>
<link id="TFieldDef.Attributes"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Items[Index: LongInt]: TFieldDef; default -->
<element name="TFieldDefs.Items">
<short>Indexed access to the fielddef instances</short>
<descr>
<var>Items</var> provides zero-based indexed access to all <var>TFieldDef</var> instances in the collection.
The index must vary between 0 and <var>Count-1</var>, or an exception will be raised.
</descr>
<seealso>
<link id="TFieldDef"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: LongInt -->
<element name="TFieldDefs.Items.Index">
<short>Zero-based Index of field definition</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TFieldKind = (fkData,fkCalculated,fkLookup,fkInternalCalc) -->
<element name="TFieldKind">
<short>Kind of field</short>
<descr>
<var>TFieldKind</var> indicates the type of a <var>TField</var> instance. Besides <var>TField</var> instances that represent fields present in the underlying data records,
there can also be calculated or lookup fields. To distinguish between these kind of fields, <var>TFieldKind</var> is introduced.
</descr>
<seealso>
<link id="TField.FieldKind"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: fkData -->
<element name="TFieldKind.fkData">
<short>Field represents actual data in the underlying data structure.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: fkCalculated -->
<element name="TFieldKind.fkCalculated">
<short>The field is calculated on the fly.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: fkLookup -->
<element name="TFieldKind.fkLookup">
<short>The field is a lookup field.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: fkInternalCalc -->
<element name="TFieldKind.fkInternalCalc">
<short>Field is calculated but stored in an underlying buffer.</short>
</element>

<!-- set type Visibility: default
     Declaration: TFieldKinds= Set of (fkData,fkCalculated,fkLookup,fkInternalCalc) -->
<element name="TFieldKinds">
<short>Set of <var>TFieldKind</var> values</short>
<descr>
<var>TFieldKinds</var> is a set of <link id="TFieldKind"/> values. It is used internally by the classes of the DB unit.
</descr>
<seealso>
<link id="TFieldKind"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TFieldNotifyEvent = procedure(Sender: TField) of object -->
<element name="TFieldNotifyEvent">
<short>Noification handler prototype</short>
<descr>
<var>TFieldNotifyEvent</var> is a prototype for the event handlers in the <link id="TField"/> class. 
It's <var>Sender</var> parameter is the field instance that triggered the event. 
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Sender: TField -->
<element name="TFieldNotifyEvent.Sender">
<short>Field that triggered the event.</short>
</element>

<!-- procedure type Visibility: default
     Declaration: TFieldGetTextEvent = procedure(Sender: TField;var aText: String;
                               DisplayText: Boolean) of object -->
<element name="TFieldGetTextEvent">
<short>Event handler to get field content</short>
<descr>
<var>TFieldGetTextEvent</var> is the prototype for the <link id="TField.OnGetText"/> event handler. It should be used when
the text of a field requires special formatting. The event handler should return the contents of the field in formatted form
in the <var>AText</var> parameter. The <var>DisplayText</var> is <var>True</var> if the text is used for displaying purposes or
is <var>False</var> if it will be used for editing purposes.
</descr>
<seealso>
<link id="TField.OnGetText"/>
<link id="TFieldSetTextEvent"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Sender: TField -->
<element name="TFieldGetTextEvent.Sender">
<short>Field instance whose text should be returned.</short>
</element>

<!-- argument Visibility: default
     Declaration: aText: String -->
<element name="TFieldGetTextEvent.aText">
<short>The result of the event handler should be returned in this parameter.</short>
</element>

<!-- argument Visibility: default
     Declaration: DisplayText: Boolean -->
<element name="TFieldGetTextEvent.DisplayText">
<short>Is the result used for display purposes ?</short>
</element>

<!-- procedure type Visibility: default
     Declaration: TFieldSetTextEvent = procedure(Sender: TField;const aText: String)
                                of object -->
<element name="TFieldSetTextEvent">
<short>Event handler to get field content</short>
<descr>
<var>TFieldSetTextEvent</var> is the prototype for an event handler used to set the contents of a field based on a user-edited text.
It should be used when the text of a field is entered with special formatting. The event handler should set the contents of the field 
based on the formatted text in the <var>AText</var> parameter.
</descr>
<seealso>
<link id="TField.OnGetText"/>
<link id="TFieldGetTextEvent"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Sender: TField -->
<element name="TFieldSetTextEvent.Sender">
<short>Field which invoked the event handler</short>
</element>

<!-- argument Visibility: default
     Declaration: aText: String -->
<element name="TFieldSetTextEvent.aText">
<short>User-supplied value for the field's contents</short>
</element>

<!-- pointer type Visibility: default
     Declaration: TFieldRef = ^TField -->
<element name="TFieldRef">
<short>Pointer to a TField instance</short>
</element>

<!-- set type Visibility: default
     Declaration: TFieldChars = Set of Char -->
<element name="TFieldChars">
<short>Set of valid characters for the field contents</short>
<descr>
<var>TFieldChars</var> is a type used in the <link id="TField.ValidChars"/> property. It's a simple set of characters.
</descr>
<seealso>
<link id="TField.ValidChars"/>
</seealso>
</element>

<!-- pointer type Visibility: default
     Declaration: PLookupListRec = ^TLookupListRec -->
<element name="PLookupListRec">
<short>Pointer to <var>TLookupListRec</var> record</short>
<seealso>
<link id="TlookupListRec"/>
</seealso>
</element>

<!-- record type Visibility: default
     Declaration: TLookupListRec = record
  Key : Variant;
  Value : Variant;
end
 -->
<element name="TLookupListRec">
<short>Record to store lookup results</short>
<descr>
<var>TLookupListRec</var> is used by lookup fields to store lookup results, if the results should be cached.
Its two fields keep the key value and associated lookup value.
</descr>
<seealso>
<link id="TLookupList"/>
</seealso>
</element>

<!-- variable Visibility: default
     Declaration: Key : Variant -->
<element name="TLookupListRec.Key">
<short>Key value</short>
</element>

<!-- variable Visibility: default
     Declaration: Value : Variant -->
<element name="TLookupListRec.Value">
<short>Lookup value associated to <var>Key</var>.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TLookupList
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TLookupList">
<short>Class to manage lookup list values</short>
<descr>
<var>TLookupList</var> is a list object used for storing values of lookup operations by lookup fields. 
There should be no need to create an instance of <var>TLookupList</var> manually, 
the <var>TField</var> instance will create an instance of <var>TlookupList</var> on demand.
</descr>
<seealso>
<link id="TField.LookupCache"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create -->
<element name="TLookupList.Create">
<short>Create a new instance of <var>TLookupList</var>.</short>
<descr>
<var>Create</var> sets up the necessary structures to manage a list of lookup values for a lookup field.
</descr>
<seealso>
<link id="TLookupList.Destroy"/>
</seealso>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TLookupList.Destroy">
<short>Free a <var>TLookupList</var> instance from memory</short>
<descr>
<var>Destroy</var> frees all resources (mostly memory) allocated by the lookup list, and calls then the inherited destructor.
</descr>
<seealso>
<link id="TLookupList.Create"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Add(const AKey: Variant;const AValue: Variant) -->
<element name="TLookupList.Add">
<short>Add a key, value pair to the list</short>
<descr>
<var>Add</var> will add the value <var>AValue</var> to the list and associate it with key <var>AKey</var>. The same key cannot be added twice.
</descr>
<seealso>
<link id="TLookupList.Clear"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AKey: Variant -->
<element name="TLookupList.Add.AKey">
<short>Lookup key</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: Variant -->
<element name="TLookupList.Add.AValue">
<short>Lookup value</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Clear -->
<element name="TLookupList.Clear">
<short>Remove all key, value pairs from the list</short>
<descr>
<var>Clear</var> removes all keys and associated values from the list.
</descr>
<seealso>
<link id="TLookupList.Add"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function FirstKeyByValue(const AValue: Variant) : Variant -->
<element name="TLookupList.FirstKeyByValue">
<short>Find the first key that matches a value</short>
<descr>
<var>FirstKeyByValue</var> does a reverse lookup: it returns the first key value in the list that matches the <var>AValue</var> value. If none is found, <var>Null</var> is returned. This mechanism is quite slow, as a linear search is performed.
</descr>
<errors>
If no key is found, <var>Null</var> is returned.
</errors>
<seealso>
<link id="TLookupList.ValueOfKey"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TLookupList.FirstKeyByValue.Result">
<short>First key that has <var>AValue</var> associated with it.</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: Variant -->
<element name="TLookupList.FirstKeyByValue.AValue">
<short>Value to match key with.</short>
</element>

<!-- function Visibility: public
     Declaration: function ValueOfKey(const AKey: Variant) : Variant -->
<element name="TLookupList.ValueOfKey">
<short>Look up value based on a key</short>
<descr>
<var>ValueOfKey</var> does a value lookup based on a key: it returns the value in the list that matches the <var>AKey</var> key. 
If none is found, <var>Null</var> is returned. 
This mechanism is quite slow, as a linear search is performed.
</descr>
<seealso>
<link id="TLookupList.FirstKeyByValue"/>
<link id="TLookupList.Add"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TLookupList.ValueOfKey.Result">
<short>Resulting value or <var>Null</var></short>
</element>

<!-- argument Visibility: default
     Declaration: AKey: Variant -->
<element name="TLookupList.ValueOfKey.AKey">
<short>Key to find associated value for.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure ValuesToStrings(AStrings: TStrings) -->
<element name="TLookupList.ValuesToStrings">
<short>Convert values to stringlist</short>
<descr>
<var>ValuesToStrings</var> converts the list of values to a stringlist, so they can be used e.g. in a drop-down list.
</descr>
<seealso>
<link id="TLookupList.ValueOfKey"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AStrings: TStrings -->
<element name="TLookupList.ValuesToStrings.AStrings">
<short>Stringlist to put values in.</short>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TField.Create">
<short>Create a new <var>TField</var> instance</short>
<descr>
<var>Create</var> creates a new <var>TField</var> instance and sets up initial values for the fields. 
<var>TField</var> is a component, and <var>AOwner</var> will be used as the owner of the <var>TField</var> instance.  
This usually will be the form or datamodule on which the dataset was placed.
There should normally be no need for a programmer to create a Tfield instance manually. 
The <link id="TDataset.Open"/> method will create the necessary <var>TField</var> instances, if none had been creaed in the designer.
</descr>
<seealso>
<link id="TDataset.Open"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TField.Create.AOwner">
<short>Owner of the field.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TField.Destroy">
<short>Destroy the <var>TField</var> instance</short>
<descr>
<var>Destroy</var> cleans up any structures set up by the field instance, and then calls the inherited destructor. There should be no need to call this method under normal circumstances:
the dataset instance will  free any TField instances it has created when the dataset was opened.
</descr>
<seealso>
<link id="TDataset.Close"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Assign(Source: TPersistent);  Override -->
<element name="TField.Assign">
<short>Copy properties from one TField instance to another</short>
<descr>
<var>Assign</var> is overridden by <var>TField</var> to copy the field value (not the field properties) from <var>Source</var> if it exists. 
If <var>Source</var> is <var>Nil</var> then the value of the field is cleared.
</descr>
<errors>
If <var>Source</var> is not a <var>TField</var> instance, then an exception will be raised.
</errors>
<seealso>
<link id="TField.Value"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Source: TPersistent -->
<element name="TField.Assign.Source">
<short>Source field to copy value from.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignValue(const AValue: TVarRec) -->
<element name="TField.AssignValue">
<short>Assign value of a variant record to the field.</short>
<descr>
<p>
<var>AssignValue</var> assigns the value of a "array of const" record <var>AValue</var> (of type <var>TVarRec</var>) to the field's value.
If the record contains a TPersistent instance, it will be used as argument for the <var>Assign</var> to the field.
</p>
<p>
The dataset must be in edit mode to execute this method.
</p>
</descr>
<errors>
If the <var>AValue</var> contains an unsupported value (such as a non-nil pointer) then an exception will be raised.
If the dataset is not in one of the edit modes, then executing this method will raise an <link id="EDatabaseError"/> exception.
</errors>
<seealso>
<link id="TField.Assign"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AValue: TVarRec -->
<element name="TField.AssignValue.AValue">
<short>Value to assign to the field</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Clear;  Virtual -->
<element name="TField.Clear">
<short>Clear the field contents.</short>
<descr>
<p>
<var>Clear</var> clears the contents of the field. After calling this method the value of the field is <var>Null</var> and <link id="TField.IsNull">IsNull</link> returns <var>True</var>.
</p>
<p>
The dataset must be in edit mode to execute this method.
</p>
</descr>
<errors>
If the dataset is not in one of the edit modes, then executing this method will raise an <link id="EDatabaseError"/> exception.
</errors>
<seealso>
<link id="TField.IsNull"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure FocusControl -->
<element name="TField.FocusControl">
<short>Set focus to the first control connected to this field.</short>
<descr>
<var>FocusControl</var> will set focus to the first control that is connected to this field.
</descr>
<errors>
If the control cannot receive focus, then this method will raise an exception.
</errors>
<seealso>
<link id="TDataset.EnableControls"/>
<link id="TDataset.DisableControls"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function GetData(Buffer: Pointer) : Boolean;  Overload -->
<element name="TField.GetData">
<short>Get the data from this field</short>
<descr>
<var>GetData</var> is used internally by <var>TField</var> to fetch the value of the data of this field into the data buffer pointed to by <var>Buffer</var>.
If it returns <var>False</var> if the field has no value (i.e. is Null). If the <var>NativeFormat</var> parameter is true, then date/time formats should use
the <var>TDateTime</var> format. It should not be necessary to use this method, instead use the various 'AsXXX' methods to access the data.
</descr>
<errors>
No validity checks are performed on <var>Buffer</var>: it should point to a valid memory area, and should be large enough to contain the value of the field. 
Failure to provide a buffer that matches these criteria will result in an exception.
</errors>
<seealso>
<link id="TField.IsNull"/>
<link id="TField.SetData"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TField.GetData.Result">
<short>True if data is available.</short>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TField.GetData.Buffer">
<short>Buffer to store field contents in.</short>
</element>

<!-- argument Visibility: default
     Declaration: NativeFormat: Boolean -->
<element name="TField.GetData.NativeFormat">
<short>Return date/time values in native (TDateTime) format.</short>
</element>

<!-- function Visibility: public
     Declaration: function IsBlob : Boolean;  Virtual -->
<element name="TField.IsBlob">
<short>Is the field a BLOB field (untyped data of indeterminate size).</short>
<descr>
<var>IsBlob</var> returns <var>True</var> if the field is one of the blob field types. 
The <var>TField</var> implementation returns false. 
Only one of the blob-type field classes override this function and let it return <var>True</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBlobField.IsBlob"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TField.IsBlob.Result">
<short><var>True</var> if the field is a BLOB field, <var>False</var> otherwise.</short>
</element>

<!-- function Visibility: public
     Declaration: function IsValidChar(InputChar: Char) : Boolean;  Virtual -->
<element name="TField.IsValidChar">
<short>Check whether a character is valid input for the field</short>
<descr>
<p>
<var>IsValidChar</var> checks whether <var>InputChar</var> is a valid characters for the current field.
It does this by checking whether <var>InputChar</var> is in the set of characters sepcified by the 
<link id="TField.ValidChars"/> property. The <var>ValidChars</var> property will be initialized to 
a correct set of characters by descendent classes. For instance, a numerical field will only accept 
numerical characters and the sign and decimal separator characters.
</p>
<p>
Descendent classes can override this method to provide custom checks. The <var>ValidChars</var>
property can be set to restrict the list of valid characters to a subset of what would normally
be available.
</p> 
</descr>
<seealso>
<link id="TField.ValidChars"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TField.IsValidChar.Result">
<short><var>True</var> if <var>InputChar</var> is in the set <var>ValidChars</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: InputChar: Char -->
<element name="TField.IsValidChar.InputChar">
<short>Character to check</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure RefreshLookupList -->
<element name="TField.RefreshLookupList">
<short>Refresh the lookup list</short>
<descr>
<var>RefreshLookupList</var> fills the lookup list for a lookup fields with all key, value pairs found in the lookup dataset.
It will open the lookup dataset if needed. The lookup list is only used if the <link id="TField.LookupCache"/> property is set to <var>True</var>.
</descr>
<errors>
If the values of the various lookup properties is not correct or the lookup dataset cannot be opened, then an exception will be raised.
</errors>
<seealso>
<link id="TField.LookupDataset">LookupDataset</link>
<link id="TField.LookupKeyFields">LookupKeyFields</link>
<link id="TField.LookupResultField">LookupResultField</link>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetData(Buffer: Pointer);  Overload -->
<element name="TField.SetData">
<short>Save the field data</short>
<descr>
<p>
<var>SetData</var> saves the value of the field data in <var>Buffer</var> to the dataset internal buffer. 
The <var>Buffer</var> pointer should point to a memory buffer containing the data for the field in the correct format.
If the <var>NativeFormat</var> parameter is true, then date/time formats should use
the <var>TDateTime</var> format.
</p>
<p>
There should normally not be any need to call <var>SetData</var> directly: it is called by the various setter methods of the AsXXX properties of <var>TField</var>.
</p>
</descr>
<errors>
No validity checks are performed on <var>Buffer</var>: it should point to a valid memory area, and should be large enough to contain the value of the field. 
Failure to provide a buffer that matches these criteria will result in an exception.
</errors>
<seealso>
<link id="TField.GetData"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TField.SetData.Buffer">
<short>Buffer to copy field value from</short>
</element>

<!-- argument Visibility: default
     Declaration: NativeFormat: Boolean -->
<element name="TField.SetData.NativeFormat">
<short>Is the provided data in native format</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetFieldType(AValue: TFieldType);  Virtual -->
<element name="TField.SetFieldType">
<short>Set the field data type</short>
<descr>
<var>SetFieldType</var> does nothing, but it can be overridden by descendent classes to provide special handling when the field type is set.
</descr>
<seealso>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AValue: TFieldType -->
<element name="TField.SetFieldType.AValue">
<short>DataType for the field</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Validate(Buffer: Pointer) -->
<element name="TField.Validate">
<short>Validate the data buffer</short>
<descr>
<var>Validate</var> is called by <var>SetData</var> prior to writing the data from <var>Buffer</var> to the dataset buffer. 
It will call the <link id="TField.OnValidate"/> event handler, if one is set, to allow the application programmer to 
program additional checks.
</descr>
<seealso>
<link id="TField.SetData"/>
<link id="TField.OnValidate"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TField.Validate.Buffer">
<short>Buffer with the data to be validated</short>
</element>

<!-- property Visibility: public
     Declaration: AsBCD : TBCD -->
<element name="TField.AsBCD">
<short>Access the field's contents as a BCD (Binary coded Decimal)</short>
<descr>
<var>AsBCD</var> can be used to read or write the contents of the field as a BCD value (Binary Coded Decimal).
If the native type of the field is not BCD, then an attempt will be made to convert the field value from the native
format to a BCD value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a BCD value, an exception may be raised.
</descr>
<seealso>
<link id="TField.AsCurrency"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsBoolean : Boolean -->
<element name="TField.AsBoolean">
<short>Access the field's contents as a Boolean value.</short>
<descr>
<var>AsBoolean</var> can be used to read or write the contents of the field as a boolean value.
If the native type of the field is not Boolean, then an attempt will be made to convert the field value from the native
format to a boolean value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a Boolean value (for instance a string value), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsInteger"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsCurrency : Currency -->
<element name="TField.AsCurrency">
<short>Access the field's contents as a Currency value.</short>
<descr>
<var>AsBoolean</var> can be used to read or write the contents of the field as a currency value.
If the native type of the field is not Boolean, then an attempt will be made to convert the field value from the native
format to a currency value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a currency-compatible value (dates or string values), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsFloat"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsDateTime : TDateTime -->
<element name="TField.AsDateTime">
<short>Access the field's contents as a TDateTime value.</short>
<descr>
<var>AsDateTime</var> can be used to read or write the contents of the field as a TDateTime value (for both date and time values).
If the native type of the field is not a date or time value, then an attempt will be made to convert the field value from the native
format to a TDateTime value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a TDateTime-compatible value (dates or string values), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsFloat : Double -->
<element name="TField.AsFloat">
<short>Access the field's contents as a floating-point (Double) value.</short>
<descr>
<var>AsFloat</var> can be used to read or write the contents of the field as a floating-point value (of type double, i.e. with double precision).
If the native type of the field is not a floating-point value, then an attempt will be made to convert the field value from the native
format to a floating-point value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a floating-point-compatible value (string values for instance), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
<link id="TField.AsCurrency"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsLongint : LongInt -->
<element name="TField.AsLongint">
<short>Access the field's contents as a 32-bit signed integer (longint) value.</short>
<descr>
<p>
<var>AsLongint</var> can be used to read or write the contents of the field as a 32-bit signed integer value (of type longint).
If the native type of the field is not a longint value, then an attempt will be made to convert the field value from the native
format to a longint value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a 32-bit signed integer-compatible value (string values for instance), an exception may be raised.
</p>
<p>
This is an alias for the <link id="TField.AsInteger"/>.
</p>
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
<link id="TField.AsInteger"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsLargeInt : LargeInt -->
<element name="TField.AsLargeInt">
<short>Access the field's contents as a 64-bit signed integer (longint) value.</short>
<descr>
<var>AsLargeInt</var> can be used to read or write the contents of the field as a 64-bit signed integer value (of type Int64).
If the native type of the field is not an Int64 value, then an attempt will be made to convert the field value from the native
format to an Int64 value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a 64-bit signed integer-compatible value (string values for instance), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
<link id="TField.AsInteger"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsInteger : Integer -->
<element name="TField.AsInteger">
<short>Access the field's contents as a 32-bit signed integer (longint) value.</short>
<descr>
<var>AsInteger</var> can be used to read or write the contents of the field as a 32-bit signed integer value (of type Integer).
If the native type of the field is not an integer value, then an attempt will be made to convert the field value from the native
format to a integer value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a 32-bit signed integer-compatible value (string values for instance), an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
<link id="TField.AsLongint"/>
<link id="TField.AsInt64"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsString : String -->
<element name="TField.AsString">
<short>Access the field's contents as an AnsiString value.</short>
<descr>
<var>AsString</var> can be used to read or write the contents of the field as an AnsiString value.
If the native type of the field is not an ansistring value, then an attempt will be made to convert the field value from the native
format to a ansistring value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not an ansistring-compatible value, an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsWideString"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsWideString : WideString -->
<element name="TField.AsWideString">
<short>Access the field's contents as a WideString value.</short>
<descr>
<var>AsWideString</var> can be used to read or write the contents of the field as a WideString value.
If the native type of the field is not a widestring value, then an attempt will be made to convert the field value from the native
format to a widestring value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a widestring-compatible value, an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.Astring"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsVariant : variant -->
<element name="TField.AsVariant">
<short>Access the field's contents as a Variant value.</short>
<descr>
<var>AsVariant</var> can be used to read or write the contents of the field as a Variant value.
If the native type of the field is not a Variant value, then an attempt will be made to convert the field value from the native
format to a variant value when reading the field's content. Likewise, when writing the property, the value will be converted
to the native type of the field (if the value allows it). Therefor, when reading or writing a field value for a field 
whose native data type is not a variant-compatible value, an exception may be raised.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.Astring"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AttributeSet : String -->
<element name="TField.AttributeSet">
<short>Not used: dictionary information</short>
<descr><var>AttributeSet</var> was used in older Delphi versions to store data dictionary information for use in data-aware controls at design time.
Not used in FreePascal (or newer Delphi versions); kept for Delphi compatibility.
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Calculated : Boolean -->
<element name="TField.Calculated">
<short>Is the field a calculated field ?</short>
<descr>
<var>Calculated</var> is <var>True</var> if the <link id="TField.FieldKind">FieldKind</link> is <var>fkCalculated</var>.
Setting the property wil result in <var>FieldKind</var> being set to <var>fkCalculated</var> (for a value of <var>True</var>)
or <var>fkData</var>. This property should be considered read-only.
</descr>
<seealso>
<link id="TField.FieldKind"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: CanModify : Boolean -->
<element name="TField.CanModify">
<short>Can the field's contents be modified.</short>
<descr>
<var>CanModify</var> is <var>True</var> if the field is not read-only and the dataset allows modification.
</descr>
<seealso>
<link id="TField.ReadOnly"/>
<link id="TDataset.CanModify"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: CurValue : Variant -->
<element name="TField.CurValue">
<short>Current value of the field</short>
<descr>
<var>CurValue</var> returns the current value of the field as a variant.
</descr>
<seealso>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSet : TDataSet -->
<element name="TField.DataSet">
<short>Dataset this field belongs to</short>
<descr>
<var>Dataset</var> contains the dataset this field belongs to. Writing this property will add the field to the list of fields of a dataset,
after removing if from the list of fields of the dataset the field was previously assigned to. It should under normal circumstnces never 
be necessary to set this property, the <var>TDataset</var> code will take care of this.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDataset.Fields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSize : Integer -->
<element name="TField.DataSize">
<short>Size of the field's data</short>
<descr>
<var>DataSize</var> is the memory size needed to store the field's contents. This is different from the <link id="TField.Size">Size</link> property which 
declares a logical size for datatypes that have a variable size (such as string fields). For BLOB fields, use the <link id="TBlobField.BlobSize"/> 
property to get the size of the field's contents for the current record..
</descr>
<seealso>
<link id="TField.Size"/>
<link id="TBlobField.BlobSize"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataType : TFieldType -->
<element name="TField.DataType">
<short>The data type of the field.</short>
<descr>
<var>Datatype</var> indicates the type of data the field has. This property is initialized when the dataset is opened or when persistent fields are created for the dataset.
Instead of checking the class type of the field, it is better to check the <var>Datatype</var>, since the actual class of the TField instance may differ depending on the dataset.
</descr>
<seealso>
<link id="TField.FieldKind"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DisplayName : String -->
<element name="TField.DisplayName">
<short>User-readable fieldname</short>
<descr>
<p>
<var>DisplayName</var> is the name of the field as it will be displayed to the user e.g. in grid column headers. 
By default it equals the <link id="TField.FieldName">FieldName</link> property, unless assigned another value.
</p>
<p>
The use of this property is deprecated. Use <link id="TField.Displaylabel">DisplayLabel</link> instead.
</p>
</descr>
<seealso>
<link id="Tfield.FieldName"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DisplayText : String -->
<element name="TField.DisplayText">
<short>Formatted field value</short>
<descr>
<var>DisplayText</var> returns the field's value as it should be displayed to the user, with all necessary formatting applied.
Controls that should display the value of the field should use <var>DisplayText</var> instead of the <link id="TField.AsString"/> 
property, which does not take into account any formatting.
</descr>
<seealso>
<link id="TField.AsString"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldNo : LongInt -->
<element name="TField.FieldNo">
<short>Number of the field in the record</short>
<descr>
<var>FieldNo</var> is the position of the field in the record. It is a 1-based index and is initialized when 
the dataset is opened or when persistent fields are created for the dataset.
</descr>
<seealso>
<link id="TField.Index"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: IsIndexField : Boolean -->
<element name="TField.IsIndexField">
<short>Is the field an indexed field ?</short>
<descr>
<var>IsIndexField</var> is true if the field is an indexed field. By default this property is <var>False</var>, 
descendents of <link id="TDataset"/> can change this to <var>True</var>.
</descr>
<seealso>
<link id="TField.Calculated"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: IsNull : Boolean -->
<element name="TField.IsNull">
<short>Is the field empty</short>
<descr>
<var>IsNull</var> is <var>True</var> if the field does not have a value. 
If the underlying data contained a value, or a value is written to it, <var>IsNull</var> will return <var>False</var>.
After <link id="TDataset.Insert"/> is called or <link id="TField.Clear">Clear</link> is called then <var>IsNull</var> 
will return <var>True</var>.
</descr>
<seealso>
<link id="TField.Clear"/>
<link id="TDataset.Insert"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Lookup : Boolean -->
<element name="TField.Lookup">
<short>Is the field a lookup field</short>
<descr>
<var>Lookup</var> is <var>True</var> if the <link id="Tfield.FieldKind">FieldKind</link> equals <var>fkLookup</var>, <var>False</var> otherwise.
Setting the <var>Lookup</var> property will switch the <var>FieldKind</var> between the <var>fkLookup</var> and <var>fkData</var>.
</descr>
<seealso>
<link id="TField.FieldKind"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: NewValue : Variant -->
<element name="TField.NewValue">
<short>The new value of the field</short>
<descr>
<var>NewValue</var> returns the new value of the field. The FPC implementation of <link id="TDataset"/> does not yet support this.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.CurValue"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Offset : Word -->
<element name="TField.Offset">
<short>Offset of the field's value in the dataset buffer</short>
<descr>
<var>Offset</var> is the location of the field's contents in the dataset memory buffer. 
It is read-only and initialized by the dataset when it is opened.
</descr>
<seealso>
<link id="TField.FieldNo"/>
<link id="TField.Index"/>
<link id="TField.Datasize"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Size : Integer -->
<element name="TField.Size">
<short>Logical size of the field</short>
<descr>
<var>Size</var> is the declared size of the field for datatypes that can have variable size, such as string types, BCD types or array types.
To get the size of the storage needed to store the field's content, the <link id="TField.DataSize">DataSize</link> should be used. For blob 
fields, the current size of the data is not guaranteed to be present.
</descr>
<seealso>
<link id="TField.DataSize">DataSize</link>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Text : String -->
<element name="TField.Text">
<short>Text representation of the field</short>
<descr>
<var>Text</var> can be used to retrieve or set the value of the value as a string value for editing purposes. It will trigger the <link id="TField.OnGetText"/> event handler
if a handler was specified. For display purposes, the <link id="TField.DisplayText"/> property should be used. 
Controls that should display the value in a textual format should use text whenever they must display the text for editing purposes.
Inversely, when a control should save the value entered by the user, it should write the contents to the <var>Text</var> property, 
not the <link id="Tfield.AsString">AsString</link> property, this will invoke the <link id="Tfield.OnSetText"/> event handler, if one is set.
</descr>
<seealso>
<link id="TField.AsString"/>
<link id="TField.DisplayText"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: ValidChars : TFieldChars -->
<element name="TField.ValidChars">
<short>Characters that are valid input for the field's content</short>
<descr>
<var>ValidChars</var> is a property that is initialized by descendent classes to contain the set of characters that can be entered in an edit control
which is used to edit the field. Numerical fields will set this to a set of numerical characters, string fields will set this to all possible characters.
It is possible to restrict the possible input by setting this property to a subset of all possible characters (for example, set it to all 
uppercase letters to allow the user to enter only uppercase characters. <var>TField</var> itself does not enforce the validity of the 
data when the content of the field is set, an edit control should check the validity of the user input by means of the 
<link id="TField.IsValidChar">IsValidChar</link> function.
</descr>
<seealso>
<link id="TField.IsValidChar"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Value : variant -->
<element name="TField.Value">
<short>Value of the field as a variant value</short>
<descr>
<p>
<var>Value</var> can be used to read or write the value of the field as a Variant value. When setting the value, the value will be converted to the actual type of 
the field as defined in the underlying data. Likewise, when reading the value property, the actual field value will be converted to a variant value. If the field 
does not contain a value (when <link id="TField.IsNull">IsNull</link> returns <var>True</var>), then <var>Value</var> will contain <var>Null</var>.
</p>
<p>
It is not recommended to use the <var>Value</var> property: it should only be used when the type of the field is unknown. If the type of the field is known,
it is better to use one of the <var>AsXXX</var> properties, which will not only result in faster code, but will also avoid strange type conversions.
</p>
</descr>
<seealso>
<link id="TField.IsNull"/>
<link id="TField.Text"/>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OldValue : variant -->
<element name="TField.OldValue">
<short>Old value of the field</short>
<descr>
<var>OldValue</var> returns the value of the field prior to an edit operation. This feature is currently not supported in FPC.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.CurValue"/>
<link id="TField.NewValue"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: LookupList : TLookupList -->
<element name="TField.LookupList">
<short>List of lookup values</short>
<descr>
<var>LookupList</var> contains the list of key, value pairs used when caching the possible lookup values for a lookup field. The list is only valid when the <link id="TField.LookupCache">LookupCache</link>
property is set to <var>True</var>. It can be refreshed using the <link id="TField.RefreshLookupList">RefreshLookupList</link> method.
</descr>
<seealso>
<link id="TField.RefreshLookupList"/>
<link id="TField.LookupCache"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Alignment : TAlignment -->
<element name="TField.Alignment">
<short>Alignment for this field</short>
<descr>
<var>Alignment</var> contains the alignment that UI controls should observe when displaying the contents of the field. 
Setting the property at the field level will make sure that all DB-Aware controls will display the contents of the field with the same alignment.
</descr>
<seealso>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: CustomConstraint : String -->
<element name="TField.CustomConstraint">
<short>Custom constraint for the field's value</short>
<descr>
<p>
<var>CustomConstraint</var> may contain a constraint that will be enforced when the dataset posts it's data. 
It should be a SQL-like expression that results in a <var>True</var> or <var>False</var> value. Examples of 
valid constraints are:
</p>
<pre>
Salary &lt; 10000
YearsEducation &lt; Age
</pre>
<p>
If the constraint is not satisfied when the record is posted, then an exception will be raised with the value of 
<link id="TField.ConstraintErrorMessage">ConstraintErrorMessage</link> as a message.
</p>
<p>
This feature is not yet implemented in FPC.
</p>
</descr>
<seealso>
<link id="TField.ConstraintErrorMessage"/>
<link id="TField.ImportedConstraint"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ConstraintErrorMessage : String -->
<element name="TField.ConstraintErrorMessage">
<short>Message to display if the <var>CustomConstraint</var> constraint is violated.</short>
<descr>
<p>
<var>ConstraintErrorMessage</var> is the message that should be displayed when the dataset checks the constraints and the constraint in <link id="TField.CustomConstraint"/> is violated.
</p>
<p>
This feature is not yet implemented in FPC.
</p>
</descr>
<seealso>
<link id="TField.CustomConstraint"/> 
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DefaultExpression : String -->
<element name="TField.DefaultExpression">
<short>Default value for the field</short>
<descr>
<p>
<var>DefaultValue</var> can be set to a value that should be entered in the field whenever the <link id="TDataset.Append"/> or <link id="TDataset.Insert"/> methods are executed.
It should contain a valid SQL expression that results in the correct type for the field.
</p>
<p>
This feature is not yet implemented in FPC.
</p>
</descr>
<seealso>
<link id="TDataset.Insert"/>
<link id="TDataset.Append"/>
<link id="TDataset.CustomConstraint"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DisplayLabel : String -->
<element name="TField.DisplayLabel">
<short>Name of the field for display purposes</short>
<descr>
<p>
<var>DisplayLabel</var> is the name of the field as it will be displayed to the user e.g. in grid column headers. 
By default it equals the <link id="TField.FieldName">FieldName</link> property, unless assigned another value.
</p>
</descr>
<seealso>
<link id="TField.FieldName"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DisplayWidth : LongInt -->
<element name="TField.DisplayWidth">
<short>Width of the field in characters</short>
<descr>
<var>DisplayWidth</var> is the width (in characters) that should be used by controls that display the contents
of the field (such as in grids or lookup lists). It is initialized to a default value for most fields (e.g. 
it equals <link id="TField.Size">Size</link> for string fields) but can be modified to obtain a more appropriate 
value for the field's expected content.
</descr>
<seealso>
<link id="TField.Alignment"/>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: FieldKind : TFieldKind -->
<element name="TField.FieldKind">
<short>The kind of field.</short>
<descr>
<var>FieldKind</var> indicates the type of the <var>TField</var> instance. Besides <var>TField</var> instances that represent 
fields present in the underlying data records, there can also be calculated or lookup fields. This property determines
what kind of field the TField instance is.
</descr>
<link id="TField.IsLookup"/>
<link id="TField.Calculated"/>
<link id="TField.DataType"/>
<seealso>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: FieldName : String -->
<element name="TField.FieldName">
<short>Name of the field</short>
<descr>
<var>FieldName</var> is the name of the field as it is defined in the underlying data structures (for instance the name
of the field in a SQL table, DBAse file, or the alias of the field if it was aliased in a SQL SELECT statement.
It does not always equal the <var>Name</var> property, which is the name of the <var>TField</var> component instance.
The <var>Name</var> property will generally equal the name of the dataset appended with the value of the <var>FieldName</var> property.
</descr>
<seealso>
<link id="TFieldDef.Name"/>
<link id="TField.Size"/>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: HasConstraints : Boolean -->
<element name="TField.HasConstraints">
<short>Does the field have any constraints defined</short>
<descr>
<var>HasConstraints</var> will contain <var>True</var> if one of the <link id="TField.CustomConstraint">CustomConstraint</link> 
or <link id="TField.ImportedConstraint">ImportedConstraint</link> properties is set to a non-empty value.
</descr>
<seealso>
<link id="TField.CustomConstraint">CustomConstraint</link>
<link id="TField.ImportedConstraint">ImportedConstraint</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Index : LongInt -->
<element name="TField.Index">
<short>Index of the field in the list of fields</short>
<descr>
<var>Index</var> is the name of the field in the list of fields of a dataset. 
It is, in general, the (0-based) position of the field in the underlying datas structures, but this need not always be so. 
The <link id="TField.FieldNo"/> property should be used for that.
</descr>
<seealso>
<link id="TField.FieldNo"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ImportedConstraint : String -->
<element name="TField.ImportedConstraint">
<short>Constraint for the field value on the level of the underlying database</short>
<descr>
<var>ImportedConstraint</var> contains any constraints that the underlying data engine imposes on the values of a field (usually in an SQL CONSTRAINT) clause.
Whether this field is filled with appropriate data depends on the implementation of the <link id="TDataset"/> descendent.
</descr>
<seealso>
<link id="TField.CustomConstraint"/>
<link id="TDataset"/>
<link id="TField.ConstraintErrorMessage"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: KeyFields : String -->
<element name="TField.KeyFields">
<short>Key fields to use when looking up a field value.</short>
<descr>
<var>KeyFields</var> should contain a semi-colon separated list of field names from the lookupfield's dataset which will be matched to the fields 
enumerated in <link id="TField.LookupKeyFields">LookupKeyFields</link> in the dataset pointed to by the <link id="Tfield.LookupDataset">LookupDataset</link> property.
</descr>
<seealso>
<link id="TField.LookupKeyFields">LookupKeyFields</link>
<link id="Tfield.LookupDataset">LookupDataset</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: LookupCache : Boolean -->
<element name="TField.LookupCache">
<short>Should lookup values be cached</short>
<descr>
<var>LookupCache</var> is by default <var>False</var>. If it is set to <var>True</var> then a list of key, value pairs will be created from the
<link id="TField.LookupKeyFields">LookupKeyFields</link> in the dataset pointed to by the <link id="Tfield.LookupDataset">LookupDataset</link> property.
The list of key, value pairs is available through the <link id="TField.LookupList"/> property.
</descr>
<seealso>
<link id="TField.LookupKeyFields">LookupKeyFields</link>
<link id="Tfield.LookupDataset">LookupDataset</link>
<link id="TField.LookupList"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: LookupDataSet : TDataSet -->
<element name="TField.LookupDataSet">
<short>Dataset with lookup values</short>
<descr>
<var>LookupDataset</var> is used by lookup fields to fetch the field's value. The <link id="TField.LookupKeyFields">LookupKeyFields</link> property is
used as a list of fields to locate a record in this dataset, and the value of the <link id="TField.LookupResultField">LookupResultField</link> field is then used as the 
value of the lookup field.
</descr>
<seealso>
<link id="TField.KeyFields">KeyFields</link>
<link id="TField.LookupKeyFields">LookupKeyFields</link>
<link id="TField.LookupResultField">LookupResultField</link>
<link id="TField.LookupCache">LookupCache</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: LookupKeyFields : String -->
<element name="TField.LookupKeyFields">
<short>Names of fields on which to perform a locate</short>
<descr>
<var>LookupKeyFields</var> should contain a semi-colon separated list of field names from the dataset pointed to by the <link id="Tfield.LookupDataset">LookupDataset</link> property.
These fields will be used when locating a record corresponding to the values in the <link id="TField.KeyFields"/> property.
</descr>
<seealso>
<link id="TField.KeyFields">KeyFields</link>
<link id="TField.LookupDataset">LookupDataset</link>
<link id="TField.LookupResultField">LookupResultField</link>
<link id="TField.LookupCache">LookupCache</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: LookupResultField : String -->
<element name="TField.LookupResultField">
<short>Name of field to use as lookup value</short>
<descr>
<var>LookupResultField</var> contains the field name from a field in the dataset pointed to by the <link id="Tfield.LookupDataset">LookupDataset</link> property.
The value of this field will be used as the lookup's field value when a record is found in the lookup dataset as result for the lookup field value.
</descr>
<seealso>
<link id="TField.KeyFields">KeyFields</link>
<link id="TField.LookupDataset">LookupDataset</link>
<link id="TField.LookupKeyFields">LookupKeyFields</link>
<link id="TField.LookupCache">LookupCache</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Origin : String -->
<element name="TField.Origin">
<short>Original fieldname of the field.</short>
<descr>
<var>Origin</var> contains the origin of the field in the form <var>TableName.fieldName</var>.
This property is filled only if the <link id="TDataset"/> descendent or the database engine support retrieval of this property.
It can be used to autmatically create update statements, together with the <link id="TField.ProviderFlags"/> property.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField.ProviderFlags"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ProviderFlags : TProviderFlags -->
<element name="TField.ProviderFlags">
<short>Flags for provider or update support</short>
<descr>
<p>
<var>ProviderFlags</var> contains a set of flags that can be used by engines that automatically generate update SQL statements or update data packets. 
The various items in the set tell the engine whether the key is a key field, should be used in the where clause of an  update statement or  whether - in fact - it should be updated at all.
</p>
<p>
These properties should be set by the programmer so engines such as SQLDB can create correct update SQL statements whenever they need to post changes to the database. 
Note that to be able to set these properties in a designer, persistent fields must be created.
</p>
</descr>
<seealso>
<link id="TField.Origin"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ReadOnly : Boolean -->
<element name="TField.ReadOnly">
<short>Is the field read-only</short>
<descr>
<var>ReadOnly</var> can be set to <var>True</var> to prevent controls of writing data to the field, effectively making it a read-only field. 
Setting this property to <var>True</var> does not prevent the field from getting a value through code: it is just an indication for GUI 
controls that the field's value is considered read-only.
</descr>
<seealso>
<link id="TFieldDef.Attributes"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Required : Boolean -->
<element name="TField.Required">
<short>Does the field require a value</short>
<descr>
<var>Required</var> determines whether the field needs a value when posting the data: when a dataset posts the changed made to a record
(new or existing), it will check whether all fields with the <var>Required</var> property have a value assigned to them. If not, an 
exception will be raised. Descendents of <link id="TDataset"/> will set the property to <var>True</var> when opening the dataset, 
depending on whether the field is required in the underlying data engine. For fields that are not required by the database engine, 
the programmer can still set the property to <var>True</var> if the business logic requires a field.
</descr>
<seealso>
<link id="TDataset.Open"/>
<link id="TField.ReadOnly">ReadOnly</link>
<link id="TField.Visible">Visible</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Visible : Boolean -->
<element name="TField.Visible">
<short>Should the field be shown in grids</short>
<descr>
<var>Visible</var> can be used to hide fields from a grid when displaying data to the user. 
Invisible fields will by default not be shown in the grid.
</descr>
<seealso>
<link id="TField.ReadOnly"/>
<link id="TField.Required"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnChange : TFieldNotifyEvent -->
<element name="TField.OnChange">
<short>Event triggerd when the field's value has changed</short>
<descr>
<var>OnChange</var> is triggered whenever the field's value has been changed. 
It is triggered only after the new contents have been written to the dataset buffer, so it can be used to react to changes in the field's content. 
To prevent the writing of changes to the buffer, use the <link id="TField.OnValidate"/> event. It is not allowed to change the state of the dataset
or the contents of the field during the execution of this event handler: doing so may lead to infinite loops and other unexpected results.
</descr>
<seealso>
<link id="TField.OnChange"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnGetText : TFieldGetTextEvent -->
<element name="TField.OnGetText">
<short>Event to format the field's content</short>
<descr>
<var>OnGetText</var> is triggered whenever the <link id="TField.Text"/> or <link id="TField.DisplayText"/> properties are read. 
It can be used to return a custom formatted string in the <var>AText</var> parameter which will then typically be used by a control to display the field's contents 
to the user. It is not allowed to change the state of the dataset or the contents of the field during the execution of this event handler.
</descr>
<seealso>
<link id="TField.Text"/>
<link id="TField.DisplayText"/>
<link id="TField.OnSetText"/>
<link id="TFieldGetTextEvent"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnSetText : TFieldSetTextEvent -->
<element name="TField.OnSetText">
<short>Event to set the field's content based on a user-formatted string</short>
<descr>
<var>OnSetText</var> is called whenever the <link id="TField.Text"/> property is written. It can be used to set the actual value of the field
based on the passed <var>AText</var> parameter. Typically, this event handler will perform the inverse operation of the <link id="TField.OnGetText"/> handler, if it exists.
</descr>
<seealso>
<link id="TField.Text"/>
<link id="TField.OnGetText"/>
<link id="TFieldGetTextEvent"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnValidate : TFieldNotifyEvent -->
<element name="TField.OnValidate">
<short>Event to validate the value of a field before it is written to the data buffer</short>
<descr>
<var>OnValidate</var> is called prior to writing a new field value to the dataset's data buffer. 
It can be used to prevent writing the new value to the buffer by raising an exception in the event handler.
Note that this event handler is always called, irrespective of the way the value of the field is set.
</descr>
<seealso>
<link id="TField.Text"/>
<link id="TField.OnGetText"/>
<link id="TField.OnSetText"/>
<link id="TField.OnChange"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TStringField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TStringField">
<short>Field class to handle ansistring fields</short>
<descr>
<var>TStringField</var> is the class used whenever a dataset has to handle a string field type (data type <var>ftString</var>). 
This class overrides some of the standard <link id="TField"/> methods to handle string data, 
and introduces some properties that are only pertinent for data fields of string type.
It should never be necessary to create an instance of <var>TStringField</var> manually, a field
of this class will be instantiated automatically for each string field when a dataset is opened.
</descr>
<seealso>
<link id="TField"/>
<link id="TWideStringField"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TStringField.Create">
<short>Create a new instance of the TStringField class</short>
<descr>
<var>Create</var> is used to create a new instance of the <var>TStringField</var> class. It initializes
some <link id="TField"/> properties after having called the inherited constructor.
</descr>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TStringField.Create.AOwner">
<short>Owner for the field class instance</short>
</element>

<!-- property Visibility: public
     Declaration: FixedChar : Boolean -->
<element name="TStringField.FixedChar">
<short>Is the string declared with a fixed length ?</short>
<descr>
<var>FixedChar</var> is <var>True</var> if the underlying data engine has declared the field with a fixed length, as in a SQL CHAR() declaration:
the field's value will then always be padded with as many spaces as needed to obain the declared length of the field. If it is <var>False</var> 
then the declared length is simply the maximum length for the field, and no padding with spaces is performed.
</descr>
</element>

<!-- property Visibility: public
     Declaration: Transliterate : Boolean -->
<element name="TStringField.Transliterate">
<short>Should the field value be transliterated when reading or writing</short>
<descr>
<var>Transliterate</var> can be set to <var>True</var> if the field's contents should be transliterated prior to copying it from or to the field's buffer.
Transliteration is done by a method of <var>TDataset</var>: <link id="TDataset.Translate"/>.
</descr>
<seealso>
<link id="TDataset.Translate"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Value : String -->
<element name="TStringField.Value">
<short>Value of the field as a string</short>
<descr>
<var>Value</var> is overridden in <var>TField</var> to return the value of the field as a string. It returns the contents of <link id="TField.AsString"/> 
when read, or sets the <var>AsString</var> property when written to.
</descr>
<seealso>
<link id="TField.AsString"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Size :  -->
<element name="TStringField.Size">
<short>Maximum size of the string</short>
<descr>
<var>Size</var> is made published by the <var>TStringField</var> class so it can be set in the IDE: it is the declared maximum size of the string (in characters) 
and is used to calculate the size of the dataset buffer.
</descr>
<seealso>
<link id="TField.Size"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TWideStringField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TWideStringField">
<short>Field class for widestring data</short>
<descr>
<var>TWideStringField</var> is the string field class instantiated for fields of data type <var>ftWideString</var>.
This class overrides some of the standard <link id="TField"/> methods to handle widestring data, 
and introduces some properties that are only pertinent for data fields of widestring type.
It should never be necessary to create an instance of <var>TWideStringField</var> manually, a field
of this class will be instantiated automatically for each widestring field when a dataset is opened.
</descr>
<seealso>
<link id="TField"/>
<link id="TStringField"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(aOwner: TComponent);  Override -->
<element name="TWideStringField.Create">
<short>Create a new instance of the <var>TWideStringField</var> class.</short>
<descr>
<var>Create</var> is used to create a new instance of the <var>TWideStringField</var> class. It initializes
some <link id="TField"/> properties after having called the inherited constructor.
</descr>
</element>

<!-- argument Visibility: default
     Declaration: aOwner: TComponent -->
<element name="TWideStringField.Create.aOwner">
<short>Owner of the TWideStringField class instance</short>
</element>

<!-- property Visibility: public
     Declaration: Value : WideString -->
<element name="TWideStringField.Value">
<short>Value of the field as a widestring</short>
<descr>
<var>Value</var> is overridden by the <var>TWideStringField</var> to return a <var>WideString</var> value.
It is the same value as the <link id="TField.AsWideString"/> property.
</descr>
<seealso>
<link id="TField.AsWideString"/>
<link id="TField.Value"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TNumericField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TNumericField">
<short>Base class for all numerical data field classe</short>
<descr>
<p><var>TNumericField</var> is an abstract class which overrides some of the methods of <link id="TField"/> to 
handle numerical data. It also introduces or publishes a couple of properties that are only relevant in 
the case of numerical data, such as <link id="TNumericField.DisplayFormat"/> and <link id="TNumericField.EditFormat"/>.
</p>
<p>
Since <var>TNumericField</var> is an abstract class, it must never be instantiated directly. 
Instead one of the descendent classes should be created.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TNumericField.DisplayFormat"/>
<link id="TNumericField.EditFormat"/>
<link id="TField.Alignment"/>
<link id="TIntegerField"/>
<link id="TLargeIntField"/>
<link id="TFloatField"/>
<link id="TBCDField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TNumericField.Create">
<short>Create a new instance of <var>TNumericField</var></short>
<descr>
<var>Create</var> calls the inherited constructor and then initializes the <link id="TField.Alignment"/> property with
</descr>
<seealso>
<link id="TField.Alignment"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TNumericField.Create.AOwner">
<short>Owner of the field component</short>
</element>

<!-- property Visibility: published
     Declaration: Alignment :  -->
<element name="TNumericField.Alignment">
<short>Alignment of the field</short>
<descr>
<var>Alignment</var> is published by <var>TNumericField</var> with  <var>taRightJustify</var> as a default value.
</descr>
<seealso>
<link id="TField.Alignment"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DisplayFormat : String -->
<element name="TNumericField.DisplayFormat">
<short>Format string for display of numerical data</short>
<descr>
<var>DisplayFormat</var> specifies a format string (such as used by the <link id="#rtl.sysutils.Format">Format</link>
and <link id="#rtl.sysutils.FormatFloat">FormatFloat</link> functions) for display purposes: the <link id="TField.DisplayText"/> 
property will use this property to format the field's value. Which formatting function (and, consequently, which format can be 
entered) is used depends on the descendent of the <var>TNumericField</var> class.
</descr>
<seealso>
<link id="#rtl.sysutils.Format">Format</link>
<link id="#rtl.sysutils.FormatFloat">FormatFloat</link>
<link id="TField.DisplayText"/>
<link id="TNumericField.EditFormat"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: EditFormat : String -->
<element name="TNumericField.EditFormat">
<short>Format string for editing of numerical data</short>
<descr>
<var>EditFormat</var> specifies a format string (such as used by the <link id="#rtl.sysutils.Format">Format</link>
and <link id="#rtl.sysutils.FormatFloat">FormatFloat</link> functions) for editing purposes: the <link id="TField.Text"/> 
property will use this property to format the field's value. Which formatting function (and, consequently, which format can be 
entered) is used depends on the descendent of the <var>TNumericField</var> class.
</descr>
<seealso>
<link id="#rtl.sysutils.Format">Format</link>
<link id="#rtl.sysutils.FormatFloat">FormatFloat</link>
<link id="TField.Text"/>
<link id="TNumericField.DisplayFormat"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TLongintField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TLongintField">
<short>Field class for 32-bit signed integer data</short>
<descr>
<p>
<var>TLongintField</var> is instantiated when a dataset must manage a field with 32-bit signed data: 
the data type <var>ftInteger</var>. It overrides some methods of <link id="TField"/> to handle integer 
data, and sets some of the properties to values for integer data. It also introduces some methods and
properties specific to integer data such as <link id="TLongintField.MinValue">MinValue</link> and
<link id="TLongintField.MaxValue">MaxValue</link>.
</p>
<p>
It should never be necessary to create an instance of <var>TLongintField</var> manually, a field
of this class will be instantiated automatically for each integer field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TLongintField.MaxValue">MaxValue</link>
<link id="TLongintField.MinValue">MinValue</link>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TLongintField.Create">
<short>Create a new instance of <var>TLongintField</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TLongintField</var>. 
After calling the inherited constructor, it initializes the <link id="TLongintField.MinValue">MinValue</link> 
and <link id="TLongintField.MaxValue">MaxValue</link> properties.
</descr>
<seealso>
<link id="TField"/>
<link id="TLongintField.MaxValue">MaxValue</link>
<link id="TLongintField.MinValue">MinValue</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TLongintField.Create.AOwner">
<short>Owner of the field component.</short>
</element>

<!-- function Visibility: public
     Declaration: function CheckRange(AValue: LongInt) : Boolean -->
<element name="TLongintField.CheckRange">
<short>Check whether a valid is in the allowed range of values for the field</short>
<descr>
<var>CheckRange</var> returns <var>True</var> if <var>AValue</var> lies within the range defined by 
the <link id="TLongintField.MinValue">MinValue</link> and <link id="TLongintField.MaxValue">MaxValue</link> 
properties. If the value lies outside of the allowed range, then <var>False</var> is returned.
</descr>
<seealso>
<link id="TLongintField.MaxValue">MaxValue</link>
<link id="TLongintField.MinValue">MinValue</link>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TLongintField.CheckRange.Result">
<short><var>true</var> if <var>AValue</var> is in the allowed range of values.</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: LongInt -->
<element name="TLongintField.CheckRange.AValue">
<short>Value to check</short>
</element>

<!-- property Visibility: public
     Declaration: Value : LongInt -->
<element name="TLongintField.Value">
<short>Value of the field as longint</short>
<descr>
<var>Value</var> is redefined by <var>TLongintField</var> as a 32-bit signed integer value. 
It returns the same value as the <link id="TField.AsInteger"/> property.
</descr>
<seealso>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MaxValue : LongInt -->
<element name="TLongintField.MaxValue">
<short>Maximum value for the field</short>
<descr>
<var>MaxValue</var> is the maximum value for the field. 
When setting the field's value, the value may not be larger than <var>MaxValue</var>. 
Any attempt to write a larger value as the field's content will result in an exception.
By default <var>MaxValue</var> equals <var>MaxInt</var>, i.e. any integer value is allowed.
</descr>
<seealso>
<link id="TLongintField.MinValue">MinValue</link>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MinValue : LongInt -->
<element name="TLongintField.MinValue">
<short>Minimum value for the field</short>
<descr>
<var>MinValue</var> is the minimum value for the field. 
When setting the field's value, the value may not be less than <var>MinValue</var>. 
Any attempt to write a smaller value as the field's content will result in an exception.
By default <var>MinValue</var> equals <var>-MaxInt</var>, i.e. any integer value is allowed.
</descr>
<seealso>
<link id="TLongintField.MaxValue">MaxValue</link>
</seealso>
</element>

<!-- alias type Visibility: default
     Declaration: TIntegerField = TLongintField -->
<element name="TIntegerField">
<short>Alias for <var>TLongintField</var></short>
<descr>
<var>TIntegerField</var> is an alias for <link id="TLongintField"/>. 
</descr>
<seealso>
<link id="TLongintField"/>
<link id="TField"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TLargeintField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TLargeintField">
<short>Field class for 64-bit signed integer data</short>
<descr>
<p>
<var>TLargeIntField</var> is instantiated when a dataset must manage a field with 64-bit signed data: 
the data type <var>ftLargeInt</var>. It overrides some methods of <link id="TField"/> to handle int64
data, and sets some of the properties to values for int64 data. It also introduces some methods and
properties specific to 64-bit integer data such as <link id="TLargeIntField.MinValue">MinValue</link> and
<link id="TLargeIntField.MaxValue">MaxValue</link>.
</p>
<p>
It should never be necessary to create an instance of <var>TLargeIntField</var> manually, a field
of this class will be instantiated automatically for each int64 field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TLargeIntField.MinValue">MinValue</link>
<link id="TLargeIntField.MaxValue">MaxValue</link>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TLargeintField.Create">
<short>Create a new instance of the <var>TLargeintField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TLargeIntField</var> class: it calls the inherited constructor
and then initializes the various properties of <link id="Tfield"/> and <link id="TLargeIntField.MinValue">MinValue</link> and
<link id="TLargeIntField.MaxValue">MaxValue</link>.
</descr>
<seealso>
<link id="TField"/>
<link id="TLargeIntField.MinValue">MinValue</link>
<link id="TLargeIntField.MaxValue">MaxValue</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TLargeintField.Create.AOwner">
<short>Owner of the <var>TLargeIntField</var> component</short>
</element>

<!-- function Visibility: public
     Declaration: function CheckRange(AValue: LargeInt) : Boolean -->
<element name="TLargeintField.CheckRange">
<short>Check whether a values falls within the allowed range</short>
<descr>
<var>CheckRange</var> returns <var>True</var> if <var>AValue</var> lies within the range defined by 
the <link id="TLargeIntField.MinValue">MinValue</link> and <link id="TLargeIntField.MaxValue">MaxValue</link> 
properties. If the value lies outside of the allowed range, then <var>False</var> is returned.
</descr>
<seealso>
<link id="TLargeIntField.MaxValue">MaxValue</link>
<link id="TLargeIntField.MinValue">MinValue</link>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TLargeintField.CheckRange.Result">
<short><var>true</var> if <var>AValue</var> is in the allowed range of values.</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: LargeInt -->
<element name="TLargeintField.CheckRange.AValue">
<short>Value to check</short>
</element>

<!-- property Visibility: public
     Declaration: Value : LargeInt -->
<element name="TLargeintField.Value">
<short>Field contents as a 64-bit integer value</short>
<descr>
<var>Value</var> is redefined by <var>TLargeIntField</var> as a 64-bit integer value. 
It returns the same value as <link id="TField.AsLargeInt"/>.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsLargeInt"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MaxValue : LargeInt -->
<element name="TLargeintField.MaxValue">
<short>Maximum value for the field</short>
<descr>
<p>
<var>MaxValue</var> is the maximum value for the field if set to any value different from zero.
When setting the field's value, the value may not be larger than <var>MaxValue</var>. 
Any attempt to write a larger value as the field's content will result in an exception.
By default <var>MaxValue</var> equals <var>0</var>, i.e. any integer value is allowed.
</p>
<p>
If <var>MaxValue</var> is set, <link id="TLargeIntField.MinValue">MinValue</link> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TLargeIntField.MinValue"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MinValue : LargeInt -->
<element name="TLargeintField.MinValue">
<short>Minimum value for the field</short>
<descr>
<p>
<var>MinValue</var> is the minimum value for the field. 
When setting the field's value, the value may not be less than <var>MinValue</var>. 
Any attempt to write a smaller value as the field's content will result in an exception.
By default <var>MinValue</var> equals <var>0</var>, i.e. any integer value is allowed.
</p>
<p>
If <var>MinValue</var> is set, <link id="TLargeIntField.MaxValue">MaxValue</link> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TLargeIntField.MaxValue"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TSmallintField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TSmallintField">
<short>Field class for smallint (16-bit signed integer) data</short>
<descr>
<p>
<var>TSmallIntField</var> is the class created when a dataset must manage 16-bit signed integer data, of datatype <var>ftSmallInt</var>.
It exposes no new properties, but simply overrides some methods to manage 16-bit signed integer data.
</p>
<p>
It should never be necessary to create an instance of <var>TSmallIntField</var> manually, a field
of this class will be instantiated automatically for each smallint field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TNumericField"/>
<link id="TLongintField"/>
<link id="TWordField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TSmallintField.Create">
<short>Create a new instance of the <var>TSmallintField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <link id="TSmallintField"/> class. 
It calls the inherited constructor and then simply sets some of the <link id="TField"/> 
properties to work with 16-bit signed integer data.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TSmallintField.Create.AOwner">
<short>Owner of the field component.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TWordField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TWordField">
<short>Field class for word (16-bit unsigned integer) data</short>
<descr>
<p>
<var>TWordField</var> is the class created when a dataset must manage 16-bit unsigned integer data, of datatype <var>ftWord</var>.
It exposes no new properties, but simply overrides some methods to manage 16-bit unsigned integer data.
</p>
<p>
It should never be necessary to create an instance of <var>TWordField</var> manually, a field
of this class will be instantiated automatically for each word field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TNumericField"/>
<link id="TLongintField"/>
<link id="TSmallIntField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TWordField.Create">
<short>Create a new instance of the <var>TWordField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <link id="TWordField"/> class. 
It calls the inherited constructor and then simply sets some of the <link id="TField"/> 
properties to work with 16-bit unsigned integer data.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TWordField.Create.AOwner">
<short>Owner of the field instance.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TAutoIncField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TAutoIncField">
<short>Field for auto-incremental, 32-bit signed integer data</short>
<descr>
<p>
<var>TAutoIncField</var> is the class created when a dataset must manage 32-bit signed integer data, 
of datatype <var>ftAutoInc</var>: This field gets it's data automatically by the database engine. 
It exposes no new properties, but simply overrides some methods to manage 32-bit signed integer data.
</p>
<p>
It should never be necessary to create an instance of <var>TAutoIncField</var> manually, a field
of this class will be instantiated automatically for each auto-incremental field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TAutoIncField.Create">
<short>Create a new instance of the <var>TAutoIncField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TAutoIncField</var> class. 
It simply calls the inherited constructor and then sets up some of the <link id="TField"/> class' fields.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TAutoIncField.Create.AOwner">
<short>Owner of the newly created fields.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TFloatField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFloatField">
<short>Class for floating point values</short>
<descr>
<p>
<var>TFloatField</var> is the class created when a dataset must manage floating point values of double precision.
It exposes a few new properties such as <link id="TFloatField.Currency">Currency</link>, 
<link id="TFloatField.MaxValue">MaxValue</link>,
<link id="TFloatField.MinValue">MinValue</link> and overrides some <link id="TField"/> methods to work with floating point data.
</p>
<p>
It should never be necessary to create an instance of <var>TFloatField</var> manually, a field
of this class will be instantiated automatically for each floating-point field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TFloatField.Currency">Currency</link>
<link id="TFloatField.MaxValue">MaxValue</link>
<link id="TFloatField.MinValue">MinValue</link>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TFloatField.Create">
<short>Create a new instance of the <var>TFloatField</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TFloatField</var>. 
It calls the inherited constructor and then initializes some properties.
</descr>
<link id="TField"/>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TFloatField.Create.AOwner">
<short>Owner of the field instance</short>
</element>

<!-- function Visibility: public
     Declaration: function CheckRange(AValue: Double) : Boolean -->
<element name="TFloatField.CheckRange">
<short>Check whether a value is in the allowed range of values for the field</short>
<descr>
<var>CheckRange</var> returns <var>True</var> if <var>AValue</var> lies within the range defined by 
the <link id="TFloatField.MinValue">MinValue</link> and <link id="TFloatField.MaxValue">MaxValue</link> 
properties. If the value lies outside of the allowed range, then <var>False</var> is returned.
</descr>
<seealso>
<link id="TFloatField.MaxValue">MaxValue</link>
<link id="TFloatField.MinValue">MinValue</link>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TFloatField.CheckRange.Result">
<short><var>true</var> if <var>AValue</var> is in the allowed range of values.</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: Double -->
<element name="TFloatField.CheckRange.AValue">
<short>Value to check</short>
</element>

<!-- property Visibility: public
     Declaration: Value : Double -->
<element name="TFloatField.Value">
<short>Value of the field as a double type</short>
<descr>
<var>Value</var> is redefined by <var>TFloatField</var> to return a value of type <var>Double</var>. 
It returns the same value as <link id="TField.AsFloat"/>
</descr>
<seealso>
<link id="TField.AsFloat"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Currency : Boolean -->
<element name="TFloatField.Currency">
<short>Is the field a currency field.</short>
<descr>
<var>Currency</var> can be set to <var>True</var> to indicate that the field contains data representing 
an amount of currency. This affects the way the <link id="TField.DisplayText"/> and <link id="TField.Text"/> 
properties format the value of the field: if the <var>Currency</var> property is <var>True</var>, then these 
properties will format the value as a currency value (generally appending the currency sign) and if the 
<var>Currency</var> property is <var>False</var>, then they will format it as a normal floating-point value.
</descr>
<seealso>
<link id="TField.DisplayText"/>
<link id="TField.Text"/>
<link id="TNumericField.DisplayFormat"/>
<link id="TNumericField.EditFormat"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MaxValue : Double -->
<element name="TFloatField.MaxValue">
<short>Maximum value for the field</short>
<descr>
<p>
<var>MaxValue</var> can be set to a value different from zero, it is then the maximum value for 
the field if set to any value different from zero. When setting the field's value, the value may 
not be larger than <var>MaxValue</var>. 
Any attempt to write a larger value as the field's content will result in an exception.
By default <var>MaxValue</var> equals <var>0</var>, i.e. any floating-point value is allowed.
</p>
<p>
If <var>MaxValue</var> is set, <link id="TFloatField.MinValue">MinValue</link> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TFloatField.MinValue"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MinValue : Double -->
<element name="TFloatField.MinValue">
<short>Minimum value for the field</short>
<descr>
<p>
<var>MinValue</var> can be set to a value different from zero, then it is the minimum value for the field. 
When setting the field's value, the value may not be less than <var>MinValue</var>. 
Any attempt to write a smaller value as the field's content will result in an exception.
By default <var>MinValue</var> equals <var>0</var>, i.e. any floating-point value is allowed.
</p>
<p>
If <var>MinValue</var> is set, <link id="TFloatField.MaxValue">MaxValue</link> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TFloatField.MaxValue"/>
<link id="TFloatField.CheckRange"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Precision : LongInt -->
<element name="TFloatField.Precision">
<short>Precision (number of digits) of the field in text representations</short>
<descr>
<var>Precision</var> is the maximum number of digits that should be used when the field is converted to a textual representation in <link id="TField.Displaytext"/>
or <link id="TField.Text"/>, it is used in the arguments to <link id="#rtl.sysutils.FormatFloat">FormatFloat</link>.
</descr>
<seealso>
<link id="TField.Displaytext"/>
<link id="TField.Text"/>
<link id="#rtl.sysutils.FormatFloat">FormatFloat</link>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TCurrencyField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TCurrencyField">
<short>Class for currency fields</short>
<descr>
<p>
<var>TCurrencyField</var> is the field class used by <link id="TDataset"/> when it needs to
manage currency-valued data.(<link id="TField.Datatype"/> equals <var>ftCurrency</var>).
It simply sets some <link id="Tfield"/> properties to be able to work with currency data.
</p>
<p>
It should never be necessary to create an instance of <var>TCurrencyField</var> manually, a field
of this class will be instantiated automatically for each currency field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TCurrencyField.Create">
<short>Create a new instance of a <var>TCurrencyField</var>.</short>
<descr>
<var>Create</var> initializes a new instance of <var>TCurrencyField</var>. 
It calls the inherited constructor and then sets some properties (<link id="TCurrencyField.Currency"/>)
to be able to work with currency data.
</descr>
<seealso>
<link id="TField"/>
<link id="TCurrencyField.Currency"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TCurrencyField.Create.AOwner">
<short>Owner of the new field instance</short>
</element>

<!-- property Visibility: published
     Declaration: Currency :  -->
<element name="TCurrencyField.Currency">
<short>Is the field a currency field</short>
<descr>
<var>Currency</var> is inherited from <link id="TFloatField.Currency"/> but is initialized 
to <var>True</var> by the <var>TCurrencyField</var> constructor. It can be set to <var>False</var> if the contents of the field is of type currency, 
but does not represent an amount of currency.
</descr>
<seealso>
<link id="TFloatField.Currency"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TBooleanField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBooleanField">
<short>Boolean field class type</short>
<descr>
<p>
<var>TBooleanField</var> is the field class used by <link id="TDataset"/> whenever 
it needs to manage boolean data (<link id="TField.DataType"/> equals <var>ftBoolean</var>).
It overrides some properties and methods of <link id="TField"/> to be able to work with boolean data.
</p>
<p>
It should never be necessary to create an instance of <var>TBooleanField</var> manually, a field
of this class will be instantiated automatically for each boolean field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TBooleanField.Create">
<short>Create a new instance of the <var>TBooleanField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TBooleanField</var> class. It calls the inherited constructor and then sets some <link id="TField"/>
properties to configure it for working with boolean values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TBooleanField.Create.AOwner">
<short>Owner of the field instance</short>
</element>

<!-- property Visibility: public
     Declaration: Value : Boolean -->
<element name="TBooleanField.Value">
<short>Value of the field as a boolean value</short>
<descr>
<var>Value</var> is redefined from <link id="TField.Value"/> by <var>TBooleanField</var> as a boolean value. 
It returns the same value as the <link id="TField.AsBoolean"/> property.
</descr>
<seealso>
<link id="TField.AsBoolean"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DisplayValues : String -->
<element name="TBooleanField.DisplayValues">
<short>Textual representation of the true and false values</short>
<descr>
<p>
<var>DisplayValues</var> contains 2 strings, separated by a semicolon (;) 
which are used to display the <var>True</var> and <var>False</var> values of the fields. 
The first string is  used for <var>True</var> values, the second value is used for <var>False</var> values. 
If only one value is given, it will serve as the representation of the <var>True</var> value, the <var>False</var> 
value will be represented as an empty string.
</p>
<p>
A value of <var>Yes;No</var> will result in <var>True</var> values being displayed as 'Yes', and <var>False</var> values as 'No'. 
When writing the value of the field as a string, the string will 
be compared (case insensitively) with the value for <var>True</var>, and if it matches, the field's value will be set to <var>True</var>. 
After this it will be compared to the value for <var>False</var>, and if it matches, the field's value will be set to <var>False</var>. 
If the text matches neither of the two values, an exception will be raised.
</p>
</descr>
<seealso>
<link id="TField.AsString"/>
<link id="TField.Text"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDateTimeField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDateTimeField">
<short>Field class for date/time/Datetime values</short>
<descr>
<p>
<var>TDateTimeField</var> is the class used when a dataset must manage data of type datetime. (<link id="TField.DataType"/> equals <var>ftDateTime</var>). 
It also serves as base class for the <link id="TDateField"/> or <link id="TTimeField"/> classes. It overrides some of the properties and methods of the
<link id="TField"/> class to be able to work with date/time fields.
</p>
<p>
It should never be necessary to create an instance of <var>TDateTimeField</var> manually, a field
of this class will be instantiated automatically for each datetime field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TDateField"/>
<link id="TTimeField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDateTimeField.Create">
<short>Create a new instance of a <var>TDateTimeField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TDateTimeField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with date/time values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDateTimeField.Create.AOwner">
<short>Owner of the field instance</short>
</element>

<!-- property Visibility: public
     Declaration: Value : TDateTime -->
<element name="TDateTimeField.Value">
<short>Contents of the field as a TDateTime value</short>
<descr>
<var>Value</var> is redefined from <link id="TField.Value"/> by <var>TDateTimeField</var> as a <var>TDateTime</var> value. 
It returns the same value as the <link id="TField.AsDateTime"/> property.
</descr>
<seealso>
<link id="TField.AsDateTime"/>
<link id="TField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DisplayFormat : String -->
<element name="TDateTimeField.DisplayFormat">
<short>Formatting string for textual representation of the field</short>
<descr>
<var>DisplayFormat</var> can be set to a formatting string that will then be used by 
the <link id="TField.DisplayText"/> property to format the value with the 
<link id="#rtl.sysutils.datetimetostring">DateTimeToString</link>function.
</descr>
<seealso>
<link id="#rtl.sysutils.datetimetostring">DateTimeToString</link>
<link id="#rtl.sysutils.formatdatetime">FormatDateTime</link>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDateField
  *******************************************************************
-->

<!-- class Visibility: default -->
<element name="TDateField">
<short>Field class for date values</short>
<descr>
<p>
<var>TDateField</var> is the class used when a dataset must manage data of type date. (<link id="TField.DataType"/> equals <var>ftDate</var>). 
It initializes some of the properties of the <link id="TField"/> class to be able to work with date fields.
</p>
<p>
It should never be necessary to create an instance of <var>TDateField</var> manually, a field
of this class will be instantiated automatically for each date field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TDateTimeField"/>
<link id="TTimeField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDateField.Create">
<short>Create a new instance of a <var>TDateField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TDateField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with date values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDateField.Create.AOwner">
<short>Owner for the new field instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TTimeField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TTimeField">
<short>Field class for time values</short>
<descr>
<p>
<var>TimeField</var> is the class used when a dataset must manage data of type time. (<link id="TField.DataType"/> equals <var>ftTime</var>). 
It initializes some of the properties of the <link id="TField"/> class to be able to work with time fields.
</p>
<p>
It should never be necessary to create an instance of <var>TTimeField</var> manually, a field
of this class will be instantiated automatically for each time field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TDateTimeField"/>
<link id="TDateField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TTimeField.Create">
<short>Create a new instance of a <var>TTimeField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TTimeField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with time values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TTimeField.Create.AOwner">
<short>Owner for the new field instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TBinaryField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBinaryField">
<short>Field class for working with binary field data</short>
<descr>
<p>
<var>TBinaryField</var> is an abstract class, designed to handle binary data of variable size.  It overrides some of the properties and methods of the
<link id="TField"/> class to be able to work with binary field data, such as retrieving the contents as a string or as a variant.
</p>
<p>
One must never create an instance of <var>TBinaryField</var> manually, it is an abstract class. Instead, a descendent class such as 
<link id="TBytesField"/> or <link id="TVarBytesField"/> should be created.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TBytesField"/>
<link id="TVarBytesField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TBinaryField.Create">
<short>Create a new instance of a <var>TBinaryField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TBinaryField</var> class.
It simply calls the inherited destructor.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TBinaryField.Create.AOwner">
<short>Owner for the new field instance.</short>
</element>

<!-- property Visibility: published
     Declaration: Size :  -->
<element name="TBinaryField.Size">
<short>Size of the binary data</short>
<descr>
<var>Size</var> is simply redeclared published with a default value of 16.
</descr>
<seealso>
<link id="TField.Size"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TBytesField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBytesField">
<short>Field class for fixed size byte array values</short>
<descr>
<p>
<var>TBytesField</var> is the class used when a dataset must manage data of fixed-size binary type. (<link id="TField.DataType"/> equals <var>ftBytes</var>). 
It initializes some of the properties of the <link id="TField"/> class to be able to work with fixed-size byte fields.
</p>
<p>
It should never be necessary to create an instance of <var>TBytesField</var> manually, a field
of this class will be instantiated automatically for each binary data field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TVarBytesField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TBytesField.Create">
<short>Create a new instance of a <var>TBytesField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TBytesField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with binary data values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TBytesField.Create.AOwner">
<short>Owner of the niew field instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TVarBytesField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TVarBytesField">
<short>Field class for variable size byte array values</short>
<descr>
<p>
<var>TVarBytesField</var> is the class used when a dataset must manage data of variable-size binary type. (<link id="TField.DataType"/> equals <var>ftVarBytes</var>). 
It initializes some of the properties of the <link id="TField"/> class to be able to work with variable-size byte fields.
</p>
<p>
It should never be necessary to create an instance of <var>TVarBytesField</var> manually, a field
of this class will be instantiated automatically for each variable-sized binary data field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TBytesField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TVarBytesField.Create">
<short>Create a new instance of a <var>TVarBytesField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TVarBytesField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with variable-size binary data values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TVarBytesField.Create.AOwner">
<short>Owner of the new field instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TBCDField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBCDField">
<short>Field class for Binary Coded Decimal (BCD) values</short>
<descr>
<p>
<var>TBCDField</var> is the class used when a dataset must manage data of Binary Coded Decimal  type. (<link id="TField.DataType"/> equals <var>ftBCD</var>). 
It initializes some of the properties of the <link id="TField"/> class, and overrides some of its methods to be able to work with BCD fields.
</p>
<p>
<var>TBCDField</var> assumes that the field's contents can be stored in a currency type, i.e. the maximum number of decimals 
after the decimal separator that can be stored in a <var>TBCDField</var> is 4. Fields that need to store a larger amount
of decimals should be represented by a <link id="TFMTBCDField"/> instance.
</p>
<p>
It should never be necessary to create an instance of <var>TBCDField</var> manually, a field
of this class will be instantiated automatically for each BCD field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TFMTBCDField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TBCDField.Create">
<short>Create a new instance of a <var>TBCDField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TBCDField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with BCD data values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TBCDField.Create.AOwner">
<short>Owner of the new field instance</short>
</element>

<!-- function Visibility: public
     Declaration: function CheckRange(AValue: Currency) : Boolean -->
<element name="TBCDField.CheckRange">
<short>Check whether a values falls within the allowed range</short>
<descr>
<var>CheckRange</var> returns <var>True</var> if <var>AValue</var> lies within the range defined by 
the <link id="TBCDField.MinValue">MinValue</link> and <link id="TBCDField.MaxValue">MaxValue</link> 
properties. If the value lies outside of the allowed range, then <var>False</var> is returned.
</descr>
<seealso>
<link id="TBCDField.MaxValue">MaxValue</link>
<link id="TBCDField.MinValue">MinValue</link>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TBCDField.CheckRange.Result">
<short><var>True</var> if <var>AValue</var> falls in the allowed range of values</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: Currency -->
<element name="TBCDField.CheckRange.AValue">
<short>Value to check</short>
</element>

<!-- property Visibility: public
     Declaration: Value : Currency -->
<element name="TBCDField.Value">
<short>Value of the field contents as a Currency type</short>
<descr>
<var>Value</var> is overridden from the <link id="TField.Value"/> property to a currency type field.
It returns the same value as the <link id="TField.AsCurrency"/> field. 
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsCurrency"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Precision : LongInt -->
<element name="TBCDField.Precision">
<short>Precision of the BCD field</short>
<descr>
<var>Precision</var> is the total number of decimals in the BCD value. 
It is not the same as <link id="TBCDField.Size"/>, which is the number of decimals after the decimal point.
The <var>Precision</var> property should be set by the descendent classes when they initialize the field, 
and should be considered read-only. Changing the value will influence the values returned by the various 
<var>AsXXX</var> properties.
</descr>
<seealso>
<link id="TBCDField.Size"/>
<link id="TBCDField.Value"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Currency : Boolean -->
<element name="TBCDField.Currency">
<short>Does the field represent a currency amount</short>
<descr>
<var>Currency</var> can be set to <var>True</var> to indicate that the field contains data representing 
an amount of currency. This affects the way the <link id="TField.DisplayText"/> and <link id="TField.Text"/> 
properties format the value of the field: if the <var>Currency</var> property is <var>True</var>, then these 
properties will format the value as a currency value (generally appending the currency sign) and if the 
<var>Currency</var> property is <var>False</var>, then they will format it as a normal floating-point value.
</descr>
<seealso>
<link id="TField.DisplayText"/>
<link id="TField.Text"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MaxValue : Currency -->
<element name="TBCDField.MaxValue">
<short>Maximum value for the field</short>
<descr>
<p>
<var>MaxValue</var> can be set to a value different from zero, it is then the maximum value for 
the field if set to any value different from zero. When setting the field's value, the value may 
not be larger than <var>MaxValue</var>. 
Any attempt to write a larger value as the field's content will result in an exception.
By default <var>MaxValue</var> equals <var>0</var>, i.e. any floating-point value is allowed.
</p>
<p>
If <var>MaxValue</var> is set, <link id="TBCDField.MinValue">MinValue</link> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TBCDField.MinValue"/>
<link id="TBCDField.CheckRange"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: MinValue : Currency -->
<element name="TBCDField.MinValue">
<short>Minimum value for the field</short>
<descr>
<p>
<var>MinValue</var> can be set to a value different from zero, then it is the minimum value for the field. 
When setting the field's value, the value may not be less than <var>MinValue</var>. 
Any attempt to write a smaller value as the field's content will result in an exception.
By default <var>MinValue</var> equals <var>0</var>, i.e. any floating-point value is allowed.
</p>
<p>
If <var>MinValue</var> is set, <link id="TBCDField.MaxValue"/> should also be set, because it will also be checked.
</p>
</descr>
<seealso>
<link id="TBCDField.MaxValue"/>
<link id="TBCDField.CheckRange"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Size :  -->
<element name="TBCDField.Size">
<short>Number of decimals after the decimal separator</short>
<descr>
<var>Size</var> is the number of decimals after the decimal separator. 
It is not the total number of decimals, which is stored in the <link id="TBCDField.Precision"/> field.
</descr>
<seealso>
<link id="TBCDField.Precision"/>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TBlobStreamMode = (bmRead,bmWrite,bmReadWrite) -->
<element name="TBlobStreamMode">
<short>Mode used when creating a blob stream</short>
<descr>
<var>TBlobStramMode</var> is used when creating a stream for redaing BLOB data. 
It indicates what the data will be used for: reading, writing or both.
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: bmRead -->
<element name="TBlobStreamMode.bmRead">
<short>Read blob data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: bmWrite -->
<element name="TBlobStreamMode.bmWrite">
<short>Write blob data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: bmReadWrite -->
<element name="TBlobStreamMode.bmReadWrite">
<short>Read and write blob data</short>
</element>

<!-- range type Visibility: default
     Declaration: TBlobType = ..ftWideMemo -->
<element name="TBlobType">
<short>Valid BLOB fieldtypes</short>
<descr>
<var>TBlobType</var> is a subrange type, indicating the various datatypes of BLOB fields.
</descr>
<seealso>
<link id="TFieldType"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TBlobField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBlobField">
<short>Base class for BLOB field data</short>
<descr>
<p>
<var>TBLobField</var> is the class used when a dataset must manage BLOB data. (<link id="TField.DataType"/> equals <var>ftBLOB</var>). 
It initializes some of the properties of the <link id="TField"/> class, and overrides some of its methods to be able to work with BLOB fields.
It also serves as parent class for some specialized blob-like field types such as <link id="TMemoField"/>, <link id="TWideMemoField"/> or 
<link id="TGraphicField"/>
</p>
<p>
It should never be necessary to create an instance of <var>TBlobField</var> manually, a field
of this class will be instantiated automatically for each BLOB field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TMemoField"/>
<link id="TWideMemoField"/>
<link id="TGraphicField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TBlobField.Create">
<short>Create a new instance of a <var>TBlobField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TBlobField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with BLOB data.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TBlobField.Create.AOwner">
<short>Owner of the new field instance</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Clear;  Override -->
<element name="TBlobField.Clear">
<short>Clear the BLOB field's contents</short>
<descr>
<var>Clear</var> overrides the <var>TField</var> implementation of <link id="TField.Clear"/>. 
It creates and immediately releases an empty blob stream in write mode, effectively clearing the contents of the BLOB field.
</descr>
<seealso>
<link id="TField.Clear"/>
<link id="TField.IsNull"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function IsBlob : Boolean;  Override -->
<element name="TBlobField.IsBlob">
<short>Is the field a blob field</short>
<descr>
<var>IsBlob</var> is overridden by <var>TBlobField</var> to return <var>True</var>
</descr>
<seealso>
<link id="TField.IsBlob"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TBlobField.IsBlob.Result">
<short>Always <var>True</var></short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure LoadFromFile(const FileName: String) -->
<element name="TBlobField.LoadFromFile">
<short>Load the contents of the field frop a file</short>
<descr>
<var>LoadFromFile</var> creates a file stream with <var>FileName</var> 
as the name of the file to open, en then calls <link id="TBlobField.LoadFromStream">LoadFromStream</link>
to read the contents of the blob field from the file. The file is opened in read-only mode.
</descr>
<errors>
If the file does not exist or is nor available for reading, an exception will be raised.
</errors>
<seealso>
<link id="TBlobField.LoadFromStream">LoadFromStream</link>
<link id="TBlobField.SaveToFile">SaveToFile</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: FileName: String -->
<element name="TBlobField.LoadFromFile.FileName">
<short>Name of file to read data from</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure LoadFromStream(Stream: TStream) -->
<element name="TBlobField.LoadFromStream">
<short>Load the field's contents from stream</short>
<descr>
<var>LoadFromStream</var> can be used to load the contents of the field from a <link
id="#rtl.classes.TStream">TStream</link> descendent.
The entire data of the stream will be copied, and the stream will be positioned on the first byte of data, so it must be seekable.
</descr>
<errors>
If the stream is not seekable, an exception will be raised.
</errors>
<seealso>
<link id="TBlobField.SaveToStream">SaveToStream</link>
<link id="TBlobField.LoadFromFile">LoadFromFile</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Stream: TStream -->
<element name="TBlobField.LoadFromStream.Stream">
<short>Stream instance to load data from</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SaveToFile(const FileName: String) -->
<element name="TBlobField.SaveToFile">
<short>Save field contents to a file</short>
<descr>
<var>SaveToFile</var> creates a file stream with <var>FileName</var> 
as the name of the file to open, en then calls <link id="TBlobField.SaveToStream">SaveToStream</link>
to write the contents of the blob field to the file. The file is opened in write mode and is created if it does not yet exist.
</descr>
<errors>
If the file cannot be created or is not available for writing, an exception will be raised.
</errors>
<seealso>
<link id="TBlobField.LoadFromFile">LoadFromFile</link>
<link id="TBlobField.SaveToStream">SaveToStream</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: FileName: String -->
<element name="TBlobField.SaveToFile.FileName">
<short>Name of file to write data to</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SaveToStream(Stream: TStream) -->
<element name="TBlobField.SaveToStream">
<short>Save the field's contents to stream</short>
<descr>
<var>SaveToStream</var> can be used to save the contents of the field to a <link id="#rtl.classes.TStream">TStream</link> descendent.
The entire data of the field will be copied. The stream must of course support writing.
</descr>
<errors>
If the stream is not writable, an exception will be raised.
</errors>
<seealso>
<link id="TBlobField.SaveToFile">SaveToFile</link>
<link id="TBlobField.LoadFromStream">LoadFromStream</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Stream: TStream -->
<element name="TBlobField.SaveToStream.Stream">
<short>Stream to save data to</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetFieldType(AValue: TFieldType);  Override -->
<element name="TBlobField.SetFieldType">
<short>Set field type</short>
<descr>
<var>SetFieldType</var> is overridden by <var>TBlobField</var> to check whether a valid Blob field type is set. 
If so, it calls the inherited method.
</descr>
<seealso>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AValue: TFieldType -->
<element name="TBlobField.SetFieldType.AValue">
<short>Value for the <var>DataType</var> property</short>
</element>

<!-- property Visibility: public
     Declaration: BlobSize : LongInt -->
<element name="TBlobField.BlobSize">
<short>Size of the current blob</short>
<descr>
<var>BlobSize</var> is the size (in bytes) of the current contents of the field.
It will vary as the dataset's current record moves from record to record.
</descr>
<seealso>
<link id="TField.Size"/>
<link id="TField.DataSize"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Modified : Boolean -->
<element name="TBlobField.Modified">
<short>Has the field's contents been modified.</short>
<descr>
<var>Modified</var> indicates whether the field's contents have been modified for the current record. 
</descr>
<seealso>
<link id="TBlobField.LoadFromStream"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Value : String -->
<element name="TBlobField.Value">
<short>Return the field's contents as a string</short>
<descr>
<var>Value</var> is redefined by <var>TBlobField</var> as a string value: getting or setting this value
will convert the BLOB data to a string, it will return the same value as the <link id="TField.AsString"/> property.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="TField.AsString"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Transliterate : Boolean -->
<element name="TBlobField.Transliterate">
<short>Should the contents of the field be transliterated</short>
<descr>
<var>Transliterate</var> indicates whether the contents of the field should be transliterated 
(i.e. changed from OEM to non OEM codepage and vice versa) when reading or writing the value. 
The actual transliteration must be done in the <link id="TDataset.Translate"/> method of the 
dataset to which the field belongs. By default this property is <var>False</var>, 
but it can be set to <var>True</var> for BLOB data which contains text in another codepage.
</descr>
<seealso>
<link id="TStringField.Transliterate"/>
<link id="TDataset.Translate"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: BlobType : TBlobType -->
<element name="TBlobField.BlobType">
<short>Type of blob</short>
<descr>
<var>BlobType</var> is an alias for <link id="TField.DataType"/>, but with a restricted set of values. 
Setting <var>BlobType</var> is equivalent to setting the <link id="TField.DataType"/> property.
</descr>
<seealso>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Size :  -->
<element name="TBlobField.Size">
<short>Size of the blob field</short>
<descr>
<var>Size</var> is the size of the blob in the internal memory buffer. It defaults to 0, as the BLOB data is not stored in the internal memory buffer.
To get the size of the data in the current record, use the <link id="TBlobField.BlobSize">BlobSize</link> property instead.
</descr>
<seealso>
<link id="TBlobField.BlobSize">BlobSize</link>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TMemoField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TMemoField">
<short>Base class for MEMO (text BLOB) field data</short>
<descr>
<p>
<var>TMemoField</var> is the class used when a dataset must manage memo (Text BLOB) data. (<link id="TField.DataType"/> equals <var>ftMemo</var>). 
It initializes some of the properties of the <link id="TField"/> class. All methods to be able to work with memo fields have been implemented in 
the <link id="TBlobField"/> parent class.
</p>
<p>
It should never be necessary to create an instance of <var>TMemoField</var> manually, a field
of this class will be instantiated automatically for each memo field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TBLOBField"/>
<link id="TWideMemoField"/>
<link id="TGraphicField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TMemoField.Create">
<short>Create a new instance of the <var>TMemoField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TMemoField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with memo values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TMemoField.Create.AOwner">
<short>Owner of the new field instance/</short>
</element>

<!-- property Visibility: published
     Declaration: Transliterate :  -->
<element name="TMemoField.Transliterate">
<short>Should the contents of the field be transliterated</short>
<descr>
<var>Transliterate</var> is redefined from <link id="TBlobField.Transliterate"/> with a default value of <var>true</var>.
</descr>
<seealso>
<link id="TBlobField.Transliterate"/>
<link id="TStringField.Transliterate"/>
<link id="TDataset.Translate"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TWideMemoField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TWideMemoField">
<short>Field class for wide MEMO (widestring text BLOB) field data</short>
<descr>
<p>
<var>TWideMemoField</var> is the class used when a dataset must manage memo (Text BLOB) data. (<link id="TField.DataType"/> equals <var>ftWideMemo</var>). 
It initializes some of the properties of the <link id="TField"/> class. All methods to be able to work with widestring memo fields have been implemented in 
the <link id="TBlobField"/> parent class.
</p>
<p>
It should never be necessary to create an instance of <var>TWideMemoField</var> manually, a field
of this class will be instantiated automatically for each widestring memo field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TBLOBField"/>
<link id="TMemoField"/>
<link id="TGraphicField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(aOwner: TComponent);  Override -->
<element name="TWideMemoField.Create">
<short>Create a new instance of the <var>TWideMemoField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TWideMemoField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with widestring memo values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: aOwner: TComponent -->
<element name="TWideMemoField.Create.aOwner">
<short>Owner for the new field instance</short>
</element>

<!-- property Visibility: public
     Declaration: Value : WideString -->
<element name="TWideMemoField.Value">
<short>Value of the field's contents as a widestring</short>
<descr>
<var>Value</var> is redefined by <var>TWideMemoField</var> as a WideString value. 
Reading and writing this property is equivalent to reading and writing the <link id="TField.AsWideString"/> property.
</descr>
<seealso>
<link id="TField.Value"/>
<link id="Tfield.AsWideString"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TGraphicField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TGraphicField">
<short>Field class for graphical BLOB field data</short>
<descr>
<p>
<var>TGraphicField</var> is the class used when a dataset must manage graphical BLOB data. (<link id="TField.DataType"/> equals <var>ftGraphic</var>). 
It initializes some of the properties of the <link id="TField"/> class. All methods to be able to work with graphical BLOB data have been implemented in 
the <link id="TBlobField"/> parent class.
</p>
<p>
It should never be necessary to create an instance of <var>TGraphicsField</var> manually, a field
of this class will be instantiated automatically for each graphical BLOB field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TBLOBField"/>
<link id="TMemoField"/>
<link id="TWideMemoField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TGraphicField.Create">
<short>Create a new instance of the <var>TGraphicField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TGraphicField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with graphical BLOB values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TGraphicField.Create.AOwner">
<short>Owner for the new <var>TGraphicField</var> instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TVariantField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TVariantField">
<short>Field class for native variant data</short>
<descr>
<p>
<var>TVariantField</var> is the class used when a dataset must manage native variant-typed data. (<link id="TField.DataType"/> equals <var>ftVariant</var>). 
It initializes some of the properties of the <link id="TField"/> class and overrides some of its methods to be able to work with variant data.
</p>
<p>
It should never be necessary to create an instance of <var>TVariantField</var> manually, a field
of this class will be instantiated automatically for each variant field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TVariantField.Create">
<short>Create a new instance of the <var>TVariantField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TVariantField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with variant values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TVariantField.Create.AOwner">
<short>Owner for the new <var>TVariantField</var> instance</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TGuidField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TGuidField">
<short>Field class for native variant data</short>
<descr>
<p>
<var>TGUIDField</var> is the class used when a dataset must manage native variant-typed data. (<link id="TField.DataType"/> equals <var>ftGUID</var>). 
It initializes some of the properties of the <link id="TField"/> class and overrides some of its methods to be able to work with variant data. 
It also adds a method to retrieve the field value as a native <var>TGUID</var> type.
</p>
<p>
It should never be necessary to create an instance of <var>TGUIDField</var> manually, a field
of this class will be instantiated automatically for each GUID field when a dataset is opened.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TGuidField.AsGuid"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TGuidField.Create">
<short>Create a new instance of the <var>TGUIDField</var> class</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TGUIDField</var> class.
It calls the inherited destructor, and then sets some <link id="TField"/> properties 
to configure the instance for working with GUID values.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TGuidField.Create.AOwner">
<short>Owner for the new <var>TGUIDField</var> instance</short>
</element>

<!-- property Visibility: public
     Declaration: AsGuid : TGUID -->
<element name="TGuidField.AsGuid">
<short>Field content as a GUID value</short>
<descr>
<var>AsGUID</var> can be used to get or set the field's content as a value of type <var>TGUID</var>.
</descr>
<seealso>
<link id="TField.AsString"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TIndexDefs
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TIndexDefs">
<short>A class to keep a list of index definitions</short>
<descr>
<var>TIndexDefs</var> is used to keep a collection of index (sort order) definitions. 
It can be used by classes that provide in-memory or on-disk indexes to provide a list 
of available indexes. 
</descr>
<seealso>
<link id="TIndexDef"/>
<link id="TIndexDefs.Items"/>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TIndexOption = (ixPrimary,ixUnique,ixDescending,ixCaseInsensitive,
                ixExpression,ixNonMaintained) -->
<element name="TIndexOption">
<short>Index description flags</short>
<descr>
<var>TIndexOption</var> describes the various properties that an index can have. 
It is used in the <link id="TIndexOptions"/> set type to describe all properties of an index definition as in <link id="TIndexDef"/>.
</descr>
<seealso>
<link id="TIndexOptions"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixPrimary -->
<element name="TIndexOption.ixPrimary">
<short>The index is the primary index for the data</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixUnique -->
<element name="TIndexOption.ixUnique">
<short>The index is a unique index, i.e. each index value can occur only once</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixDescending -->
<element name="TIndexOption.ixDescending">
<short>The values in the index are sorted descending.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixCaseInsensitive -->
<element name="TIndexOption.ixCaseInsensitive">
<short>The values in the index are sorted case-insensitively</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixExpression -->
<element name="TIndexOption.ixExpression">
<short>The values in the index are based on a calculated expression.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ixNonMaintained -->
<element name="TIndexOption.ixNonMaintained">
<short>The index is non-maintained, i.e. changing the data will not update the index.</short>
</element>

<!-- set type Visibility: default
     Declaration: TIndexOptions= Set of (ixPrimary,ixUnique,ixDescending,
                       ixCaseInsensitive,ixExpression,ixNonMaintained) -->
<element name="TIndexOptions">
<short>Set of <var>TIndexOption</var> values</short>
<descr>
<var>TIndexOptions</var> contains the set of properties that an index can have. 
It is used in the <link id="TIndexDef.Options"/> property to describe all properties of an index definition as in <link id="TIndexDef"/>.
</descr>
<seealso>
<link id="TIndexDef.Options"/>
<link id="TIndexDef"/>
<link id="TIndexOption"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TIndexDef
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TIndexDef">
<short>Index definition</short>
<descr>
<var>TIndexDef</var> describes one index in a set of indexes of a <link id="TDataset"/> instance. 
The collection of indexes is descibed by the <link id="TIndexDefs"/> class.
It just has the necessary properties to describe an index, but does not implement any 
functionality to maintain an index.
</descr>
<seealso>
<link id="TIndexDefs"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(Owner: TIndexDefs;const AName: String;
                  const TheFields: String;TheOptions: TIndexOptions)
                  ;  Overload -->
<element name="TIndexDef.Create">
<short>Create a new index definition</short>
<descr>
<var>Create</var> initializes a new <link id="TIndexDef"/> instance with the <var>AName</var> value as the index name, 
<var>AField</var> as the fields making up the index, and <var>TheOptions</var> as the options. <var>Owner</var> should 
be the <link id="TIndexDefs"/> instance to which the new <var>TIndexDef</var> can be added.
</descr>
<errors>
If an index with name <var>AName</var> already exists in the collection, an exception will be raised.
</errors>
<seealso>
<link id="TIndexDefs"/>
<link id="TIndexDef.Options"/>
<link id="TIndexDef.Fields"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Owner: TIndexDefs -->
<element name="TIndexDef.Create.Owner">
<short><var>TIndexDefs</var> Collection to which new instance must be added.</short>
</element>

<!-- argument Visibility: default
     Declaration: AName: String -->
<element name="TIndexDef.Create.AName">
<short>Name for the new index. Each name may appear only once in the collection.</short>
</element>

<!-- argument Visibility: default
     Declaration: TheFields: String -->
<element name="TIndexDef.Create.TheFields">
<short>Fields that make up the index</short>
</element>

<!-- argument Visibility: default
     Declaration: TheOptions: TIndexOptions -->
<element name="TIndexDef.Create.TheOptions">
<short>Options for the index</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TIndexDef.Destroy">
<short>Remove the index from memory</short>
<descr>
<var>Destroy</var> calls the inherited destructor, and removes the item from memory.
</descr>
<seealso>
<link id="TIndexDef.Create"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Expression : String -->
<element name="TIndexDef.Expression">
<short>Expression that makes up the index values</short>
<descr>
<var>Expression</var> is an SQL expression based on which the index values are computed.
It is only used when <var>ixExpression</var> is in <link id="TIndexDef.Options"/>
</descr>
<seealso>
<link id="TIndexDef.Options"/>
<link id="TindexDef.Fields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Fields : String -->
<element name="TIndexDef.Fields">
<short>Fields making up the index</short>
<descr>
<p>
<var>Fields</var> is a list of fieldnames, separated by semicolons: the fields that make up the index,
in case the index is not based on an expression. The list contains the names of all fields, regardless 
of whether the sort order for a particular field is ascending or descending. The fields should be in 
the right order, i.e. the first field is sorted on first, and so on.
</p>
<p>
The <link id="TIndexDef.DescFields"/> property can be used to determine the fields in the list that have 
a descending sort order. The <link id="TIndexDef.CaseInsFields"/> property determines which fields are 
sorted in a case-insensitive manner.
</p>
</descr>
<seealso>
<link id="TIndexDef.DescFields"/>
<link id="TIndexDef.CaseInsFields"/>
<link id="TIndexDef.Expression"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: CaseInsFields : String -->
<element name="TIndexDef.CaseInsFields">
<short>Fields in field list that are ordered case-insensitively</short>
<descr>
<var>CaseInsFields</var> is a list of fieldnames, separated by semicolons. It contains the names
of the fields in the <link id="TIndexDef.Fields">Fields</link> property which are ordered in a
case-insensitive manner. <var>CaseInsFields</var> may not contain fieldnames that do not appear in
<var>Fields</var>.
</descr>
<seealso>
<link id="TIndexDef.Fields"/>
<link id="TIndexDef.Expression"/>
<link id="TIndexDef.DescFields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DescFields : String -->
<element name="TIndexDef.DescFields">
<short>Fields in field list that are ordered descending</short>
<descr>
<var>DescFields</var> is a list of fieldnames, separated by semicolons. It contains the names
of the fields in the <link id="TIndexDef.Fields">Fields</link> property which are ordered in a
descending manner. <var>DescFields</var> may not contain fieldnames that do not appear in
<var>Fields</var>.
</descr>
<seealso>
<link id="TIndexDef.Fields"/>
<link id="TIndexDef.Expression"/>
<link id="TIndexDef.DescFields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Options : TIndexOptions -->
<element name="TIndexDef.Options">
<short>Index options</short>
<descr>
<p>
<var>Options</var> describes the various properties of the index. 
This is usually filled by the dataset that provides the index definitions. 
For datasets that provide In-memory indexes, this should be set prior to creating the index: it cannot be changed once the index is created.
</p>
<p>
See the description of <link id="TindexOption"/> for more information on the various available options.
</p>
</descr>
<seealso>
<link id="TIndexOptions"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Source : String -->
<element name="TIndexDef.Source">
<short>Source of the index</short>
<descr>
<var>Source</var> describes where the index comes from. This is a property for the convenience of the various datasets that provide indexes: 
they can use it to describe the source of the index.
</descr>
<seealso>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ADataSet: TDataSet);  Virtual;  Overload -->
<element name="TIndexDefs.Create">
<short>Create a new <var>TIndexDefs</var> instance</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TIndexDefs</var> class. It simply calls the inherited destructor with the appropriate item class, <link id="TIndexDef"/>.
</descr>
<seealso>
<link id="TIndexDef"/>
<link id="TIndexDefs.Destroy"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataSet: TDataSet -->
<element name="TIndexDefs.Create.ADataSet">
<short>Dataset for which the index definitions are stored</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TIndexDefs.Destroy">
<short>Remove the indexdefs from memory.</short>
<descr>
<var>Destroy</var> removes the indexdefs from memory. If the <var>TIndexDefs</var> instance is created by a <link id="TDataset"/> instance,
the dataset instance will also destroy it.
</descr>
<seealso>
<link id="TIndexDefs.Create"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Add(const Name: String;const Fields: String;
             Options: TIndexOptions) -->
<element name="TIndexDefs.Add">
<short>Add a new index definition with given name and options</short>
<descr>
<var>Add</var> adds a new <link id="TIndexDef"/> instance to the list of indexes. It initializes the index definition properties
<var>Name</var>, <var>Fields</var> and <var>Options</var> with the values given in the parameters with the same names.
</descr>
<errors>
If an index with the same <var>Name</var> already exists in the list of indexes, an exception will be raised.
</errors>
<seealso>
<link id="TIndexDef"/>
<link id="TNamedItem.Name"/>
<link id="TIndexDef.Fields"/>
<link id="TIndexDef.Options"/>
<link id="TIndexDefs.AddIndexDef"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Name: String -->
<element name="TIndexDefs.Add.Name">
<short>Name for the new index definition</short>
</element>

<!-- argument Visibility: default
     Declaration: Fields: String -->
<element name="TIndexDefs.Add.Fields">
<short>Value for the <var>Fields</var> property of the new index definition.</short>
</element>

<!-- argument Visibility: default
     Declaration: Options: TIndexOptions -->
<element name="TIndexDefs.Add.Options">
<short>Value for the <var>Options</var> property of the new index definition.</short>
</element>

<!-- function Visibility: public
     Declaration: function AddIndexDef : TIndexDef -->
<element name="TIndexDefs.AddIndexDef">
<short>Add a new, empty, index definition</short>
<descr>
<var>AddIndexDef</var> adds a new <link id="TIndexDef"/> instance to the list of indexes, and returns the newly created instance.
It does not initialize any of the properties of the new index definition. 
</descr>
<seealso>
<link id="TIndexDefs.Add"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TIndexDefs.AddIndexDef.Result">
<short>New <var>TIndexDef</var> instance.</short>
</element>

<!-- function Visibility: public
     Declaration: function Find(const IndexName: String) : TIndexDef -->
<element name="TIndexDefs.Find">
<short>Find an index by name</short>
<descr>
<var>Find</var> overloads the <link id="TDefCollection.Find"/> method to search and return a <link id="TIndexDef"/> instance based on the name.
The search is case-insensitive and raises an exception if no matching index definition was found. Note: <var>TIndexDefs.IndexOf</var> can be used instead if an exception is not desired.
</descr>
<errors>
</errors>
<seealso>
<link id="TIndexDef"/>
<link id="TDefCollection.Find"/>
<link id="TIndexDefs.FindIndexForFields"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TIndexDefs.Find.Result">
<short><var>TIndexDef</var> instance with name <var>IndexName</var> or <var>Nil</var></short>
</element>

<!-- argument Visibility: default
     Declaration: IndexName: String -->
<element name="TIndexDefs.Find.IndexName">
<short>Index name to search for.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindIndexForFields(const Fields: String) : TIndexDef -->
<element name="TIndexDefs.FindIndexForFields">
<short>Find index definition based on field names</short>
<descr>
<var>FindIndexForFields</var> searches in the list of indexes for an index whose <link id="TIndexDef.Fields"/> property matches
the list of fields in <var>Fields</var>. If it finds an index definition, then it returns the found instance.
</descr>
<errors>
If no matching definition is found, an exception is raised. 
This is different from other Find functionality, where Find usually returns Nil if nothing is found.
</errors>
<seealso>
<link id="TIndexDef"/>
<link id="TIndexDefs.Find"/>
<link id="TIndexDefs.GetindexForFields"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TIndexDefs.FindIndexForFields.Result">
<short><var>TIndexDef</var> instance with fieldlist matching <var>Fields</var></short>
</element>

<!-- argument Visibility: default
     Declaration: Fields: String -->
<element name="TIndexDefs.FindIndexForFields.Fields">
<short>Fieldlist to look for</short>
</element>

<!-- function Visibility: public
     Declaration: function GetIndexForFields(const Fields: String;
                          CaseInsensitive: Boolean) : TIndexDef -->
<element name="TIndexDefs.GetIndexForFields">
<short>Get index definition based on field names</short>
<descr>
<var>GetIndexForFields</var> searches in the list of indexes for an index whose <link id="TIndexDef.Fields"/> property matches
the list of fields in <var>Fields</var>. If <var>CaseInsenstitive</var> is <var>True</var> it only searches for case-sensitive
indexes. If it finds an index definition, then it returns the found instance.  If it does not find a matching definition, 
<var>Nil</var> is returned.
</descr>
<seealso>
<link id="TIndexDef"/>
<link id="TIndexDefs.Find"/>
<link id="TIndexDefs.FindIndexForFields"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TIndexDefs.GetIndexForFields.Result">
<short><var>TIndexDef</var> instance with fieldlist matching <var>Fields</var> or <var>Nil</var></short>
</element>

<!-- argument Visibility: default
     Declaration: Fields: String -->
<element name="TIndexDefs.GetIndexForFields.Fields">
<short>Fieldlist to look for</short>
</element>

<!-- argument Visibility: default
     Declaration: CaseInsensitive: Boolean -->
<element name="TIndexDefs.GetIndexForFields.CaseInsensitive">
<short>Look only for a case-insensitive index</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Update;  Virtual;  Overload -->
<element name="TIndexDefs.Update">
<short>Called whenever one of the items changes</short>
<descr>
<var>Update</var> can be called to have the dataset update its index definitions.
</descr>
</element>

<!-- property Visibility: public
     Declaration: Items[Index: Integer]: TIndexDef; default -->
<element name="TIndexDefs.Items">
<short>Indexed access to the index definitions</short>
<descr>
<var>Items</var> is redefined by <var>TIndexDefs</var> using <var>TIndexDef</var> as the type for the elements. It is the default property of the <var>TIndexDefs</var> class.
</descr>
<seealso>
<link id="TIndexDef"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: Integer -->
<element name="TIndexDefs.Items.Index">
<short>Numerical, zero-based index.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TCheckConstraint
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TCheckConstraint">
<short>Record-level constraint definition</short>
<descr>
<var>TCheckConstraint</var> can be used to store the definition of a record-level constraint.
It does not enforce the constraint, it only stores the constraint's definition. The constraint 
can come from several sources: an imported constraints from the database, usually stored in the
<link id="TCheckConstraint.ImportedConstraint"/> property , or a constraint 
enforced by the user on a particular dataset instance stored in <link id="TCheckConstraint.CustomConstraint"/>
</descr>
<errors>
</errors>
<seealso>
<link id="TCheckConstraints"/>
<link id="TCheckConstraint.ImportedConstraint"/>
<link id="TCheckConstraint.CustomConstraint"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Assign(Source: TPersistent);  Override -->
<element name="TCheckConstraint.Assign">
<short>Assign one constraint to another</short>
<descr>
<var>Assign</var> is overridden by  <var>TCheckConstraint</var> to copy all published 
properties if <var>Source</var> is also a <var>TCheckConstraint</var> instance.
</descr>
<errors>
If <var>Source</var> is not an instance of <var>TCheckConstraint</var>, an exception may be thrown.
</errors>
<seealso>
<link id="TCheckConstraint.ImportedConstraint"/>
<link id="TCheckConstraint.CustomConstraint"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Source: TPersistent -->
<element name="TCheckConstraint.Assign.Source">
<short>Instance to copy properties from.</short>
</element>

<!-- property Visibility: published
     Declaration: CustomConstraint : String -->
<element name="TCheckConstraint.CustomConstraint">
<short>User-defined constraint</short>
<descr>
<var>CustomConstraint</var> is an SQL expression with an additional user-defined constraint. 
The expression should be enforced by a <link id="TDataset"/> descendent when data is posted to
the dataset. If the constraint is violated, then the dataset should raise an exception, with 
message as specified in <link id="TCheckConstraint.ErrorMessage"/>
</descr>
<seealso>
<link id="TCheckConstraint.ErrorMessage"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ErrorMessage : String -->
<element name="TCheckConstraint.ErrorMessage">
<short>Message to display when the constraint is violated</short>
<descr>
<var>ErrorMessage</var> is used as the message when the dataset instance raises an exception if the constraint is violated.
</descr>
<seealso>
<link id="TCheckConstraint.CustomConstraint"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: FromDictionary : Boolean -->
<element name="TCheckConstraint.FromDictionary">
<short>True if the constraint is imported from a datadictionary</short>
<descr>
<var>FromDictionary</var> indicates whether a constraint is imported from a data dictionary. 
This can be set by <link id="TDataset"/> descendents to indicate the source of the constraint, 
but is otherwise ignored.
</descr>
<seealso>
<link id="TCheckConstraint.ImportedConstraint"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ImportedConstraint : String -->
<element name="TCheckConstraint.ImportedConstraint">
<short>Constraint imported from the database engine</short>
<descr>
<var>ImportedConstraint</var> is a constraint imported from the database engine: it will not be 
enforced locally by the <link id="TDataset"/> descendent.
</descr>
<seealso>
<link id="TCheckConstraint.CustomConstraint"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TCheckConstraints
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TCheckConstraints">
<short>Set of record-level constraints</short>
<descr>
<var>TCheckConstraints</var> is a <var>TCollection</var> descendent which keeps a collection of <link id="TCheckConstraint"/> items.
It overrides the <link id="TCheckConstraints.Add">Add</link> method to return a <var>TCheckConstraint</var> instance.
</descr>
<seealso>
<link id="TCheckConstraint"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TPersistent) -->
<element name="TCheckConstraints.Create">
<short>Create a new instance of the <var>TCheckConstraints</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TCheckConstraints</var> class.
The <var>AOwner</var> argument is usually the <link id="TDataset"/> instance for which the
data is managed. It is kept for future reference. After storing the owner, the inherited 
constructor is called with the <link id="TCheckConstraint"/> class pointer.
</descr>
<seealso>
<link id="TCheckConstraint"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TPersistent -->
<element name="TCheckConstraints.Create.AOwner">
<short>Owner for the collection</short>
</element>

<!-- function Visibility: public
     Declaration: function Add : TCheckConstraint -->
<element name="TCheckConstraints.Add">
<short>Add new <var>TCheckConstraint</var> item to the collection</short>
<descr>
<var>Add</var> is overridden by <var>TCheckConstraint</var> to add a new <link id="TCheckConstraint"/> instance to the collection. it returns the newly added instance.
</descr>
<seealso>
<link id="TCheckConstraint"/>
<link id="#rtl.classes.TCollection.Add"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TCheckConstraints.Add.Result">
<short>The newly added <var>TCheckConstraint</var> instance</short>
</element>

<!-- property Visibility: public
     Declaration: Items[Index: LongInt]: TCheckConstraint; default -->
<element name="TCheckConstraints.Items">
<short>Indexed access to the items in the collection</short>
<descr>
<var>Items</var> is overridden by <var>TCheckConstraints</var> to provide type-safe access to the items in the collection.
The <var>index</var> is zero-based, so it runs from 0 to <var>Count-1</var>.
</descr>
<seealso>
<link id="#rtl.classes.TCollection.Items"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: LongInt -->
<element name="TCheckConstraints.Items.Index">
<short>Zero-based index to the list of items</short>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ADataset: TDataSet) -->
<element name="Tfields.Create">
<short>Create a new instance of <var>TFields</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TFields</var>. 
It stores the <var>ADataset</var> parameter, so it can be retrieved at any time in the <link id="TFields.Dataset"/> property, 
and initializes an internal list object to store te list of fields.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TFields.Dataset"/>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataset: TDataSet -->
<element name="Tfields.Create.ADataset">
<short>Dataset for which fields must be managed.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="Tfields.Destroy">
<short>Free the <var>TFields</var> instance</short>
<descr>
<var>Destroy</var> frees the field instances that it manages on behalf of the <link id="TFields.Dataset">Dataset</link>.
After that it cleans up the internal structures and then calls the inherited destructor. 
</descr>
<seealso>
<link id="TDataset"/>
<link id="TField"/>
<link id="TFields.Clear"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Add(Field: TField) -->
<element name="Tfields.Add">
<short>Add a new field to the list</short>
<descr>
<var>Add</var> must be used to add a new <link id="TField"/> instance to the list of fields. 
After a <var>TField</var> instance is added to the list, the <var>TFields</var> instance will 
free the field instance if it is cleared.
</descr>
<seealso>
<link id="TField"/>
<link id="TFields.Clear"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="Tfields.Add.Field">
<short>TField instance to add to the list of fields.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CheckFieldName(const Value: String) -->
<element name="Tfields.CheckFieldName">
<short>Check field name for duplicate entries</short>
<descr>
<var>CheckFieldName</var> checks whether a field with name equal to <var>Value</var> (case insensitive) 
already appears in the list of fields (using <link id="TFields.Find"/>). 
If it does, then an <link id="EDatabaseError"/> exception is raised.
</descr>
<seealso>
<link id="TField.FieldName"/>
<link id="TFields.Find"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="Tfields.CheckFieldName.Value">
<short>Field name to check</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CheckFieldNames(const Value: String) -->
<element name="Tfields.CheckFieldNames">
<short>Check a list of field names for duplicate entries</short>
<descr>
<var>CheckFieldNames</var> splits <var>Value</var> in a list of fieldnames, using semicolon as a separator. 
For each of the fieldnames obtained in this way, it calls <link id="TFields.CheckFieldName">CheckFieldName</link>.
</descr>
<errors>
Spaces are not discarded, so leaving a space after of before a fieldname will not find the fieldname, and will
yield a false negative result.
</errors>
<seealso>
<link id="TField.FieldName"/>
<link id="TFields.CheckFieldName"/>
<link id="TFields.Find"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="Tfields.CheckFieldNames.Value">
<short>List of field names to check</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Clear -->
<element name="Tfields.Clear">
<short>Clear the list of fields</short>
<descr>
<var>Clear</var> removes all <link id="TField"/> var instances from the list. 
All field instances are freed after they have been removed from the list.
</descr>
<seealso>
<link id="TField"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function FindField(const Value: String) : TField -->
<element name="Tfields.FindField">
<short>Find a field based on its name</short>
<descr>
<var>FindField</var> searches the list of fields and returns the field instance whose 
<link id="TField.FieldName">FieldName</link> property matches <var>Value</var>. 
The search is performed case-insensitively.
If no field instance is found, then <var>Nil</var> is returned.
</descr>
<seealso>
<link id="TFields.FieldByName"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="Tfields.FindField.Result">
<short>Field instance with <var>FieldName</var> matching <var>Value</var></short>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="Tfields.FindField.Value">
<short>Fieldname to search for</short>
</element>

<!-- function Visibility: public
     Declaration: function FieldByName(const Value: String) : TField -->
<element name="Tfields.FieldByName">
<short>Find a field based on its name</short>
<descr>
<var>Fieldbyname</var> searches the list of fields and returns the field instance whose 
<link id="TField.FieldName">FieldName</link> property matches <var>Value</var>. 
The search is performed case-insensitively.
</descr>
<errors>
If no field instance is found, then an exception is raised. If this behaviour is undesired, use
<link id="TField.FindField"/>, where <var>Nil</var> is returned if no match is found.
</errors>
<seealso>
<link id="TFields.FindField"/>
<link id="TFields.FieldName"/>
<link id="Tfields.FieldByNumber"/>
<link id="TFields.IndexOf"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="Tfields.FieldByName.Result">
<short>Field instance with <var>FieldName</var> matching <var>Value</var></short>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="Tfields.FieldByName.Value">
<short>Fieldname to search for</short>
</element>

<!-- function Visibility: public
     Declaration: function FieldByNumber(FieldNo: Integer) : TField -->
<element name="Tfields.FieldByNumber">
<short>Search field based on its fieldnumber</short>
<descr>
<var>FieldByNumber</var> searches for the field whose <link id="TField.FieldNo"/> property matches the <var>FieldNo</var> parameter.
If no such field is found, <var>Nil</var> is returned.
</descr>
<seealso>
<link id="TFields.FieldByName"/>
<link id="TFields.FindField"/>
<link id="TFields.IndexOf"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="Tfields.FieldByNumber.Result">
<short>Field instance with matching <var>FieldNo</var> property.</short>
</element>

<!-- argument Visibility: default
     Declaration: FieldNo: Integer -->
<element name="Tfields.FieldByNumber.FieldNo">
<short>Field number to search for</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetFieldNames(Values: TStrings) -->
<element name="Tfields.GetFieldNames">
<short>Get the list of fieldnames</short>
<descr>
<var>GetFieldNames</var> fills <var>Values</var> with the fieldnames of all the fields in the list, 
each item in the list contains 1 fieldname. The list is cleared prior to filling it.
</descr>
<seealso>
<link id="TField.FieldName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Values: TStrings -->
<element name="Tfields.GetFieldNames.Values">
<short>List to store fieldnames in</short>
</element>

<!-- function Visibility: public
     Declaration: function IndexOf(Field: TField) : LongInt -->
<element name="Tfields.IndexOf">
<short>Return the index of a field instance</short>
<descr>
<var>IndexOf</var> scans the list of fields and retuns the index of the field instance in the list (it compares actual field instances, not field names). 
If the field does not appear in the list, -1 is returned.
</descr>
<seealso>
<link id="TFields.FieldByName"/>
<link id="TFields.FieldByNumber"/>
<link id="TFields.FindField"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="Tfields.IndexOf.Result">
<short>Index of <var>Field</var> in the list</short>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="Tfields.IndexOf.Field">
<short>Field instance to search for.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Remove(Value: TField) -->
<element name="Tfields.Remove">
<short>Remove an instance from the list</short>
<descr>
<var>Remove</var> removes the field <var>Value</var> from the list. It does not free the field after it was removed.
If the field is not in the list, then nothing happens.
</descr>
<seealso>
<link id="TFields.Clear"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: TField -->
<element name="Tfields.Remove.Value">
<short>Field to remove from the list.</short>
</element>

<!-- property Visibility: public
     Declaration: Count : Integer -->
<element name="Tfields.Count">
<short>Number of fields in the list</short>
<descr>
<var>Count</var> is the number of fields in the fieldlist. The items in the <link id="TFields.Fields">Fields</link> property are numbered from 0 to <var>Count-1</var>.
</descr>
<seealso>
<link id="TFields.fields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Dataset : TDataSet -->
<element name="Tfields.Dataset">
<short>Dataset the fields belong to</short>
<descr>
<var>Dataset</var> is the dataset instance that owns the fieldlist. It is set when the <link id="TFields"/> instance is created.
This property is purely for informational purposes. When adding fields to the list, no check is performed whether the field's 
<var>Dataset</var> property matches this dataset.
</descr>
<seealso>
<link id="TFields.Create"/>
<link id="TField.Dataset"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Fields[Index: Integer]: TField; default -->
<element name="Tfields.Fields">
<short>Indexed access to the fields in the list</short>
<descr>
<var>Fields</var> is the default property of the <var>TFields</var> class. 
It provides indexed access to the fields in the list: the index runs from 0 to <var>Count-1</var>.
</descr>
<errors>
Providing an index outside the allowed range will result in an <var>EListError</var> exception.
</errors>
<seealso>
<link id="TFields.FieldByName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: Integer -->
<element name="Tfields.Fields.Index">
<short>Zero based index in the list.</short>
</element>

<!-- alias type Visibility: default
     Declaration: TBookmark = Pointer -->
<element name="TBookmark">
<short>Bookmark type (deprecated)</short>
<descr>
<var>TBookMark</var> is the type used by the <link id="TDataset.SetBookMark"/> method. 
It is an opaque type, and should not be used any more, it is superseded by the <link id="TBookmarkStr"/> type.
</descr>
<seealso>
<link id="TBookmarkStr"/>
</seealso>
</element>

<!-- alias type Visibility: default
     Declaration: TBookmarkStr = String -->
<element name="TBookmarkStr">
<short>Bookmark type</short>
<descr>
<var>TBookmarkStr</var> is the type used by the <link id="TDataset.Bookmark"/> property. 
It can be used as a string, but should in fact be considered an opaque type.
</descr>
<seealso>
<link id="TDataset.Bookmark"/>
</seealso>
</element>

<!-- pointer type Visibility: default
     Declaration: PBookmarkFlag = ^TBookmarkFlag -->
<element name="PBookmarkFlag">
<short>Pointer to <var>TBookmarkflag</var> type</short>
<descr>
<var>PBookmarkFlag</var> is a convenience type, defined for internal use in <link id="TDataset"/> or one of it's descendents.
</descr>
<seealso>
<link id="TBookmarkFlag"/>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TBookmarkFlag = (bfCurrent,bfBOF,bfEOF,bfInserted) -->
<element name="TBookmarkFlag">
<short>Bookmark flags</short>
<descr>
<var>TBookmarkFlag</var> is used internally by <link id="TDataset"/> and it's descendent types to mark the internal 
memory buffers. It should not be used in end-user applications.
</descr>
<seealso>
<link id="PBookmarkFlag"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: bfCurrent -->
<element name="TBookmarkFlag.bfCurrent">
<short>Buffer used for the current record</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: bfBOF -->
<element name="TBookmarkFlag.bfBOF">
<short>First record in the dataset.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: bfEOF -->
<element name="TBookmarkFlag.bfEOF">
<short>Last record in the dataset</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: bfInserted -->
<element name="TBookmarkFlag.bfInserted">
<short>Buffer used for insert</short>
</element>

<!-- pointer type Visibility: default
     Declaration: PBufferList = ^TBufferList -->
<element name="PBufferList">
<short>Pointer to <var>TBufferlist</var> type</short>
<descr>
<var>PBufferList</var> is a pointer to a structure of type <link id="TBufferList"/>. 
It is an internal type, and should not be used in end-user code.
</descr>
<seealso>
<link id="TBufferList"/>
</seealso>
</element>

<!-- array type Visibility: default
     Declaration: TBufferList = Array[0..dsMaxBufferCount-1] of PChar -->
<element name="TBufferList">
<short>Array of PChar records</short>
<descr>
<var>TBufferList</var> is used intenally by the <link id="TDataset"/> class to manage the memory buffers for the data.
It should not be necessary to use this type in end-user applications.
</descr>
</element>

<!-- enumeration type Visibility: default
     Declaration: TGetMode = (gmCurrent,gmNext,gmPrior) -->
<element name="TGetMode">
<short>Get new buffer mode</short>
<descr>
<var>TGetMode</var> is used internally by <link id="TDataset"/> when it needs to fetch more data for its buffers (using <var>GetRecord</var>). 
It tells the descendent dataset what operation must be performed.
</descr>
<seealso>
<link id="TDataset.Next"/>
<link id="TDataset.Prior"/>
<link id="TGetResult"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: gmCurrent -->
<element name="TGetMode.gmCurrent">
<short>Retrieve the current record</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: gmNext -->
<element name="TGetMode.gmNext">
<short>Retrieve the next record.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: gmPrior -->
<element name="TGetMode.gmPrior">
<short>Retrieve the previous record.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TGetResult = (grOK,grBOF,grEOF,grError) -->
<element name="TGetResult">
<short>result of the <var>GetRecord</var> operation.</short>
<descr>
<var>TGetResult</var> is used by descendents of <link id="TDataset"/> when they have to 
communicate the result of the <var>GetRecord</var> operation back to the <var>TDataset</var> record.
</descr>
<seealso>
<link id="TGetMode"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: grOK -->
<element name="TGetResult.grOK">
<short>The operation was completed succesfully</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: grBOF -->
<element name="TGetResult.grBOF">
<short>The beginning of the recordset is reached</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: grEOF -->
<element name="TGetResult.grEOF">
<short>The end of the recordset is reached.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: grError -->
<element name="TGetResult.grError">
<short>An error occurred</short>
</element>

<!-- set type Visibility: default
     Declaration: TResyncMode= Set of (rmExact,rmCenter) -->
<element name="TResyncMode">
<short>Internal flag for resynchronisiation</short>
<descr>
<var>TResyncMode</var> is used internally by various <link id="TDataset"/> navigation and data manipulation 
methods such as the <link id="TDataset.Refresh"/> method when they need to reset the cursor position in the dataset's buffer.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: rmExact -->
<element name="TResyncMode.rmExact">
<short>Reposition at exact the same location in the buffer</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: rmCenter -->
<element name="TResyncMode.rmCenter">
<short>Try to position the cursor in the middle of the buffer</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TDataAction = (daFail,daAbort,daRetry) -->
<element name="TDataAction">
<short>Action to take when a data manipulation operation has failed.</short>
<descr>
<var>TDataAction</var> is used by the <link id="TDataSetErrorEvent"/> event handler prototype. 
The parameter <var>Action</var> of this event handler is of <var>TDataAction</var> type, and should
indicate what action must be taken by the dataset.
</descr>
<seealso>
<link id="TDataSetErrorEvent"/>
<link id="TDataset.OnEditError"/>
<link id="TDataset.OnPosterror"/>
<link id="TDataset.OnDeleteError"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: daFail -->
<element name="TDataAction.daFail">
<short>The operation should fail (an exception will be raised)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: daAbort -->
<element name="TDataAction.daAbort">
<short>The operation should be aborted (edits are undone, and an EAbort exception is raised)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: daRetry -->
<element name="TDataAction.daRetry">
<short>Retry the operation.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TUpdateAction = (uaFail,uaAbort,uaSkip,uaRetry,uaApplied) -->
<element name="TUpdateAction">
<short>Action to perform when an update operation fails</short>
<descr>
<var>TUpdateAction</var> indicates what action must be taken in case the applying of updates on the underlying database fails.
This type is not used in the <link id="TDataset"/> class, but is defined on behalf of <var>TDataset</var> descendents that 
implement caching of updates: It indicates what should be done when the (delayed) applying of the updates fails. 
This event occurs long after the actual post or delete operation.
</descr>
<seealso>
<link id="TDataAction"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: uaFail -->
<element name="TUpdateAction.uaFail">
<short>Update operation should fail</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: uaAbort -->
<element name="TUpdateAction.uaAbort">
<short>The whole update operation should abort</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: uaSkip -->
<element name="TUpdateAction.uaSkip">
<short>The update of the current record should be skipped. (but not discarded)</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: uaRetry -->
<element name="TUpdateAction.uaRetry">
<short>Retry the update operation</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: uaApplied -->
<element name="TUpdateAction.uaApplied">
<short>Consider the update as applied</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TUpdateKind = (ukModify,ukInsert,ukDelete) -->
<element name="TUpdateKind">
<short>Kind of update operation</short>
<descr>
<var>TUpdateKind</var> indicates what kind of update operation is in progress when applying updates.
</descr>
<seealso>
<link id="TUpdateAction"/>
<link id="TDataAction"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: ukModify -->
<element name="TUpdateKind.ukModify">
<short>Modify an existing record in the database.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ukInsert -->
<element name="TUpdateKind.ukInsert">
<short>insert a new record in the database.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ukDelete -->
<element name="TUpdateKind.ukDelete">
<short>Delete a record in the database.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TLocateOption = (loCaseInsensitive,loPartialKey) -->
<element name="TLocateOption">
<short>Available options when locating a record in a dataset</short>
<descr>
<p>
<var>TLocateOption</var> is used in the <link id="TDataset.Locate"/> call to enumerate the possible 
options available when locating a record in the dataset.
</p>
<p>
For string-type fields, this option indicates that fields starting with the search value are considered a match.
For other fields (e.g. integer, date/time), this option is ignored and only equal field values are considered a match.
</p>
</descr>
<seealso>
<link id="TDataset.Locate"/>
<link id="TLocateOptions"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: loCaseInsensitive -->
<element name="TLocateOption.loCaseInsensitive">
<short>Perform a case-insensitive search</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: loPartialKey -->
<element name="TLocateOption.loPartialKey">
<short>Accept partial key matches for string fields</short>
</element>

<!-- set type Visibility: default
     Declaration: TLocateOptions= Set of (loCaseInsensitive,loPartialKey) -->
<element name="TLocateOptions">
<short>Options to use when locating a record in a dataset</short>
<descr>
<var>TLocateOptions</var> is used in the <link id="TDataset.Locate"/> call: It should contain the actual
options to use when locating a record in the dataset.
</descr>
<seealso>
<link id="TDataset.Locate"/>
<link id="TLocateOption"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TDataOperation = procedure of object -->
<element name="TDataOperation">
<short>Internal callback type</short>
<descr>
<var>TDataOperation</var> is a prototype handler used internally in <var>TDataset</var>. It can be changed
at any time, so it should not be used in end-user code.
</descr>
<seealso>
<link id="TDatasetNotifyEvent"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TDataSetNotifyEvent = procedure(DataSet: TDataSet) of object -->
<element name="TDataSetNotifyEvent">
<short>Event handler prototype for dataset events</short>
<descr>
<var>TDatasetNotifyEVent</var> is used in most of the <link id="TDataset"/> event handlers. It differs from the more general
<var>TNotifyEvent</var> (defined in the <file>Classes</file> unit) in that the <var>Sender</var> parameter of the latter is 
replaced with the <var>Dataset</var> parameter. This avoids typecasts, the available TDataset methods can be used directly.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: DataSet: TDataSet -->
<element name="TDataSetNotifyEvent.DataSet">
<short>Dataset which triggered the event</short>
</element>

<!-- procedure type Visibility: default
     Declaration: TDataSetErrorEvent = procedure(DataSet: TDataSet;E: EDatabaseError;
                               var DataAction: TDataAction) of object -->
<element name="TDataSetErrorEvent">
<short>Error handling callback</short>
<descr>
<var>TDatasetErrorEvent</var> is used by the <link id="TDataset.OnEditError"/>, <link id="TDataset.OnPostError"/> 
and <link id="TDataset.OnDeleteError"/> event handlers to allow the programmer to specfy what should be done if
an update operation fails with an exception: The <var>Dataset</var> parameter indicates what dataset triggered 
the event, the <var>E</var> parameter contains the exception object. The <var>DataAction</var> must be set by the 
event handler, and based on it's return value, the dataset instance will take appropriate action. The default 
value is <var>daFail</var>, i.e. the exception will be raised again. For a list of available return values, 
see <link id="TDataAction"/>.
</descr>
<seealso>
<link id="TDataAction"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: DataSet: TDataSet -->
<element name="TDataSetErrorEvent.DataSet">
<short>Dataset that triggered the event</short>
</element>

<!-- argument Visibility: default
     Declaration: E: EDatabaseError -->
<element name="TDataSetErrorEvent.E">
<short>Exception object that caused the operation to fail.</short>
</element>

<!-- argument Visibility: default
     Declaration: DataAction: TDataAction -->
<element name="TDataSetErrorEvent.DataAction">
<short>Action to take upon return of the event handler.</short>
</element>

<!-- enumeration type Visibility: default
     Declaration: TFilterOption = (foCaseInsensitive,foNoPartialCompare) -->
<element name="TFilterOption">
<short>Available filter options.</short>
<descr>
<var>TFilterOption</var> enumerates the various options available when filtering a dataset.
The <link id="TFilterOptions"/> set is used in the <link id="TDataset.FilterOptions"/> property 
to indicate which of the options should be used when filtering the data.
</descr>
<seealso>
<link id="TFilterOptions"/>
<link id="TDataset.FilterOptions"/>
<link id="TDataset.Filter"/>
<link id="TDataset.Filtered"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: foCaseInsensitive -->
<element name="TFilterOption.foCaseInsensitive">
<short>Filter case insensitively.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: foNoPartialCompare -->
<element name="TFilterOption.foNoPartialCompare">
<short>Do not compare values partially, always compare completely.</short>
</element>

<!-- set type Visibility: default
     Declaration: TFilterOptions= Set of (foCaseInsensitive,foNoPartialCompare) -->
<element name="TFilterOptions">
<short>Set of filter options to use.</short>
<descr>
<var>TFilterOption</var> is the set of filter options to use when filtering a dataset. 
This set type is used in the <link id="TDataset.FilterOptions"/> property. The available 
values are described in the <link id="TFilterOption"/> type.
</descr>
<seealso>
<link id="TDataset.FilterOptions"/>
<link id="TFilterOption"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TFilterRecordEvent = procedure(DataSet: TDataSet;var Accept: Boolean)
                                of object -->
<element name="TFilterRecordEvent">
<short>Record filtering event handler prototype</short>
<descr>
<var>TFilterRecordEvent</var> is the prototype for the <link id="TDataset.OnFilterRecord"/> event handler.
The <var>Dataset</var> parameter indicates which dataset triggered the event, and the <var>Accept</var> 
parameter must be set to <var>true</var> if the current record should be shown, <var>False</var> should 
be used when the record should be hidden.
</descr>
<seealso>
<link id="TDataset.OnFilterRecord"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: DataSet: TDataSet -->
<element name="TFilterRecordEvent.DataSet">
<short>Dataset that triggered the event</short>
</element>

<!-- argument Visibility: default
     Declaration: Accept: Boolean -->
<element name="TFilterRecordEvent.Accept">
<short>Set to indicate whether the current record should be shown or not.</short>
</element>

<!-- "class of" type Visibility: default
     Declaration: TDatasetClass = Class of TDataSet -->
<element name="TDatasetClass">
<short>Class type for the <var>TDataset</var> class</short>
<descr>
<var>TDatasetClass</var> is the class type for the <link id="TDataset"/> class. 
It is currently unused in the <file>DB</file> unit and is defined for the benefit of other units.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- pointer type Visibility: default
     Declaration: TBufferArray = ^pchar -->
<element name="TBufferArray">
<short>Pointer to an array of buffers</short>
<descr>
<var>TBufferArray</var> is an internally used type. It can change in future implementations, 
and should not be used in application code.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: LongInt -->
<element name="TDataSet.Buffers.Index">
<short>Index in the buffers property</short>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDataSet.Create">
<short>Create a new <var>TDataset</var> instance</short>
<descr>
<var>Create</var> initializes a new <link id="TDataset"/> instance. It calls the inherited constructor, and then
initializes the internal structures needed to manage the dataset (fielddefs, fieldlist, constraints etc.).
</descr>
<seealso>
<link id="TDataset.Destroy"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDataSet.Create.AOwner">
<short>Owner of the new dataset instance.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TDataSet.Destroy">
<short>Free a <var>TDataset</var> instance</short>
<descr>
<var>Destroy</var> removes a <var>TDataset</var> instance from memory. It closes the dataset if it was open, 
clears all internal sructures and then calls he inherited destructor.
</descr>
<errors>
An exception may occur during the close operation, in that case, the dataset will not be removed from memory.
</errors>
<seealso>
<link id="TDataset.Close"/>
<link id="TDataset.Create"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function ActiveBuffer : PChar -->
<element name="TDataSet.ActiveBuffer">
<short>Currently active memory buffer</short>
<descr>
<var>ActiveBuffer</var> points to the currently active memory buffer. It should not be used in application code.
</descr>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.ActiveBuffer.Result">
<short>Pointer to buffer used to display current contents</short>
</element>

<!-- function Visibility: public
     Declaration: function GetFieldData(Field: TField;Buffer: Pointer) : Boolean;  Virtual
                     ;  Overload -->
<element name="TDataSet.GetFieldData">
<short>Get the data for a field</short>
<descr>
<var>GetFieldData</var> should copy the data for field <var>Field</var> from the internal dataset memory buffer 
into the memory pointed to by <var>Buffer</var>.
This function is not intended for use by end-user applications, and should be used only in descendent classes, where it
can be overridden. The function should return <var>True</var> if data was available and has been copied, or <var>False</var>
if no data was available (in which case the field has value <var>Null</var>). The <var>NativeFormat</var> determines whether
the data should be in native format (e.g. whether the date/time values should be in <var>TDateTime</var> format).
</descr>
<errors>
No checks are performed on the validity of the memory buffer
</errors>
<seealso>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.GetFieldData.Result">
<short>True if data was available, false if no data was available.</short>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TDataSet.GetFieldData.Field">
<short>Field for which the data should be fetched</short>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TDataSet.GetFieldData.Buffer">
<short>Buffer in which the data should be copied</short>
</element>

<!-- argument Visibility: default
     Declaration: NativeFormat: Boolean -->
<element name="TDataSet.GetFieldData.NativeFormat">
<short>Should the data be in native format</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetFieldData(Field: TField;Buffer: Pointer);  Virtual
                      ;  Overload -->
<element name="TDataSet.SetFieldData">
<short>Store the data for a field</short>
<descr>
<var>SetFieldData</var> should copy the data from field <var>Field</var>, stored in the memory pointed to by <var>Buffer</var>
to the dataset memory buffer for the current record.
This function is not intended for use by end-user applications, and should be used only in descendent classes, where it
can be overridden. The <var>NativeFormat</var> determines whether the data is in native format (e.g. whether the date/time 
values are in <var>TDateTime</var> format).
</descr>
<seealso>
<link id="TField.DisplayText"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TDataSet.SetFieldData.Field">
<short>Field to copy data for</short>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TDataSet.SetFieldData.Buffer">
<short></short>
</element>

<!-- argument Visibility: default
     Declaration: NativeFormat: Boolean -->
<element name="TDataSet.SetFieldData.NativeFormat">
<short>Is the data in native format</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Append -->
<element name="TDataSet.Append">
<short>Append a new record to the data</short>
<descr>
<var>Append</var> appends a new record at the end of the dataset. It is functionally equal to the <link id="TDataset.Insert"/> call,
but the cursor is positioned at the end of the dataset prior to performing the insert operation. The same events occur as when the 
<var>Insert</var> call is made.
</descr>
<seealso>
<link id="TDataset.Insert"/>
<link id="TDataset.Edit"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AppendRecord(const Values: Array of const) -->
<element name="TDataSet.AppendRecord">
<short>Append a new record to the dataset and fill with data</short>
<descr>
<var>AppendRecord</var> first calls <var>Append</var> to add a new record to the dataset. It then copies the values in <var>Values</var> 
to the various fields (using <link id="TDataset.SetFields"/>) and attempts to post the record using <link id="TDataset.Post"/>. 
If all went well, the result is that the values in <var>Values</var> have been added as a new record to the dataset.
</descr>
<errors>
Various errors may occur (not supplying a value for all required fields, invalid values) and may cause an exception. 
This may leave the dataset in editing mode.
</errors>
<seealso>
<link id="TDataset.Append"/>
<link id="TDataset.SetFields"/>
<link id="TDataset.Post"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Values: Array of const -->
<element name="TDataSet.AppendRecord.Values">
<short>Values for all fields, in correct order</short>
</element>

<!-- function Visibility: public
     Declaration: function BookmarkValid(ABookmark: TBookmark) : Boolean;  Virtual -->
<element name="TDataSet.BookmarkValid">
<short>Test whether <var>ABookMark</var> is a valid bookmark.</short>
<descr>
<var>BookmarkValid</var> returns <var>True</var> if <var>ABookMark</var> is a valid bookmark for the dataset. 
Various operations can render a bookmark invalid: changing the sort order, closing and re-opening the dataset.
<var>BookmarkValid</var> always returns <var>False</var> in <var>TDataset</var>. 
Descendent classes must override this method to do an actual test.
</descr>
<errors>
If the bookmark is a completely arbitrary pointer, an exception may be raised.
</errors>
<seealso>
<link id="TDataset.GetBookmark"/>
<link id="TDataset.SetBookmark"/>
<link id="TDataset.FreeBookmark"/>
<link id="TDataset.BookmarkAvailable"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.BookmarkValid.Result">
<short><var>True</var> if <var>ABookmark</var> is a valid bookmark.</short>
</element>

<!-- argument Visibility: default
     Declaration: ABookmark: TBookmark -->
<element name="TDataSet.BookmarkValid.ABookmark">
<short>Bookmark pointer to test</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Cancel;  Virtual -->
<element name="TDataSet.Cancel">
<short>Cancel the current editing operation</short>
<descr>
<p>
<var>Cancel</var> cancels the current editing operation and sets the dataset again in browse mode.
This operation triggers the <link id="TDataset.BeforeCancel"/> and <link id="TDataset.AfterCancel"/> events.
If the dataset wa sin insert mode, then the <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> 
events are triggered after and respectively before the <var>BeforeCancel</var> and <var>AfterCancel</var> events.
</p>
<p>
If the dataset was not in one of the editing modes when <var>Cancel</var> is called, 
then nothing will happen.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="TDataset.State"/>
<link id="TDataset.Append"/>
<link id="TDataset.Insert"/>
<link id="TDataset.Edit"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CheckBrowseMode -->
<element name="TDataSet.CheckBrowseMode">
<short>Check whether the dataset is in browse mode.</short>
<descr>
<var>CheckBrowseMode</var> will force the dataset to browse mode (<var>State=dsBrowse</var>)
if it is active. If it is not active, an <link id="EDatabaseError"/> exception is raised.
If it is active, but in an edit state, then <link
id="TDataset.UpdateRecord"/> is called, and if the <link
id="TDataset.Modified"/> property is true, a <link id="TDataset.Post"/> is
performed, else <link id="TDataset.Cancel"/> is called.
</descr>
<seealso>
<link id="TDataset.State"/>
<link id="TDataset.Post"/>
<link id="TDataset.Cancel"/>
<link id="TDataset.UpdateRecord"/>
<link id="TDataset.Modified"/> 
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure ClearFields -->
<element name="TDataSet.ClearFields">
<short>Clear the values of all fields</short>
<descr>
<var>ClearFields</var> clears the values of all fields. 
</descr>
<errors>
If the dataset is not in editing mode (<var>State in dsEditmodes</var>), then an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDataset.State"/>
<link id="TField.Clear"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Close -->
<element name="TDataSet.Close">
<short>Close the dataset</short>
<descr>
<var>Close</var> closes the dataset if it is open (<var>Active=True</var>). This action triggers the <link id="TDataset.BeforeClose"/>
and <link id="TDataset.AfterClose"/> events. If the dataset is not active, nothing happens.
</descr>
<errors>
If an exception occurs during the closing of the dataset, the <var>AfterClose</var> event will not be triggered.
</errors>
<seealso>
<link id="TDataset.Active"/>
<link id="TDataset.Open"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function ControlsDisabled : Boolean -->
<element name="TDataSet.ControlsDisabled">
<short>Check whether the controls are disabled</short>
<descr>
<var>ControlsDisabled</var> returns <var>True</var> if the controls are disabled, i.e. no events are propagated to the controls connected to this dataset.
The <link id="TDataset.DisableControls"/> call can be used to disable sending of data events to the controls. 
The sending can be re-enabled with <link id="TDataset.EnableControls"/>. 
This mechanism has a counting mechanism: in order to enable sending of events to the controls, <var>EnableControls</var> must be called as much as <var>DisableControls</var> was called.
The <var>ControlsDisabled</var> function will return true as long as the internal counter is not zero.
</descr>
<seealso>
<link id="TDataset.DisableControls"/>
<link id="TDataset.EnableControls"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.ControlsDisabled.Result">
<short><var>True</var> if no events are sent to the controls</short>
</element>

<!-- function Visibility: public
     Declaration: function CompareBookmarks(Bookmark1: TBookmark;Bookmark2: TBookmark)
                          : LongInt;  Virtual -->
<element name="TDataSet.CompareBookmarks">
<short>Compare two bookmarks</short>
<descr>
<var>CompareBookmarks</var> can be used to compare the relative positions of 2 bookmarks. It returns a negative value if <var>Bookmark1</var>
 is located before <var>Bookmark2</var>, zero if they refer to the same record, and a positive value if the second bookmark appears before the first bookmark.
This function mustbe overridden by descendent classes of TDataset. The implementation in TDataset always returns zero.
 </descr>
<errors>
No checks are performed on the validity of the bookmarks.
</errors>
<seealso>
<link id="TDataset.BookmarkValid"/>
<link id="TDataset.GetBookmark"/>
<link id="TDataset.SetBookmark"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.CompareBookmarks.Result">
<short>result of the compare operation</short>
</element>

<!-- argument Visibility: default
     Declaration: Bookmark1: TBookmark -->
<element name="TDataSet.CompareBookmarks.Bookmark1">
<short>First bookmark</short>
</element>

<!-- argument Visibility: default
     Declaration: Bookmark2: TBookmark -->
<element name="TDataSet.CompareBookmarks.Bookmark2">
<short>Second bookmark.</short>
</element>

<!-- function Visibility: public
     Declaration: function CreateBlobStream(Field: TField;Mode: TBlobStreamMode) : TStream
                         ;  Virtual -->
<element name="TDataSet.CreateBlobStream">
<short>Create blob stream</short>
<descr>
<var>CreateBlobStream</var> is not intended for use by applictaion programmers. 
It creates a stream object which can be used to read or write data from a blob field.
Instead, application programmers should use the <link id="TBlobField.LoadFromStream"/> and
<link id="TBlobField.SaveToStream"/> methods when reading and writing data from/to BLOB fields.
Which operation must be performed on the stream is indicated in the <var>Mode</var> parameter, 
and the <var>Field</var> parameter contains the field whose data should be read. 
The caller is responsible for freeing the stream created by this function.
</descr>
<seealso>
<link id="TBlobField.LoadFromStream"/>
<link id="TBlobField.SaveToStream"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.CreateBlobStream.Result">
<short>Stream with (for) blob data</short>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TDataSet.CreateBlobStream.Field">
<short>BLOB Field for which data should be fetched/written</short>
</element>

<!-- argument Visibility: default
     Declaration: Mode: TBlobStreamMode -->
<element name="TDataSet.CreateBlobStream.Mode">
<short>Mode: read or write</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CursorPosChanged -->
<element name="TDataSet.CursorPosChanged">
<short>Indicate a change in cursor position</short>
<descr>
<var>CursorPosChanged</var> is not intended for internal use only, and serves to indicate that the current cursor position has changed.
(it clears the internal cursor position).
</descr>
</element>

<!-- procedure Visibility: public
     Declaration: procedure DataConvert(aField: TField;aSource: Pointer;aDest: Pointer;
                     aToNative: Boolean);  Virtual -->
<element name="TDataSet.DataConvert">
<short>Convert data from/to native format</short>
<descr>
<p>
<var>DataConvert</var> converts the data from field <var>AField</var> in buffer <var>ASource</var> to native format and puts the result in <var>ADest</var>. 
If the <var>aToNative</var> parameter equals <var>False</var>, then the data is converted from native format to non-native format.
Currently, only date/time/datetime and BCD fields are converted from/to native data. 
This means the routine handles conversion between <var>TDateTime</var> (the native format) and <var>TDateTimeRec</var>, and between TBCD and currency (the native format)
for BCD fields.
</p>
<p>
<var>DataConvert</var> is used internally by <var>TDataset</var> and descendent classes. There should be no need to use this routine in application code.
</p>
</descr>
<errors>
No checking on the validity of the buffer pointers is performed. If an invalid pointer is passed, an exception may be raised.
</errors>
<seealso>
<link id="TDataset.GetFieldData"/>
<link id="TDataset.SetFieldData"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: aField: TField -->
<element name="TDataSet.DataConvert.aField">
<short>Field for which data should be converted.</short>
</element>

<!-- argument Visibility: default
     Declaration: aSource: Pointer -->
<element name="TDataSet.DataConvert.aSource">
<short>Pointer to memory area with source data</short>
</element>

<!-- argument Visibility: default
     Declaration: aDest: Pointer -->
<element name="TDataSet.DataConvert.aDest">
<short>Pointer to memory area for target data</short>
</element>

<!-- argument Visibility: default
     Declaration: aToNative: Boolean -->
<element name="TDataSet.DataConvert.aToNative">
<short><var>True</var> if the conversion should happen to native format.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Delete -->
<element name="TDataSet.Delete">
<short>Delete the current record.</short>
<descr>
<var>Delete</var> will delete the current record. 
This action will trigger the <link id="TDataset.BeforeDelete"/>, <link id="TDataset.BeforeScroll"/>, <link id="TDataset.AfterDelete"/> and <link id="TDataset.AfterScroll"/> events.
If the dataset was in edit mode, the edits will be canceled before the delete operation starts. 
</descr>
<errors>
If the dataset is empty or read-only, then an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDataset.Cancel"/>
<link id="TDataset.BeforeDelete"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterDelete"/>
<link id="TDataset.AfterScroll"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure DisableControls -->
<element name="TDataSet.DisableControls">
<short>Disable event propagation of controls</short>
<descr>
<p>
<var>DisableControls</var> tells the dataset to stop sending data-related events to the controls. This can be used before starting operations that will
cause the current record to change a lot, or before any other lengthy operation that may cause a lot of events to be sent to the controls that
show data from the dataset: each event will cause the control to update itself, which is a time-consuming operation that may also cause a 
lot of flicker on the screen.
</p>
<p>
The sending of events to the controls can be re-enabled with <link id="Tdataset.EnableControls"/>. 
Note that for each call to <var>DisableControls</var>, a matching call to <var>EnableControls</var> must be made: 
an internal count is kept and only when the count reaches zero, the controls are again notified of changes to the dataset.
It is therefore essential that the call to <var>EnableControls</var> is put in a <var>Finally</var> block:
</p>
<code>
MyDataset.DisableControls;
Try
  // Do some intensive stuff
Finally
  MyDataset.EnableControls
end;  
</code>
<p>
</p>
</descr>
<errors>
Failure to call enablecontrols will prevent the controls from receiving updates. The state can be checked with <link id="TDataset.ControlsDisabled"/>.
</errors>
<seealso>
<link id="TDataset.EnableControls"/>
<link id="TDataset.ControlsDisabled"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Edit -->
<element name="TDataSet.Edit">
<short>Set the dataset in editing mode.</short>
<descr>
<var>Edit</var> will set the dataset in edit mode: the contents of the current record can then be changed. This action will call the <link id="TDataset.BeforeEdit"/>
and <link id="TDataset.AfterEdit"/> events. If the dataset was already in insert or edit mode, nothing will happen (the events will also not be triggered). 
If the dataset is empty, this action will execute <link id="TDataset.Append"/> instead. 
</descr>
<errors>
If the dataset is read-only or not opened, then an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDataset.State"/>
<link id="TDataset.EOF"/>
<link id="TDataset.BOF"/>
<link id="TDataset.Append"/>
<link id="TDataset.BeforeEdit"/>
<link id="TDataset.AfterEdit"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure EnableControls -->
<element name="TDataSet.EnableControls">
<short>Enable event propagation of controls</short>
<descr><p>
<var>EnableControls</var> tells the dataset to resume sending data-related events to the controls. This must be used after a call to
<link id="TDataset.DisableControls"/> to re-enable updating of controls.
</p>
<p>
Note that for each call to <var>DisableControls</var>, a matching call to <var>EnableControls</var> must be made: 
an internal count is kept and only when the count reaches zero, the controls are again notified of changes to the dataset.
It is therefore essential that the call to <var>EnableControls</var> is put in a <var>Finally</var> block:
</p>
<code>
MyDataset.DisableControls;
Try
  // Do some intensive stuff
Finally
  MyDataset.EnableControls
end;  
</code>
</descr>
<errors>
Failure to call enablecontrols will prevent the controls from receiving updates. The state can be checked with <link id="TDataset.ControlsDisabled"/>.
</errors>
<seealso>
<link id="TDataset.DisableControls"/>
<link id="TDataset.ControlsDisabled"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function FieldByName(const FieldName: String) : TField -->
<element name="TDataSet.FieldByName">
<short>Search a field by name</short>
<descr>
<var>FieldByName</var> is a shortcut for <link id="TFields.FieldByname">Fields.FieldByName</link>: it searches for the field
with fieldname equalling <var>FieldName</var>. The case is performed case-insensitive. The matching field instance is returned.
</descr>
<errors>
If the field is not found, an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TFields.FieldByname"/>
<link id="TDataset.FindField"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FieldByName.Result">
<short>Field instance matching <var>FieldName</var></short>
</element>

<!-- argument Visibility: default
     Declaration: FieldName: String -->
<element name="TDataSet.FieldByName.FieldName">
<short>Fieldname to look for.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindField(const FieldName: String) : TField -->
<element name="TDataSet.FindField">
<short>Find a field by name</short>
<descr>
<var>FindField</var> is a shortcut for <link id="TFields.FindField">Fields.FindField</link>: it searches for the field
with fieldname equalling <var>FieldName</var>. The case is performed case-insensitive. The matching field instance is 
returned, and if no  match is found, <var>Nil</var> is returned.
</descr>
<seealso>
<link id="TDataset.FieldByname"/>
<link id="TFields.FindField"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FindField.Result">
<short>Field instance matching <var>FieldName</var></short>
</element>

<!-- argument Visibility: default
     Declaration: FieldName: String -->
<element name="TDataSet.FindField.FieldName">
<short>Fieldname to look for.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindFirst : Boolean -->
<element name="TDataSet.FindFirst">
<short>Find the first active record (deprecated)</short>
<descr>
<p>
<var>FindFirst</var> positions the cursor on the first record (taking into account filtering), and returns <var>True</var> if the cursor position was changed. 
This method must be implemented by descendents of <var>TDataset</var>: The implementation in <var>TDataset</var> always returns
<var>False</var>, indicating that the position was not changed.
</p>
<p>
This method is deprecated, use <link id="TDataset.First"/> instead.
</p>
</descr>
<seealso>
<link id="TDataset.First"/>
<link id="TDataset.FindLast"/>
<link id="TDataset.FindNext"/>
<link id="TDataset.FindPrior"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FindFirst.Result">
<short><var>True</var> if the cursor position was changed.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindLast : Boolean -->
<element name="TDataSet.FindLast">
<short>Find the last active record (deprecated)</short>
<descr>
<p>
<var>FindLast</var> positions the cursor on the last record (taking into account filtering), and returns <var>True</var> if the cursor position was changed. 
This method must be implemented by descendents of <var>TDataset</var>: The implementation in <var>TDataset</var> always returns
<var>False</var>, indicating that the position was not changed.
</p>
<p>
This method is deprecated, use <link id="TDataset.Last"/> instead.
</p>
</descr>
<seealso>
<link id="TDataset.Last"/>
<link id="TDataset.FindFirst"/>
<link id="TDataset.FindNext"/>
<link id="TDataset.FindPrior"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FindLast.Result">
<short><var>True</var> if the cursor position was changed.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindNext : Boolean -->
<element name="TDataSet.FindNext">
<short>Find the next active record (deprecated)</short>
<descr>
<p>
<var>FindLast</var> positions the cursor on the next record (taking into account filtering), and returns <var>True</var> if the cursor position was changed. 
This method must be implemented by descendents of <var>TDataset</var>: The implementation in <var>TDataset</var> always returns
<var>False</var>, indicating that the position was not changed.
</p>
<p>
This method is deprecated, use <link id="TDataset.Next"/> instead.
</p>
</descr>
<seealso>
<link id="TDataset.Next"/>
<link id="TDataset.FindFirst"/>
<link id="TDataset.FindLast"/>
<link id="TDataset.FindPrior"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FindNext.Result">
<short><var>True</var> if the cursor position was changed.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindPrior : Boolean -->
<element name="TDataSet.FindPrior">
<short>Find the previous active record (deprecated)</short>
<descr>
<p>
<var>FindPrior</var> positions the cursor on the previous record (taking into account filtering), and returns <var>True</var> if the cursor position was changed. 
This method must be implemented by descendents of <var>TDataset</var>: The implementation in <var>TDataset</var> always returns
<var>False</var>, indicating that the position was not changed.
</p>
<p>
This method is deprecated, use <link id="TDataset.Prior"/> instead.
</p>
</descr>
<seealso>
<link id="TDataset.Prior"/>
<link id="TDataset.FindFirst"/>
<link id="TDataset.FindLast"/>
<link id="TDataset.FindPrior"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.FindPrior.Result">
<short><var>True</var> if the cursor position was changed.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure First -->
<element name="TDataSet.First">
<short>Position the dataset on the first record.</short>
<descr>
<var>First</var> positions the dataset on the first record. This action will trigger the <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> events.
After the action is completed, the <link id="TDataset.BOF"/> property will be <var>True</var>. 
</descr>
<errors>
If the dataset is unidirectional or is closed, an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDataset.Prior"/>
<link id="TDataset.Last"/>
<link id="TDataset.Next"/>
<link id="TDataset.BOF"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterScroll"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure FreeBookmark(ABookmark: TBookmark);  Virtual -->
<element name="TDataSet.FreeBookmark">
<short>Free a bookmark obtained with <var>GetBookmark</var> (deprecated)</short>
<descr>
<var>FreeBookmark</var> must be used to free a bookmark obtained by <link id="TDataset.GetBookmark"/>. 
It should not be used on bookmarks obtained with the <link id="TDataset.Bookmark"/> property. 
Both <var>GetBookmark</var> and <var>FreeBookmark</var> are deprecated. 
Use the <var>Bookmark</var> property instead: it uses a string type, 
which is automatically disposed of when the string variable goes out of scope.
</descr>
<seealso>
<link id="TDataset.GetBookmark"/>
<link id="TDataset.Bookmark"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ABookmark: TBookmark -->
<element name="TDataSet.FreeBookmark.ABookmark">
<short>Bookmark to free.</short>
</element>

<!-- function Visibility: public
     Declaration: function GetBookmark : TBookmark;  Virtual -->
<element name="TDataSet.GetBookmark">
<short>Get a bookmark pointer (deprecated)</short>
<descr>
<p>
<var>GetBookmark</var> gets a bookmark pointer to the current cursor location. 
The <link id="TDataset.SetBookmark"/> call can be used to return to the current record in the dataset.
After use, the bookmark must be disposed of with the <link id="TDataset.FreeBookmark"/> call.
The bookmark will be <var>Nil</var> if the dataset is empty or not active.
</p>
<p>
This call is deprecated. Use the <link id="TDataset.Bookmark"/> property instead to get a bookmark.
</p>
</descr>
<seealso>
<link id="TDataset.SetBookmark"/>
<link id="TDataset.FreeBookmark"/>
<link id="TDataset.Bookmark"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.GetBookmark.Result">
<short>Bookmark for curren location or <var>Nil</var></short>
</element>

<!-- function Visibility: public
     Declaration: function GetCurrentRecord(Buffer: PChar) : Boolean;  Virtual -->
<element name="TDataSet.GetCurrentRecord">
<short>Copy the data for the current record in a memory buffer</short>
<descr>
<var>GetCurrentRecord</var> can be overridden by <var>TDataset</var> descendents to copy the data for the current record to <var>Buffer</var>. 
<var>Buffer</var>must point to a memory area, large enough to contain the data for the record. If the data is copied succesfully to the buffer, the function returns <var>True</var>.
The <var>TDataset</var> implementation is empty, and returns <var>False</var>.
</descr>
<seealso>
<link id="TDataset.ActiveBuffer"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.GetCurrentRecord.Result">
<short><var>True</var> if the data for the current record has been copied succesfully.</short>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: PChar -->
<element name="TDataSet.GetCurrentRecord.Buffer">
<short>Buffer to which record data must be copied.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetFieldList(List: TList;const FieldNames: String) -->
<element name="TDataSet.GetFieldList">
<short>Return field instances in a list</short>
<descr>
<var>GetfieldList</var> parses <var>FieldNames</var> for names of fields, and returns the field instances that match the names in <var>list</var>.
<var>FieldNames</var> must be a list of field names, separated by semicolons. The list is cleared prior to filling with the requested field instances.
</descr>
<errors>
If <var>FieldNames</var> contains a name of a field that does not exist in the dataset, then an <link id="EDatabaseError"/> exception will
be raised.
</errors>
<seealso>
<link id="TDataset.GetFieldNames"/>
<link id="TDataset.FieldByName"/>
<link id="TDataset.FindField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: List: TList -->
<element name="TDataSet.GetFieldList.List">
<short>List in whihc to return field instances</short>
</element>

<!-- argument Visibility: default
     Declaration: FieldNames: String -->
<element name="TDataSet.GetFieldList.FieldNames">
<short>Semicolon-separated list of fieldnames</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetFieldNames(List: TStrings) -->
<element name="TDataSet.GetFieldNames">
<short>Return a list of all available field names</short>
<descr>
<var>GetFieldNames</var> returns in <var>List</var> the names of all available fields, one field per item in the list. The dataset must be open for this function to work correctly.
</descr>
<seealso>
<link id="TDataset.GetFieldNameList"/>
<link id="TDataset.FieldByName"/>
<link id="TDataset.FindField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: List: TStrings -->
<element name="TDataSet.GetFieldNames.List">
<short>List in which to return field names</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GotoBookmark(ABookmark: TBookmark) -->
<element name="TDataSet.GotoBookmark">
<short>Jump to bookmark</short>
<descr>
<p>
<var>GotoBookmark</var> positions the dataset to the bookmark position indicated by <var>ABookMark</var>. <var>ABookmark</var> is a bookmark obtained by the <link id="TDataset.GetBookmark"/>
function. 
</p>
<p>
This function is deprecated, use the <link id="TDataset.Bookmark"/> property instead.
</p>
</descr>
<errors>
if <var>ABookmark</var> does not contain a valid bookmark, then an exception may be raised.
</errors>
<seealso>
<link id="TDataset.Bookmark"/>
<link id="TDataset.GetBookmark"/>
<link id="TDataset.FreeBookmark"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ABookmark: TBookmark -->
<element name="TDataSet.GotoBookmark.ABookmark">
<short>Bookmark to position the dataset on</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Insert -->
<element name="TDataSet.Insert">
<short>Insert a new record at the current position.</short>
<descr>
<var>Insert</var> will insert a new record at the current position. 
When this function is called, any pending modifications (when the dataset already is in insert or edit mode) will be posted. 
After that, the <link id="TDataset.BeforeInsert">BeforeInsert</link>, <link id="TDataset.BeforeScroll">BeforeScroll</link>, 
<link id="TDataset.OnNewrecord">OnNewRecord</link>, <link id="TDataset.AfterInsert">AfterInsert</link> and  <link id="TDataset.AfterScroll">AfterScroll</link> 
events are triggered in the order indicated here. The dataset is in the <var>dsInsert</var> state after this method is called, and the contents of the various
fields can be set. To write the new record to the underlying database <link id="TDataset.Post"/> must be called.
</descr>
<errors>
If the dataset is read-only, calling <var>Insert</var> will result in an <link id="EDatabaseError"/>.
</errors>
<seealso>
<link id="TDataset.BeforeInsert">BeforeInsert</link>
<link id="TDataset.BeforeScroll">BeforeScroll</link>
<link id="TDataset.OnNewrecord">OnNewRecord</link>
<link id="TDataset.AfterInsert">AfterInsert</link>
<link id="TDataset.AfterScroll">AfterScroll</link>
<link id="TDataset.Post"/>
<link id="TDataset.Append"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure InsertRecord(const Values: Array of const) -->
<element name="TDataSet.InsertRecord">
<short>Insert a new record with given values.</short>
<descr>
<var>InsertRecord</var> is not yet implemented in Free Pascal. It does nothing.
</descr>
<errors>
</errors>
<seealso>
<link id="TDataset.Insert"/>
<link id="TDataset.SetFieldValues"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Values: Array of const -->
<element name="TDataSet.InsertRecord.Values">
<short>Values to apply</short>
</element>

<!-- function Visibility: public
     Declaration: function IsEmpty : Boolean -->
<element name="TDataSet.IsEmpty">
<short>Check if the dataset contains no data</short>
<descr>
<var>IsEmpty</var> returns <var>True</var> if the dataset is empty, i.e. if <link id="TDataset.EOF">EOF</link> and <link id="TDataset.BOF"/> are both <var>True</var>, and the dataset is not in insert mode.
</descr>
<seealso>
<link id="TDataset.EOF"/>
<link id="TDataset.BOF"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.IsEmpty.Result">
<short><var>True</var> if the dataset has no data available.</short>
</element>

<!-- function Visibility: public
     Declaration: function IsLinkedTo(ADataSource: TDatasource) : Boolean -->
<element name="TDataSet.IsLinkedTo">
<short>Check whether a datasource is linked to the dataset</short>
<descr>
<var>IsLinkedTo</var> returns <var>True</var> if <var>ADatasource</var> is linked to this dataset, either directly (the <link id="TDatasource.Dataset">ADatasource.Dataset"</link>
points to the current dataset instance, or indirectly.
</descr>
<seealso>
<link id="TDatasource.Dataset"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.IsLinkedTo.Result">
<short>True if <var>ADatasource</var> is linked to the dataset.</short>
</element>

<!-- argument Visibility: default
     Declaration: ADataSource: TDatasource -->
<element name="TDataSet.IsLinkedTo.ADataSource">
<short><var>TDatasource</var> instance to check.</short>
</element>

<!-- function Visibility: public
     Declaration: function IsSequenced : Boolean;  Virtual -->
<element name="TDataSet.IsSequenced">
<short>Is the data sequenced</short>
<descr>
<var>IsSequenced</var> indicates whether it is safe to use the <link id="TDataset.RecNo"/> property to navigate in the records of the data.
By default, this property is set to <var>True</var>, but <var>TDataset</var> descendents may set this property to <var>False</var> (for instance,
unidirectional datasets), in which case <var>RecNo</var> should not be used to navigate through the data.
</descr>
<seealso>
<link id="TDataset.RecNo"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.IsSequenced.Result">
<short><var>True</var> if <var>RecNo</var> can be used for navigation.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Last -->
<element name="TDataSet.Last">
<short>Navigate forward to the last record</short>
<descr>
<p>
<var>Last</var> puts the cursor at the last record in the dataset, fetching more records from the underlying database if needed. 
It is equivalent to moving to the last record and calling <link id="TDataset.Next"/>.
After a call to <var>Last</var>, the <link id="TDataset.EOF"/> property will be <var>True</var>.
</p>
<p>
Calling this method will 
trigger the <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> events.
</p>
</descr>
<seealso>
<link id="TDataset.First"/>
<link id="TDataset.Next"/>
<link id="TDataset.EOF"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterScroll"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function Locate(const keyfields: String;const keyvalues: Variant;
               options: TLocateOptions) : Boolean;  Virtual -->
<element name="TDataSet.Locate">
<short>Locate a record based on some key values</short>
<descr>
<p>
<var>Locate</var> attempts to locate a record in the dataset. There are 2 possible cases when using <var>Locate</var>.
</p>
<ol>
<li><var>Keyvalues</var> is a single value. In that case, <var>KeyFields</var> is the name of the field whose value must be matched to the value in <var>KeyValues</var></li>
<li><var>Keyvalues</var> is a variant array. In that case, <var>KeyFields</var> must contain a list of names of fields (separated by semicolons) whose values must be matched to the values in the <var>KeyValues</var> array</li>
</ol>
<p>
The matching always happens according to the <var>Options</var> parameter. For a description of the possible values, see <link id="TLocateOption"/>.
</p>
<p>
If a record is found that matches the criteria, then the <var>locate</var> operation positions the cursor on this record, and returns <var>True</var>. 
If no record is found to match the criteria, <var>False</var> is returned, and the position of the cursor is unchanged.
</p>
<p>
The implementation in <var>TDataset</var> always returns <var>False</var>. 
It is up to <var>TDataset</var> descendents to implement this method and return an appropriate value.
</p>
</descr>
<seealso>
<link id="TDataset.Find"/>
<link id="TDataset.Lookup"/>
<link id="TLocateOption"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.Locate.Result">
<short><var>True</var> if a record matching <var>KeyValues</var> is found.</short>
</element>

<!-- argument Visibility: default
     Declaration: keyfields: String -->
<element name="TDataSet.Locate.keyfields">
<short>List of fields, separated by semicolons</short>
</element>

<!-- argument Visibility: default
     Declaration: keyvalues: Variant -->
<element name="TDataSet.Locate.keyvalues">
<short>Single value or array of values.</short>
</element>

<!-- argument Visibility: default
     Declaration: options: TLocateOptions -->
<element name="TDataSet.Locate.options">
<short>Options to take into account when searching for the record.</short>
</element>

<!-- function Visibility: public
     Declaration: function Lookup(const KeyFields: String;const KeyValues: Variant;
               const ResultFields: String) : Variant;  Virtual -->
<element name="TDataSet.Lookup">
<short>Search for a record and return matching values.</short>
<descr>
<var>Lookup</var> always returns <var>False</var> in <var>TDataset</var>. Descendents of <var>TDataset</var> can override this method
to call <link id="TDataset.Locate"/> to locate the record with fields <var>KeyFields</var> matching <var>KeyValues</var> and then to 
return the values of the fields in <var>ResultFields</var>. If <var>ResultFields</var> contains more than one fieldname (separated 
by semicolons), then the function returns an array. If there is only 1 fieldname, the value is returned directly.
</descr>
<errors>
If the dataset is unidirectional, then a <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDataset.Locate"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.Lookup.Result">
<short>Value(s) of <var>ResultFields</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: KeyFields: String -->
<element name="TDataSet.Lookup.KeyFields">
<short>Semicolon-separated list of fieldnames to locate record.</short>
</element>

<!-- argument Visibility: default
     Declaration: KeyValues: Variant -->
<element name="TDataSet.Lookup.KeyValues">
<short>Values for keyfields to locate record with.</short>
</element>

<!-- argument Visibility: default
     Declaration: ResultFields: String -->
<element name="TDataSet.Lookup.ResultFields">
<short>Semicolon-separated list of fieldnames whose values must be returned.</short>
</element>

<!-- function Visibility: public
     Declaration: function MoveBy(Distance: LongInt) : LongInt -->
<element name="TDataSet.MoveBy">
<short>Move the cursor position</short>
<descr>
<var>MoveBy</var> moves the current record pointer with <var>Distance</var> positions. <var>Distance</var> may be a positive number, 
in which case the cursor is moved forward, or a negative number, in which case the cursor is moved backward. The move operation will stop 
as soon as the beginning or end of the data is reached. The <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> events 
are triggered (once) when this method is called. The function returns the distance which was actually moved by the cursor.
</descr>
<errors>
A negative distance will result in an <link id="EDatabaseError"/> exception on unidirectional datasets.
</errors>
<seealso>
<link id="TDataset.RecNo"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterScroll"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.MoveBy.Result">
<short>Number of positions the cursor actually moved</short>
</element>

<!-- argument Visibility: default
     Declaration: Distance: LongInt -->
<element name="TDataSet.MoveBy.Distance">
<short>Number of positions the cursor should be moved</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Next -->
<element name="TDataSet.Next">
<short>Go to the next record in the dataset.</short>
<descr>
<var>Next</var> positions the cursor on the next record in the dataset.  It is equivalent to a <var>MoveBy(1)</var> operation. 
Calling this method triggers the <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> events.
If the dataset is located on the last known record (<link id="TDataset.EOF">EOF</link> is true), then no action is performed, and the events are not triggered.
</descr>
<errors>
Calling this method on a closed dataset will result in an <link id="EDatabaseError"/> exception.
</errors>
<seealso>
<link id="TDataset.MoveBy"/>
<link id="TDataset.Prior"/>
<link id="TDataset.Last"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterScroll"/> 
<link id="TDataset.EOF"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Open -->
<element name="TDataSet.Open">
<short>Activate the dataset: Fetch data into memory.</short>
<descr>
<p>
<var>Open</var> must be used to make the <var>TDataset</var> Active. It does nothing if the dataset is already active.
<var>Open</var> initialises the <var>TDataset</var> and brings the dataset in a browsable state:
</p>
<p>Effectively the following happens:
</p>
<ol>
<li>The BeforeOpen event is triggered.</li>
<li>The descendents <var>InternalOpen</var> method is called to actually fetch data and initialize fielddefs and field instances.</li>
<li><link id="TDataset.BOF">BOF</link>is set to <var>True</var></li>
<li>Internal buffers are allocated and filled with data</li>
<li>If the dataset is empty, <link id="TDataset.EOF">EOF</link> is set to true</li>
<li><link id="TDataset.State">State</link> is set to <var>dsBrowse</var></li>
<li>The <link id="TDataset.AfterOpen">AfterOpen</link> event  is triggered</li>
</ol>
</descr>
<errors>
If the descendent class cannot fetch the data, or the data does not match the field definitions present in the dataset, 
then an exception will be raised.
</errors>
<seealso>
<link id="TDataset.Active"/>
<link id="TDataset.State"/>
<link id="TDataset.BOF"/>
<link id="TDataset.EOF"/>
<link id="TDataset.BeforeOpen"/>
<link id="TDataset.AfterOpen"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Post;  Virtual -->
<element name="TDataSet.Post">
<short>Post pending edits to the database.</short>
<descr>
<var>Post</var> attempts to save pending edits when the dataset is in one of the edit modes: 
that is, after a <link id="TDataset.Insert">Insert</link>, <link id="Tdataset.Append">Append</link> or <link id="TDataset.Edit"/> operation.
The changes will be committed to memory - and usually immediately to the underlying database as well. Prior to saving the data to memory, 
it will check some constraints: in <var>TDataset</var>, the presence of a value for all required fields is checked. if for a required 
field no value is present, an exception will be raised.
A call to <var>Post</var> results in the triggering of the  <link id="TDataset.BeforePost">BeforePost</link>, <link id="TDataset.AfterPost">AfterPost</link> events. 
After the call to <var>Past</var>, the <link id="TDataset.State">State</link> of the dataset is again <var>dsBrowse</var>, i.e. the dataset is again in browse mode.
</descr>
<errors>
Invoking the <var>post</var> method when the dataset is not in one of the editing modes (<link id="dsEditModes"/>) will result in an <link id="EdatabaseError"/> exception.
If an exception occurs during the save operation, the <link id="Tdataset.OnPostError">OnPostError</link> event is triggered to handle the error.
</errors>
<seealso>
<link id="TDataset.Insert">Insert</link>
<link id="Tdataset.Append">Append</link>
<link id="TDataset.Edit">Edit</link>
<link id="Tdataset.OnPostError">OnPostError</link>
<link id="TDataset.BeforePost">BeforePost</link>
<link id="TDataset.AfterPost">AfterPost</link>
<link id="TDataset.State">State</link>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Prior -->
<element name="TDataSet.Prior">
<short>Go to the previous record</short>
<descr>
<var>Prior</var> moves the cursor to the previous record. It is equivalent to a <var>MoveBy(-1)</var> operation.
Calling this method triggers the <link id="TDataset.BeforeScroll"/> and <link id="TDataset.AfterScroll"/> events.
If the dataset is located on the first record, (<link id="TDataset.BOF">BOF</link> is true) then no action is performed, and the events are not triggered.
</descr>
<errors>
Calling this method on a closed dataset will result in an <link id="EDatabaseError"/> exception.
</errors>
<seealso>
<link id="TDataset.MoveBy"/>
<link id="TDataset.Next"/>
<link id="TDataset.First"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.AfterScroll"/> 
<link id="TDataset.BOF"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Refresh -->
<element name="TDataSet.Refresh">
<short>Refresh the records in the dataset</short>
<descr>
<var>Refresh</var> posts any pending edits, and refetches the data in the dataset from the underlying database, and attempts to reposition the cursor 
on the same record as it was. This operation is not supported by all datasets, and should be used with care. The repositioning may not always succeed, 
in which case the cursor will be positioned on the first record in the dataset. This is in particular true for unidirectional datasets. 
Calling <var>Refresh</var> results in the  triggering of the <link id="TDataset.BeforeRefresh">BeforeRefresh</link> and <link id="TDataset.AfterRefresh">AfterRefresh</link> events.
</descr>
<errors>
Refreshing may fail if the underlying dataset descendent does not support it.
</errors>
<seealso>
<link id="TDataset.Close"/>
<link id="TDataset.Open"/>
<link id="TDataset.BeforeRefresh">BeforeRefresh</link>
<link id="TDataset.AfterRefresh">AfterRefresh</link>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Resync(Mode: TResyncMode);  Virtual -->
<element name="TDataSet.Resync">
<short>Resynchronize the data buffer</short>
<descr>
<var>Resync</var> refetches the records around the cursor position. It should not be used by application code, instead <link id="TDataset.Refresh"/> should be used.
The <var>Resync</var> parameter indicates how the buffers should be refreshed.
</descr>
<seealso>
<link id="TDataset.Refresh"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Mode: TResyncMode -->
<element name="TDataSet.Resync.Mode">
<short>How to refresh the buffers.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetFields(const Values: Array of const) -->
<element name="TDataSet.SetFields">
<short>Set a number of field values at once</short>
<descr>
<var>SetFields</var> sets the values of the fields with the corresponding values in the array. 
It starts with the first field in the <link id="TDataset.Fields"/> property, and works it's way down the array.
</descr>
<errors>
If the dataset is not in edit mode, then an <link id="EDatabaseError"/> exception will be raised. 
If there are more values than fields, an <var>EListError</var> exception will be raised.
</errors>
<seealso>
<link id="TDataset.Fields"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Values: Array of const -->
<element name="TDataSet.SetFields.Values">
<short>Values to save in fields</short>
</element>

<!-- function Visibility: public
     Declaration: function Translate(Src: PChar;Dest: PChar;ToOem: Boolean) : Integer
                  ;  Virtual -->
<element name="TDataSet.Translate">
<short>Transliterate a buffer</short>
<descr>
<var>Translate</var>  is called for all string fields for which the <link id="TStringField.Transliterate"/> 
property is set to <var>True</var>. The <var>toOEM</var> parameter is set to <var>True</var> if the transliteration
must happen from the used codepage to the codepage used for storage, and if it is set to <var>False</var> then the
transliteration must happen from the native codepage to the storage codepage.
This call  must be overridden by descendents of <var>TDataset</var> to provide the 
necessary transliteration: <var>TDataset</var> just copies the contents of the <var>Src</var> buffer to the 
<var>Dest</var> buffer. The result must be the number of bytes copied to the destination buffer.
</descr>
<errors>
No checks are performed on the bufffers.
</errors>
<seealso>
<link id="TStringField.Transliterate"/> 
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.Translate.Result">
<short>Number of written bytes.</short>
</element>

<!-- argument Visibility: default
     Declaration: Src: PChar -->
<element name="TDataSet.Translate.Src">
<short>Source buffer</short>
</element>

<!-- argument Visibility: default
     Declaration: Dest: PChar -->
<element name="TDataSet.Translate.Dest">
<short>Destination buffer</short>
</element>

<!-- argument Visibility: default
     Declaration: ToOem: Boolean -->
<element name="TDataSet.Translate.ToOem">
<short>Should translation happen from native to OEM codepage or vice versa ?</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure UpdateCursorPos -->
<element name="TDataSet.UpdateCursorPos">
<short>Update cursor position</short>
<descr>
<var>UpdateCursorPos</var> should not be used in application code. It is used to ensure that the logical cursor position is the correct (physical) position.
</descr>
<seealso>
<link id="TDataset.Refresh"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure UpdateRecord -->
<element name="TDataSet.UpdateRecord">
<short>Indicate that the record contents have changed</short>
<descr>
<var>UpdateRecord</var> notifies controls that the contents of the current record have changed. It triggers the  event. 
This should never be called by application code, and is intended only for descendents of <var>TDataset</var>.
</descr>
<seealso>
<link id="TDataset.OnUpdateRecord">OnUpdateRecord</link>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function UpdateStatus : TUpdateStatus;  Virtual -->
<element name="TDataSet.UpdateStatus">
<short>Get the update status for the current record</short>
<descr>
<var>UpdateStatus</var> always returns <var>usUnModified</var> in the <var>TDataset</var> implementation. Descendent classes
should override this method to indicate the status for the current record in case they support cached updates: the function should
return the status of the current record: has the record been locally inserted, modified or deleted, or none of these.
<var>UpdateStatus</var> is not used in <var>TDataset</var> itself, but is provided so applications have a unique API to work with
datasets that have support for cached updates.
</descr>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSet.UpdateStatus.Result">
<short>Status of the current record</short>
</element>

<!-- property Visibility: public
     Declaration: BOF : Boolean -->
<element name="TDataSet.BOF">
<short>Is the cursor at the beginning of the data (on the first record)</short>
<descr>
<var>BOF</var> returns <var>True</var> if the first record is the first record in the dataset, <var>False</var> otherwise.
It will always be <var>True</var> if the dataset is just opened, or after a call to <link id="TDataset.First"/>.
As soon as <link id="TDataset.Next"/> is called, <var>BOF</var> will no longer be true.
</descr>
<seealso>
<link id="TDataset.EOF"/>
<link id="TDataset.Next"/>
<link id="TDataset.First"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Bookmark : TBookmarkStr -->
<element name="TDataSet.Bookmark">
<short>Get or set the current cursor position</short>
<descr>
<p>
<var>Bookmark</var> can be read to obtain a bookmark to the current position in the dataset. 
The obtained value can be used to return to current position at a later stage.
Writing the <var>Bookmark</var> property with a value previously obtained like this, 
will reposition the dataset on the same position as it was when the property was read.
</p>
<p>
This is often used when scanning all records, like this:
</p>
<code>
Var
  B : TBookmarkStr;
  
begin
  With MyDataset do
    begin
	B:=Bookmark;
    DisableControls;
	try
	  First;
	  While Not EOF do
	    begin
		DoSomething;
		Next;
		end;
	finally
	  EnableControls;
	  Bookmark:=B;
	end;
	end;	
</code>
<p>
At the end of this code, the dataset will be positioned on the same record as when the code
was started. The <link id="TDataset.DisableControls"/> and <link id="TDataset.EnableControls"/> calls
prevent the controls from receiving update notifications as the dataset scrolls through the records, tus
recuding flicker on the screen.
</p>
<p>
Note that bookmarks become invalid as soon as the dataset closes. A call to refresh may also destroy the bookmarks.
</p>
</descr>
<seealso>
<link id="TDataset.DisableControls"/>
<link id="TDataset.EnableControls"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: CanModify : Boolean -->
<element name="TDataSet.CanModify">
<short>Can the data in the dataset be modified</short>
<descr>
<var>CanModifiy</var> indicates whether the dataset allows editing. <var>Unidirectional</var> datasets do not allow
editing. Descendent datasets can impose additioanl conditions under which the data can not be modified (read-only 
datasets, for instance). If the <var>CanModify</var> property is <var>False</var>, then the edit, append or insert methods will fail.
</descr>
<seealso>
<link id="TDataset.Insert"/>
<link id="TDataset.Append"/>
<link id="TDataset.Delete"/>
<link id="Tdataset.Edit"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSource : TDatasource -->
<element name="TDataSet.DataSource">
<short>Datasource this dataset is connected to.</short>
<descr>
<var>Datasource</var> is the datasource this dataset is connected to, and from which it can get values for parameters.
In <var>TDataset</var>, the <var>Datasource</var> property is not used, and is always <var>Nil</var>. It is up to descendent classes that
actually support a datasource to implement getter and setter routines for the <var>Datasource</var> property.
</descr>
<seealso>
<link id="TDatasource"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DefaultFields : Boolean -->
<element name="TDataSet.DefaultFields">
<short>Is the dataset using persisten fields or not.</short>
<descr>
<p>
<var>DefaultFields</var> is <var>True</var> if the fields were generated dynamically when the dataset was opened. 
If it is <var>False</var> then the field instances are persistent, i;e. they were created at desin time with the fields editor.
If <var>DefaultFields</var> is <var>True</var>, then for each item in the <link id="TDataset.FieldDefs"/> property, a field 
instance is created. These fields instances are freed again when the dataset is closed.
</p>
<p>
If <var>DefaultFields</var> is <var>False</var>, then there may be less field instances than there are items in the <var>FieldDefs</var> property.
This can be the case for instance when opening a DBF file at runtime which has more fields than the file used at design time.
</p>
</descr>
<seealso>
<link id="TDataset.FieldDefs"/>
<link id="TDataset.Fields"/>
<link id="TField"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: EOF : Boolean -->
<element name="TDataSet.EOF">
<short>Indicates whether the last record has been reached.</short>
<descr>
<p>
<var>EOF</var> is <var>True</var> if the cursor is on the last record in the dataset, and no more records are available. It is also <var>True</var> for an empty dataset.
The <var>EOF</var> property will be set to <var>True</var> in the following cases:
</p>
<ol>
<li>The cursor is on the last record, and the <link id="TDataset.Next"/> method is called.</li>
<li>The <link id="TDataset.Last"/> method is called (which is equivalent to moving to the last record and calling <link id="TDataset.Next"/>).</li>
<li>The dataset is empty when opened.</li>
</ol>
<p>
In all other cases, <var>EOF</var> is <var>False</var>. Note: when the cursor is on the last-but-one record, and <var>Next</var> is called (moving the cursor to the last record), <var>EOF</var> will not yet 
be <var>True</var>. Only if both the cursor is on the last record <b>and</b> <var>Next</var> is called, will <var>EOF</var> become <var>True</var>.
</p>
<p> 
This means that the following loop will stop after the last record was visited:
</p>
<code>
With MyDataset do
  While not EOF do
    begin
    DoSomething;
    Next;
    end;
</code>
</descr>
<seealso>
<link id="TDataset.BOF"/>
<link id="TDataset.Next"/>
<link id="TDataset.Last"/>
<link id="TDataset.IsEmpty"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldCount : LongInt -->
<element name="TDataSet.FieldCount">
<short>Number of fields</short>
<descr>
<var>FieldCount</var> is the same as <link id="TFields.Count">Fields.Count</link>, i.e. the number of fields.
For a dataset with persistent fields (when <link id="TDataset.DefaultFields">DefaultFields</link> is <var>False</var>) 
then this number will be always the same every time the dataset is opened. For a dataset with dynamically created fields,
the number of fields may be different each time the dataset is opened.
</descr>
<seealso>
<link id="TFields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldDefs : TFieldDefs -->
<element name="TDataSet.FieldDefs">
<short>Definitions of available fields in the underlying database</short>
<descr>
<var>FieldDefs</var> is filled by the <var>TDataset</var> descendent when the dataset is opened. It represents the fields as they
are returned by the particular database when the data is initially fetched from the engine. If the dataset uses dynamically created 
fields (when <link id="TDataset.DefaultFields">DefaultFields</link> is <var>True</var>), then for each item in this list, a field i
nstance will be created with default properties available in the field definition.
If the dataset uses persistent fields, then the fields in the field list will be checked against the items in the <var>FieldDefs</var> property. 
If no matching item is found for a persistent field, then an exception will be raised. Items that exist in the fielddefs property but for which 
there is no matching field instance, are ignored.
</descr>
<seealso>
<link id="TDataset.Open"/>
<link id="TDataset.DefaultFields"/>
<link id="TDataset.Fields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Found : Boolean -->
<element name="TDataSet.Found">
<short>Check success of one of the <var>Find</var> methods</short>
<descr>
<var>Found</var> is <var>True</var> if the last of one of the <link id="TDataset.FindFirst"/>,<link id="TDataset.FindLast"/>,<link id="TDataset.FindNext"/> 
or <link id="TDataset.FindPrior"/> operations was succesful. 
</descr>
<seealso>
<link id="TDataset.FindFirst"/>
<link id="TDataset.FindLast"/>
<link id="TDataset.FindNext"/> 
<link id="TDataset.FindPrior"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Modified : Boolean -->
<element name="TDataSet.Modified">
<short>Was the current record modified ?</short>
<descr>
<var>Modified</var> is <var>True</var> if the current record was modified after a call to <link id="Tdataset.Edit"/> or <link id="Tdataset.Insert"/>.
It becomes <var>True</var> if a value was written to one of the fields of the dataset.
</descr>
<seealso>
<link id="Tdataset.Edit"/>
<link id="TDataset.Insert"/>
<link id="TDataset.Append"/>
<link id="TDataset.Cancel"/>
<link id="TDataset.Post"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: IsUniDirectional : Boolean -->
<element name="TDataSet.IsUniDirectional">
<short>Is the dataset unidirectional (i.e. forward scrolling only)</short>
<descr>
<p>
<var>IsUniDirectional</var> is <var>True</var> if the dataset is unidirectional. By default it is <var>False</var>, i.e. scrolling backwards is allowed.
If the dataset is unidirectional, then any attempt to scroll backwards (using one of <link id="TDataset.Prior"/> or <link id="TDataset.Next"/>), 
random positioning of the cursor, editing or filtering will result in an <link id="EDatabaseError"/>.
Unidirectional datasets are also not suitable for display in a grid, as they have only 1 record in memory at any given time: they are only useful for
performing an action on all records:
</p>
<code>
With MyDataset do
  While not EOF do
    begin
    DoSomething;
    Next;
    end;
</code>
</descr>
<seealso>
<link id="TDataset.Prior"/>
<link id="TDataset.Next"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: RecordCount : LongInt -->
<element name="TDataSet.RecordCount">
<short>Number of records in the dataset</short>
<descr>
<p>
<var>RecordCount</var> is the number of records in the dataset. This number is not necessarily equal to the number of records returned by a query. 
For optimization purposes, a <var>TDataset</var> descendent may choose not to fetch all records from the database when the dataset is opened. 
If this is the case, then the <var>RecordCount</var> will only reflect the number of records that have actually been fetched at the current time, 
and therefor the value will change as more records are fetched from the database.
</p>
<p>
Only when <var>Last</var> has been called (and the dataset has been forced to fetch all records returned by the database), will the value of 
<var>RecordCount</var> be equal to the number of records returned by the query.
</p>
<p>
In general, datasets based on in-memory data or flat files, will return the correct number of records in <var>RecordCount</var>.
</p>
</descr>
<seealso>
<link id="TDataset.RecNo"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: RecNo : LongInt -->
<element name="TDataSet.RecNo">
<short>Current record number</short>
<descr>
<p>
<var>RecNo</var> returns the current position in the dataset. It can be written to set the cursor to the indicated position.
This property must be implemented by <var>TDataset</var> descendents, for <var>TDataset</var> the property always returns -1.
</p>
<p>
This property should not be used if exact positioning is required. it is inherently unreliable.
</p>
</descr>
<seealso>
<link id="TDataset.RecordCount"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: RecordSize : Word -->
<element name="TDataSet.RecordSize">
<short>Size of the record in memory</short>
<descr>
<var>RecordSize</var> is the total size of the memory buffer used for the records.
This property returns always 0 in the <var>TDataset</var> implementation. 
Descendent classes should implement this property.
Note that this property does not necessarily reflect the actual data size for the records.
that may be more or less, depending on how the <var>TDataset</var> descendent manages it's data.
</descr>
<seealso>
<link id="TField.Datasize"/>
<link id="TDataset.RecordCount"/>
<link id="TDataset.RecNo"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: State : TDataSetState -->
<element name="TDataSet.State">
<short>Current operational state of the dataset</short>
<descr>
<p>
<var>State</var> determines the current operational state of the dataset. During it's lifetime, 
the dataset is in one of many states, depending on which operation is currently in progress:
</p>
<ul>
<li>If a dataset is closed, the <var>State</var> is <var>dsInactive</var>.</li>
<li>As soon as it is opened, it is in <var>dsBrowse</var> mode, and remains in this state while changing the cursor position.</li>
<li>If the <var>Edit</var> or <var>Insert</var> or <var>Append</var> methods is called,
the <var>State</var> changes to <var>dsEdit</var> or <var>dsInsert</var>, respectively.</li>
<li>
As soon as edits have been posted or cancelled, the state is again <var>dsBrowse</var>.
</li>
<li>Closing the dataset sets the state again to <var>dsInactive</var>.
</li>
</ul>
<p>
There are some other states, mainly connected to internal operations, but which can become visible in some of the
dataset's events.
</p>
</descr>
<seealso>
<link id="TDataset.Active"/>
<link id="TDataset.Edit"/>
<link id="TDataset.Insert"/>
<link id="TDataset.Append"/>
<link id="TDataset.Post"/>
<link id="TDataset.Cancel"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Fields : Tfields -->
<element name="TDataSet.Fields">
<short>Indexed access to the fields of the dataset.</short>
<descr>
<var>Fields</var> provides access to the fields of the dataset. It is of type <link id="TFields"/> and therefore
gives indexed access to the fields, but also allows other operations such as searching for fields based on their 
names or getting a list of fieldnames.
</descr>
<seealso>
<link id="TFieldDefs"/>
<link id="TField"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldValues[fieldname: String]: Variant; default -->
<element name="TDataSet.FieldValues">
<short>Acces to field values based on the field names.</short>
<descr>
<p>
<var>FieldValues</var> provides array-like access to the values of the fields, based on the names of the fields. 
The value is read or written as a variant type. It is equivalent to the following:
</p>
<code>
FieldByName(FieldName).AsVariant
</code>
<p>
It can be read as well as written.
</p>
</descr>
<seealso>
<link id="TFields.FieldByName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: fieldname: String -->
<element name="TDataSet.FieldValues.fieldname">
<short>Name of the field for which the value must be read or written.</short>
</element>

<!-- property Visibility: public
     Declaration: Filter : String -->
<element name="TDataSet.Filter">
<short>Filter to apply to the data in memory.</short>
<descr>
<p>
<var>Filter</var> is not implemented by <var>TDataset</var>. 
It is up to descendent classes to implement actual filtering: the filtering happens on in-memory data, and is not applied on the database level.
(in particular: setting the filter property will in no way influence the WHERE clause of an SQL-based dataset).
</p>
<p>
In general, the <var>filter</var> property accepts a SQL-like syntax usually encountered in the WHERE clause of an SQL SELECT statement.
</p>
<p>
The filter is only applied if the <var>Filtered</var> property is set to <var>True</var>. 
If the <var>Filtered</var> property is <var>False</var>, the <var>Filter</var> property is ignored.
</p>
</descr>
<seealso>
<link id="TDataset.Filtered"/>
<link id="TDataset.FilterOptions"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Filtered : Boolean -->
<element name="TDataSet.Filtered">
<short>Is the filter active or not.</short>
<descr>
<var>Filtered</var> determines whether the filter condition in <link id="TDataset.Filter"/> is applied or not. 
The filter is only applied if the <var>Filtered</var> property is set to <var>True</var>. 
If the <var>Filtered</var> property is <var>False</var>, the <var>Filter</var> property is ignored.
</descr>
<seealso>
<link id="TDataset.Filter"/>
<link id="TDataset.FilterOptions"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FilterOptions : TFilterOptions -->
<element name="TDataSet.FilterOptions">
<short>Options to apply when filtering</short>
<descr>
<var>FilterOptions</var> determines what options should be taken into account when applying the filter 
in <link id="TDataset.Filter"/>, such as case-sensitivity or whether to treat an asterisk as a wildcard:
By default, an asterisk (*) at the end of a literal string in the filter expression is treated as a wildcard.
When <var>FilterOptions</var> does not include <var>foNoPartialCompare</var>, strings that have an asterisk 
at the end, indicate a partial string match. In that case, the asterisk matches any number of characters.  
If <var>foNoPartialCompare</var> is included in the options, the asterisk is regarded as a regular character.
</descr>
<seealso>
<link id="TDataset.Filter"/>
<link id="TDataset.FilterOptions"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Active : Boolean -->
<element name="TDataSet.Active">
<short>Is the dataset open or closed.</short>
<descr>
<var>Active</var> is <var>True</var> if the dataset is open, and <var>False</var> if it is closed (<link id="TDataset.State"/> is then <var>dsInactive</var>).
Setting the <var>Active</var> property to <var>True</var> is equivalent to calling <link id="TDataset.Open"/>, 
setting it to <var>False</var> is equivalent to calling <link id="TDataset.Close"/>
</descr>
<seealso>
<link id="TDataset.State"/>
<link id="TDataset.Open"/>
<link id="TDataset.Close"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AutoCalcFields : Boolean -->
<element name="TDataSet.AutoCalcFields">
<short>How often should the value of calculated fields be calculated</short>
<descr>
<p>
<var>AutoCalcFields</var> is by default <var>true</var>, meaning that the values of calculated fields will be computed in the following cases:
</p>
<ul>
<li>When the dataset is opened</li>
<li>When the dataset is put in edit mode</li>
<li>When a data field changed</li>
</ul>
<p>
When <var>AutoCalcFields</var> is <var>False</var>, then the calculated fields are called whenever
</p>
<ul>
<li>The dataset is opened</li>
<li>The dataset is put in edit mode</li>
</ul>
<p>
Both proper calculated fields and lookup fields are computed. Calculated fields are computed through the <link id="TDataset.OnCalcFields"/> event.
</p>
</descr>
<seealso>
<link id="TField.FieldKind"/>
<link id="TDataset.OnCalcFields"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeOpen : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeOpen">
<short>Event triggered before the dataset is opened.</short>
<descr>
<var>BeforeOpen</var> is triggered before the dataset is opened. No actions have been performed yet when this event is called,
and the dataset is still in <var>dsInactive</var> state.
It can be used to set parameters and  options that influence the opening process. If an exception is raised during the event 
handler, the dataset remains closed.
</descr>
<seealso>
<link id="TDataset.AfterOpen"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterOpen : TDataSetNotifyEvent -->
<element name="TDataSet.AfterOpen">
<short>Event triggered after the dataset is opened.</short>
<descr>
<var>AfterOpen</var> is triggered after the dataset is opened. The dataset has fetched its data and is in <var>dsBrowse</var> state when 
this event is triggered. If the dataset is not empty, then a <link id="TDataset.AfterScroll"/> event will be triggered immediately after the
<var>AfterOpen</var> event.  If an exception is raised during the event  handler, the dataset remains open, but the <var>AfterScroll</var> 
event will not be triggered.
</descr>
<seealso>
<link id="TDataset.AfterOpen"/>
<link id="TDataset.State"/>
<link id="TDataset.AfterScroll"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeClose : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeClose">
<short>Event triggered before the dataset is closed.</short>
<descr>
<var>BeforeClose</var> is triggered before the dataset is closed. No actions have been performed yet when this event is called,
and the dataset is still in <var>dsBrowse</var> state or one of the editing states.
It can be used to prevent closing of the dataset, for instance if there are pending changes not yet committed to the database.
If an exception is raised during the event handler, the dataset remains opened.
</descr>
<seealso>
<link id="TDataset.AfterClose"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterClose : TDataSetNotifyEvent -->
<element name="TDataSet.AfterClose">
<short>Event triggered after the dataset is closed</short>
<descr>
<var>AfterOpen</var> is triggered after the dataset is opened. The dataset has discarded its data and has cleaned up it's internal
memory structures. It is in <var>dsInactive</var> state when this event is triggered.
</descr>
<seealso>
<link id="TDataset.BeforeClose"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeInsert : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeInsert">
<short>Event triggered before the dataset is put in insert mode.</short>
<descr>
<var>BeforeInsert</var> is triggered at the start of the <link id="TDataset.Append"/> or <link id="TDataset.Insert"/> methods.
The dataset is still in <var>dsBrowse</var> state when this event is triggered. If an exception is raised in the <var>BeforeInsert</var>
event handler, then the dataset will remain in <var>dsBrowse</var> state, and the append or insert operation is cancelled.
</descr>
<seealso>
<link id="TDataset.AfterInsert"/>
<link id="TDataset.Append"/>
<link id="TDataset.Insert"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterInsert : TDataSetNotifyEvent -->
<element name="TDataSet.AfterInsert">
<short>Event triggered after the dataset is put in insert mode.</short>
<descr>
<var>AfterInsert</var> is triggered after the dataset has finished putting the dataset in <var>dsInsert</var> state and it has
initialized the new record buffer. This event can be used e.g. to set initial field values. 
After the <var>Afterinsert</var> event, the <link id="TDataset.AfterScroll"/> event is still triggered. 
Raising an exception in the <var>AfterInsert</var> event, will prevent the <var>AfterScroll</var> event 
from being triggered, but does not undo the insert or append operation.
</descr>
<seealso>
<link id="TDataset.BeforeInsert"/>
<link id="TDataset.AfterScroll"/>
<link id="TDataset.Append"/>
<link id="TDataset.Insert"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeEdit : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeEdit">
<short>Event triggered before the dataset is put in edit mode.</short>
<descr>
<var>BeforeEdit</var> is the triggered at the start of the <link id="TDataset.Edit"/> method. 
The dataset is still in <var>dsBrowse</var> state when this event is triggered. If an exception is raised in the <var>BeforeEdit</var>
event handler, then the dataset will remain in <var>dsBrowse</var> state, and the edit operation is cancelled.
</descr>
<seealso>
<link id="TDataset.AfterEdit"/>
<link id="TDataset.Edit"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterEdit : TDataSetNotifyEvent -->
<element name="TDataSet.AfterEdit">
<short>Event triggered after the dataset is put in edit mode.</short>
<descr>
<var>AfterEdit</var> is triggered after the dataset has finished putting the dataset in <var>dsEdit</var> state and it has
initialized the edit buffer for the record. Raising an exception in the <var>AfterEdit</var> event does not undo the edit 
operation.
</descr>
<seealso>
<link id="TDataset.BeforeEdit"/>
<link id="TDataset.Edit"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforePost : TDataSetNotifyEvent -->
<element name="TDataSet.BeforePost">
<short>Event called before changes are posted to the underlying database</short>
<descr>
<var>BeforePost</var> is triggered at the start of the <link id="TDataset.Post"/> method, 
when the datset is still in one of the edit states (<var>dsEdit</var>,<var>dsInsert</var>).
If the dataset was not in an edit state when <var>Post</var> is called, the <var>BeforePost</var> event is not triggered.
This event can be used to supply values for required fields that have no value yet (the <var>Post</var> operation performs
the check on required fields only after this event), or it can be used to abort the post operation: if an exception is 
raised during the <var>BeforePost</var> operation, the posting operation is cancelled, and the dataset remains in the 
editing state it was in before the post operation.
</descr>
<seealso>
<link id="TDataset.post"/>
<link id="TDataset.AfterPost"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterPost : TDataSetNotifyEvent -->
<element name="TDataSet.AfterPost">
<short>Event called after changes have been posted to the underlying database</short>
<descr>
<var>AfterPost</var> is triggered when the <link id="TDataset.Post"/> operation was succesfully completed, and the dataset is again in <var>dsBrowse</var> state.
If an error occurred during the post operation, then the <var>AfterPost</var> event is not called, but the <link id="TDataset.OnPostError"/> event is triggered
instead.
</descr>
<seealso>
<link id="TDataset.BeforePost"/>
<link id="TDataset.Post"/>
<link id="TDataset.State"/>
<link id="TDataset.OnPostError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeCancel : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeCancel">
<short>Event triggered before a Cancel operation.</short>
<descr>
<var>BeforeCancel</var> is triggered at the start of the <link id="TDataset.Cancel"/> operation, when the state is still one of the editing states 
(<var>dsEdit</var>,<var>dsInsert</var>). The event handler can be used to abort the cancel operation: if an exception
is raised during the event handler, then the cancel operation stops. 
If the dataset was not in one of the editing states when the <var>Cancel</var> method was called, then the event is not triggered.
</descr>
<seealso>
<link id="TDataset.AfterCancel"/>
<link id="TDataset.Cancel"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterCancel : TDataSetNotifyEvent -->
<element name="TDataSet.AfterCancel">
<short>Event triggered after a Cancel operation.</short>
<descr>
<var>AfterCancel</var> is triggered when the <link id="TDataset.Cancel"/> operation was succesfully completed, and the dataset is again in <var>dsBrowse</var> state.
</descr>
<seealso>
<link id="TDataset.BeforeCancel"/>
<link id="TDataset.Cancel"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeDelete : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeDelete">
<short>Event triggered before a Delete operation.</short>
<descr>
<var>BeforeDelete</var> is triggered at the start of the <link id="TDataset.Delete"/> operation, when the dataset is still in <var>dsBrowse</var> state.
The event handler can be used to abort the delete operation: if an exception is raised during the event handler, then the delete operation stops. 
The event is followed by a <link id="TDataset.BeforeScroll"/> event. If the dataset was in insert mode when the <var>Delete</var> method was called, then
the event will not be called, as <link id="TDataset.Cancel"/> is called instead.
</descr>
<seealso>
<link id="TDataset.AfterDelete"/>
<link id="TDataset.Delete"/>
<link id="TDataset.BeforeScroll"/>
<link id="TDataset.Cancel"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterDelete : TDataSetNotifyEvent -->
<element name="TDataSet.AfterDelete">
<short>Event triggered after a succesful Delete operation.</short>
<descr><var>AfterDelete</var> is triggered after the succesfull completion of the <link id="TDataset.Delete"/> operation, 
when the dataset is again in <var>dsBrowse</var> state. The event is followed by a <link id="TDataset.AfterScroll"/> event. 
</descr>
<seealso>
<link id="TDataset.BeforeDelete"/>
<link id="TDataset.Delete"/>
<link id="TDataset.AfterScroll"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeScroll : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeScroll">
<short>Event triggered before the cursor changes position.</short>
<descr>
<var>BeforeScroll</var> is triggered before the cursor changes position. This can happen with one of the navigation methods:
<link id="TDataset.Next"/>, <link id="TDataset.Prior"/>, <link id="TDataset.First"/>, <link id="TDataset.Last"/>, but also
with two of the editing operations:<link id="TDataset.Insert"/> and <link id="TDataset.Delete"/>. Raising an exception in this 
event handler aborts the operation in progress.
</descr>
<seealso>
<link id="TDataset.AfterScroll"/>
<link id="TDataset.Next"/>
<link id="TDataset.Prior"/>
<link id="TDataset.First"/>
<link id="TDataset.Last"/>
<link id="TDataset.Insert"/>
<link id="TDataset.Delete"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterScroll : TDataSetNotifyEvent -->
<element name="TDataSet.AfterScroll">
<short>Event triggered after the cursor has changed position.</short>
<descr>
<var>AfterScroll</var> is triggered after the cursor has changed position. This can happen with one of the navigation methods:
<link id="TDataset.Next"/>, <link id="TDataset.Prior"/>, <link id="TDataset.First"/>, <link id="TDataset.Last"/>, but also
with two of the editing operations:<link id="TDataset.Insert"/> and <link id="TDataset.Delete"/> and after the dataset was opened.
It is suitable for displaying status information or showing a value that needs to be calculated for each record.
</descr>
<seealso>
<link id="TDataset.AfterScroll"/>
<link id="TDataset.Next"/>
<link id="TDataset.Prior"/>
<link id="TDataset.First"/>
<link id="TDataset.Last"/>
<link id="TDataset.Insert"/>
<link id="TDataset.Delete"/>
<link id="TDataset.Open"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BeforeRefresh : TDataSetNotifyEvent -->
<element name="TDataSet.BeforeRefresh">
<short>Event triggered before the data is refreshed.</short>
<descr>
<var>BeforeRefresh</var> is triggered at the start of the <link id="TDataset.Refresh"/> method, after the dataset has been put in browse mode.
If the dataset cannot be put in browse mode, the <var>BeforeRefresh</var> method wil not be triggered. If an exception is raised during the 
<var>BeforeRefresh</var> method, then the refresh method is cancelled and the dataset remains in the <var>dsBrowse</var> state.
</descr>
<seealso>
<link id="TDataset.Refresh"/>
<link id="TDataset.AfterRefresh"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AfterRefresh : TDataSetNotifyEvent -->
<element name="TDataSet.AfterRefresh">
<short>Event triggered after the data has been refreshed.</short>
<descr>
<var>AfterRefresh</var> is triggered at the end of the <link id="TDataset.Refresh"/> method, after the dataset has refreshed its data and is 
again in <var>dsBrowse</var> state. This event can be used to react on changes in data in the current record 
</descr>
<seealso>
<link id="TDataset.Refresh"/>
<link id="TDataset.State"/>
<link id="TDataset.BeforeRefresh"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnCalcFields : TDataSetNotifyEvent -->
<element name="TDataSet.OnCalcFields">
<short>Event triggered when values for calculated fields must be computed.</short>
<descr>
<var>OnCalcFields</var> is triggered whenever the dataset needs to (re)compute the values of any calculated fields in the
dataset. It is called very often, so this event should return as quickly as possible. Only the values of the calculated fields
should be set, no methods of the dataset that change the data or cursor position may be called during the execution of this event handler.
The frequency with which this event is called can be controlled through the <link id="TDataset.AutoCalcFields"/> property.
Note that the value of lookup fields does not need to be calculated in this event, their value is computed automatically 
before this event is triggered.
</descr>
<seealso>
<link id="TDataset.AutoCalcFields"/>
<link id="TField.Kind"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnDeleteError : TDataSetErrorEvent -->
<element name="TDataSet.OnDeleteError">
<short>Event triggered when a delete operation fails.</short>
<descr>
<p>
<var>OnDeleteError</var> is triggered when the <link id="TDataset.Delete"/> method fails to delete the record in the underlying database. 
The event handler can be used to indicate what the response to the failed delete should be. To this end, it gets the exception object passed to it (parameter <var>E</var>),
and it can examine this object to return an appropriate action in the <var>DataAction</var> parameter. The following responses are supported:
</p>
<dl>
<dt>daFail</dt><dd><printshort id="TDataAction.daFail"/></dd>
<dt>daAbort</dt><dd><printshort id="TDataAction.daAbort"/></dd>
<dt>daRetry</dt><dd><printshort id="TDataAction.daRetry"/></dd>
</dl>
<p>For more information, see also the description of the <link id="TDatasetErrorEvent"/> event handler type.</p>
</descr>
<seealso>
<link id="TDatasetErrorEvent"/>
<link id="TDataset.Delete"/>
<link id="TDataset.OnEditError"/>
<link id="TDataset.OnPostError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnEditError : TDataSetErrorEvent -->
<element name="TDataSet.OnEditError">
<short>Event triggered when an edit operation fails.</short>
<descr>
<p>
<var>OnEditError</var> is triggered when the <link id="TDataset.Edit"/> method fails to put the dataset in edit mode because the underlying database
engine reported an error. The event handler can be used to indicate what the response to the failed edit operation should be. 
To this end, it gets the exception object passed to it (parameter <var>E</var>), and it can examine this object to return an 
appropriate action in the <var>DataAction</var> parameter. The following responses are supported:
</p>
<dl>
<dt>daFail</dt><dd><printshort id="TDataAction.daFail"/></dd>
<dt>daAbort</dt><dd><printshort id="TDataAction.daAbort"/></dd>
<dt>daRetry</dt><dd><printshort id="TDataAction.daRetry"/></dd>
</dl>
<p>For more information, see also the description of the <link id="TDatasetErrorEvent"/> event handler type.</p>
</descr>
<seealso>
<link id="TDatasetErrorEvent"/>
<link id="TDataset.Edit"/>
<link id="TDataset.OnDeleteError"/>
<link id="TDataset.OnPostError"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnFilterRecord : TFilterRecordEvent -->
<element name="TDataSet.OnFilterRecord">
<short>Event triggered to filter records.</short>
<descr>
<var>OnFilterRecord</var> can be used to provide event-based filtering for datasets that support it. 
This event is only triggered when the <link id="Tdataset.Filtered"/> property is set to <var>True</var>.
The event handler should set the <var>Accept</var> parameter to <var>True</var> if the current record 
should be accepted, or to <var>False</var> if it should be rejected. No methods that change the state
of the dataset may be used during this event, and calculated fields or lookup field values are not yet
available. 
</descr>
<seealso>
<link id="TDataset.Filter"/>
<link id="TDataset.Filtered"/>
<link id="TDataset.state"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnNewRecord : TDataSetNotifyEvent -->
<element name="TDataSet.OnNewRecord">
<short>Event triggered when a new record is created.</short>
<descr>
<var>OnNewRecord</var> is triggered by the <link id="TDataset.Append"/> or <link id="TDataset.Insert"/> methods
when the buffer for the new record's data has been allocated. This event can be used to set default value for some
of the fields in the dataset. If an exception is raised during this event handler, the operation is cancelled and 
the dataset is put again in browse mode (<link id="TDataset.State"/> is again <var>dsBrowse</var>). 
</descr>
<seealso>
<link id="TDataset.Append"/>
<link id="TDataset.Insert"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnPostError : TDataSetErrorEvent -->
<element name="TDataSet.OnPostError">
<short>Event triggered when a post operation fails.</short>
<descr>
<p>
<var>OnPostError</var> is triggered when the <link id="TDataset.Post"/> method fails to post the changes in the dataset buffer to
the underlying database, because the database engine reported an error. The event handler can be used to indicate what the response 
to the failed post operation should be. To this end, it gets the exception object passed to it (parameter <var>E</var>), and it can 
examine this object to return an  appropriate action in the <var>DataAction</var> parameter. The following responses are supported:
</p>
<dl>
<dt>daFail</dt><dd><printshort id="TDataAction.daFail"/></dd>
<dt>daAbort</dt><dd><printshort id="TDataAction.daAbort"/></dd>
<dt>daRetry</dt><dd><printshort id="TDataAction.daRetry"/></dd>
</dl>
<p>For more information, see also the description of the <link id="TDatasetErrorEvent"/> event handler type.</p>
</descr>
<seealso>
<link id="TDatasetErrorEvent"/>
<link id="TDataset.Post"/>
<link id="TDataset.OnDeleteError"/>
<link id="TDataset.OnEditError"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDataLink
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDataLink">
<short>Data event handling agent for controls</short>
<descr>
<p>
<var>TDataLink</var> is used by GUI controls or datasets in a master-detail relationship to handle data events coming from
a <link id="TDatasource"/> instance. It is a class that exists for component programmers, application coders should never 
need to use <var>TDataLink</var> or one of it's descendents.
</p>
<p>
DB-Aware Component coders must use a <var>TDatalink</var> instance to handle all communication with a <link id="TDataset"/> instance,
rather than communicating directly with the dataset. <var>TDataLink</var> contains methods which are called by the various events 
triggered by the dataset. Inversely, it has some methods to trigger actions in the dataset.
</p>
<p>
<var>TDatalink</var> is an abstract class; it is never used directly. Instead, a descendent class is used which overrides the various
methods that are called in response to the events triggered by the dataset. Examples are .
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatasource"/>
<link id="TDetailDatalink"/>
<link id="TMasterDataLink"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create -->
<element name="TDataLink.Create">
<short>Initialize a new instance of <var>TDataLink</var></short>
<descr>
<var>Create</var> calls the inherited constructor and then initializes some fields. In particular, it sets the buffercount to 1.
</descr>
<seealso>
<link id="TDatalink.Destroy"/>
</seealso>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TDataLink.Destroy">
<short>Remove an instance of <var>TDatalink</var> from memory</short>
<descr>
<var>Destroy</var> cleans up the <var>TDatalink</var> instance (in particular, it removes itself from the datasource it is coupled to), and then calls the inherited destructor.
</descr>
<seealso>
<link id="TDatalink.Destroy"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function Edit : Boolean -->
<element name="TDataLink.Edit">
<short>Set the dataset in edit mode, if possible</short>
<descr>
<var>Edit</var> attempts to put the dataset in edit mode. It returns
<var>True</var> if this operation succeeded, <var>False</var> if not.
To this end, it calls the <link id="TDatasource.Edit">Edit</link> method of the <link id="TDataLink.Datasource">DataSource</link> to 
which the datalink instance is coupled. If the <link id="TDatasource.AutoEdit"/> property is <var>False</var> then this operation will
not succeed, inless the dataset is already in edit mode. GUI controls should always respect the result of this function, and not allow
the user to edit data if this function returned <var>false</var>.
</descr>
<seealso>
<link id="TDatasource"/>
<link id="TDatalink.Datasource"/>
<link id="TDatasource.Edit"/>
<link id="TDatasource.AutoEdit"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataLink.Edit.Result">
<short><var>True</var> if the dataset is ready for editing.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure UpdateRecord -->
<element name="TDataLink.UpdateRecord">
<short>Called when the data in the dataset must be updated</short>
<descr>
<var>Updaterecord</var> is called when the dataset expects the GUI controls to post any pending changes to
the dataset. This method guards against recursive behaviour: while an <var>UpdateRecord</var> is in progress,
the <link id="TDatalink.RecordChange"/> notification (which could result from writing data to the dataset)
will be blocked.
</descr>
<seealso>
<link id="TDatalink.RecordChange"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function ExecuteAction(Action: TBasicAction) : Boolean;  Virtual -->
<element name="TDataLink.ExecuteAction">
<short>Execute action</short>
<descr>
<var>ExecuteAction</var> implements action support. It should never be necessary to call <var>ExecuteAction</var> 
from program code, as it is called automatically whenever a target control needs to handle an action. This method 
must be overridden in case any additional action must be taken when the action must be executed. The implementation
in <var>TDatalink</var> checks if the action handles the datasource, and then calls <var>Action.ExecuteTarget</var>,
passing it the datasource. If so, it returns <var>True</var>.
</descr>
<seealso>
<link id="TDatalink.UpdateAction"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataLink.ExecuteAction.Result">
<short>Action was executed succesfully</short>
</element>

<!-- argument Visibility: default
     Declaration: Action: TBasicAction -->
<element name="TDataLink.ExecuteAction.Action">
<short>Action to execute</short>
</element>

<!-- function Visibility: public
     Declaration: function UpdateAction(Action: TBasicAction) : Boolean;  Virtual -->
<element name="TDataLink.UpdateAction">
<short>Update handler for actions</short>
<descr>
<var>UpdateAction</var> implements action update support. It should never be necessary to call <var>UpdateAction</var> 
from program code, as it is called automatically whenever a target control needs to update an action. This method 
must be overridden in case any specific action must be taken when the action must be updated. The implementation
in <var>TDatalink</var> checks if the action handles the datasource, and then calls <var>Action.UpdateTarget</var>,
passing it the datasource. If so, it returns <var>True</var>.
</descr>
<seealso>
<link id="TDataLink.ExecuteAction"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataLink.UpdateAction.Result">
<short><var>True</var> if the action handles the datalink's datasource.</short>
</element>

<!-- argument Visibility: default
     Declaration: Action: TBasicAction -->
<element name="TDataLink.UpdateAction.Action">
<short>Action to check</short>
</element>

<!-- property Visibility: public
     Declaration: Active : Boolean -->
<element name="TDataLink.Active">
<short>Is the link active</short>
<descr>
<var>Active</var> determines whether the events of the dataset are passed on to the control connected to the actionlink.
If it is set to <var>False</var>, then no events are passed between control and dataset. It is set to <link id="TDataset.Active"/> 
whenever the <link id="TDatalink.DataSource">DataSource</link> property is set.
</descr>
<seealso>
<link id="TDatalink.Datasource"/>
<link id="TDatalink.ReadOnly"/>
<link id="TDataset.Active"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: ActiveRecord : Integer -->
<element name="TDataLink.ActiveRecord">
<short>Currently active record</short>
<descr>
<var>ActiveRecord</var> returns the index of the active record in the dataset's record buffer for this datalink.
</descr>
<seealso>
<link id="TDatalink.BOF"/>
<link id="TDatalink.EOF"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BOF : Boolean -->
<element name="TDataLink.BOF">
<short>Is the dataset at the first record</short>
<descr>
<var>BOF</var> returns <link id="TDataset.BOF"/> if the dataset is available, <var>True</var> otherwise.
</descr>
<seealso>
<link id="TDatalink.EOF"/>
<link id="TDataset.BOF"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: BufferCount : Integer -->
<element name="TDataLink.BufferCount">
<short>Set to the number of record buffers this datalink needs.</short>
<descr>
<var>BufferCount</var> can be set to the number of buffers that the dataset should manage on behalf of the control 
connected to this datalink. By default, this is 1. Controls that must display more than 1 buffer (such as grids) 
can set this to a higher value.
</descr>
<seealso>
<link id="TDataset.ActiveBuffer"/>
<link id="TDatalink.ActiveRecord"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSet : TDataSet -->
<element name="TDataLink.DataSet">
<short>Dataset this datalink is connected to</short>
<descr>
<var>Dataset</var> equals <var>Datasource.Dataset</var> if the datasource is set, or <var>Nil</var> otherwise.
</descr>
<seealso>
<link id="TDatalink.DataSource"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSource : TDatasource -->
<element name="TDataLink.DataSource">
<short>Datasource this datalink is connected to</short>
<descr>
<var>Datasource</var> should be set to a <link id="TDatasource"/>  instance to get access to the dataset it is connected to.
A datalink never points directly to a <link id="TDataset"/> instance, always to a datasource. When the datasource is enabled 
or disabled, all <var>TDatalink</var> instances connected  to it are enabld or disabled at once.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatasource"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSourceFixed : Boolean -->
<element name="TDataLink.DataSourceFixed">
<short>Can the datasource be changed</short>
<descr>
<var>DatasourceFixed</var> can be set to <var>True</var> to prevent changing of the <link id="TDataLink.Datasource">DataSource</link> property.
When lengthy operations are in progress, this can be done to prevent user code (e.g. event handlers) from changing the datasource property which 
might interfere with the operation in progress.
</descr>
<seealso>
<link id="TDataLink.DataSource"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Editing : Boolean -->
<element name="TDataLink.Editing">
<short>Is the dataset in edit mode</short>
<descr>
<var>Editing</var> determines whether the dataset is in one of the edit states (dsEdit,dsInsert). It can be set into this mode by calling the <link id="TDatalink.Edit"/> method.
Never attempt to set the dataset in editing mode directly. The <var>Edit</var> method will perform the needed checks prior to setting the dataset in edit mode and will return
<var>True</var> if the dataset was succesfully set in the editing state.
</descr>
<seealso>
<link id="TDatalink.Edit"/>
<link id="TDataset.Edit"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Eof : Boolean -->
<element name="TDataLink.Eof">
<short></short>
<descr>
<var>EOF</var> returns <link id="TDataset.EOF"/> if the dataset is available, <var>True</var> otherwise.
</descr>
<seealso>
<link id="TDatalink.BOF"/>
<link id="TDataset.EOF"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: ReadOnly : Boolean -->
<element name="TDataLink.ReadOnly">
<short>Is the link readonly</short>
<descr>
<var>ReadOnly</var> can be set to <var>True</var> to indicate that the link is read-only, i.e. the connected control will not modify the dataset.
Methods as <link id="TDatalink.Edit"/> will check this property and fail if the link is read-only. This setting has no effect on the communication 
of dataset events to the datalink: the <link id="TDatalink.Active"/> property can be used to disable delivey of events to the datalink.
</descr>
<seealso>
<link id="TDatalink.Active"/>
<link id="TDatalink.edit"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: RecordCount : Integer -->
<element name="TDataLink.RecordCount">
<short>Number of records in the buffer of the dataset</short>
<descr>
<var>RecordCount</var> returns the number of records in the dataset's buffer. It is limited by the <link id="TDatalink.BufferCount"/> property: <var>RecordCount</var> i
s always less than <var>Buffercount</var>.
</descr>
<seealso>
<link id="TDatalink.BufferCount"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DetailDataSet : TDataSet -->
<element name="TDetailDataLink.DetailDataSet">
<short>Detail dataset in Master-detail relation</short>
<descr>
<var>DetailDataset</var> is the detail dataset in a master-detail relationship between 2 datasets.
<var>DetailDataset</var> is always <var>Nil</var> in <var>TDetailDatalink</var> and is only filled in 
in descendent classes like <link id="TMasterDatalink"/>. The master dataset is available through the 
regular <link id="TDataLink.DataSource"/> property.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TMasterDatalink"/>
<link id="TDataLink.DataSource"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TMasterDataLink
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TMasterDataLink">
<short>Datalink for Master-Detail relationships between datasets.</short>
<descr>
<p>
<var>TMasterDataLink</var> is a <var>TDatalink</var> descendent which handles master-detail relations. 
It can be used in <link id="TDataset"/> descendents that must have master-detail functionality: 
the detail dataset creates an instance of <var>TMasterDataLink</var> to point to the master dataset, 
which is subsequently available through the <link id="TDataLink.Dataset"/> property.
</p>
<p>
The class also provides functionailty for keeping a list of fields that make up the master-detail
functionality, in the <link id="TMasterDatalink.FieldNames"/> and <link id="TMasterDataLink.Fields"/> properties.
</p>
<p>
This class should never be used in application code.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatalink.DataSource"/>
<link id="TDatalink.DataSet"/>
<link id="TMasterDatalink.FieldNames"/>
<link id="TMasterDataLink.Fields"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ADataSet: TDataSet);  Virtual -->
<element name="TMasterDataLink.Create">
<short>Create a new instance of <var>TMasterDataLink</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TMasterDataLink</var>. The <var>ADataset</var> parameter
is the detail dataset in the master-detail relation: it is saved in the <link id="TDetailDataLink.DetailDataset">DetailDataset</link>
property. The master dataset must be set through the <link id="TDatalink.DataSource">DataSource</link> property, and is usually
set by the applictaion programmer.
</descr>
<seealso>
<link id="TDetailDataLink.DetailDataset"/>
<link id="TDatalink.Datasource"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataSet: TDataSet -->
<element name="TMasterDataLink.Create.ADataSet">
<short>Detail dataset of the master-detail relation.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TMasterDataLink.Destroy">
<short>Free the datalink instance from memory</short>
<descr>
<var>Destroy</var> cleans up the resources used by <var>TMasterDatalink</var> and then calls the inherited destructor.
</descr>
<seealso>
<link id="TMasterDatalink.Create"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: FieldNames : String -->
<element name="TMasterDataLink.FieldNames">
<short>List of fieldnames that make up the master-detail relationship</short>
<descr>
<var>FieldNames</var> is a semicolon-separated list of fieldnames in the master dataset (<link id="TDatalink.Dataset"/>) 
on which the master-detail relationship is based. Setting this property will fill the <link id="TMasterDataLink.Fields"/> 
property with the field instances of the master dataset. 
</descr>
<seealso>
<link id="TMasterDataLink.Fields"/>
<link id="TDatalink.Dataset"/>
<link id="TDataset.GetFieldList"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Fields : TList -->
<element name="TMasterDataLink.Fields">
<short>List of fields as specified in <var>FieldNames</var></short>
<descr>
<var>Fields</var> is filled with the <link id="TField"/> instances from the master dataset (<link id="TDatalink.Dataset"/>) when
the <link id="TMasterDatalink.FieldNames">FieldNames</link> property is set, and when the master dataset opens.
</descr>
<seealso>
<link id="TField"/>
<link id="TMasterDatalink.FieldNames"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnMasterChange : TNotifyEvent -->
<element name="TMasterDataLink.OnMasterChange">
<short>Called whenever the master dataset data changes</short>
<descr>
<var>OnMasterChange</var> is called whenever the field values in the master dataset changes, i.e. when it becomes active,
or when the current record changes. If the <link id="TMasterDataLink.Fields"/> list is empty, <link id="TMasterDataLink.OnMasterDisable"/> is called instead.
</descr>
<seealso>
<link id="TMasterDataLink.OnMasterDisable"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: OnMasterDisable : TNotifyEvent -->
<element name="TMasterDataLink.OnMasterDisable">
<short>Called whenever the master dataset is disabled</short>
<descr>
<var>OnMasterDisable</var> is called whenever the master dataset is disabled, or when it is active and the field list is empty.
</descr>
<seealso>
<link id="TMasterDataLink.OnMasterChange"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TDataChangeEvent = procedure(Sender: TObject;Field: TField) of object -->
<element name="TDataChangeEvent">
<short>Event handler prototype when a field's data has changed.</short>
<descr>
<var>TDataChangeEvent</var> is the event handler prototype for the <link id="TDatasource.OnDataChange"/> event.
The sender parameter is the <var>TDatasource</var> instance that triggered the event, and the <var>Field</var> 
parameter is the field whose data has changed. If the dataset has scrolled, then the <var>Field</var> parameter 
is <var>Nil</var>.
</descr>
<seealso>
<link id="TDatasource.OnDataChange"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Sender: TObject -->
<element name="TDataChangeEvent.Sender">
<short>Datasource that triggered the event</short>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TDataChangeEvent.Field">
<short>Field that changed, or <var>Nil</var> if record changed.</short>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDataSource.Create">
<short>Create a new instance of <var>TDatasource</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TDatasource</var>. 
It simply allocates some resources and then calls the inherited constructor.
</descr>
<seealso>
<link id="TDatasource.Destroy"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDataSource.Create.AOwner">
<short>Owner for the new <var>TDatasource</var> instance.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TDataSource.Destroy">
<short>Remove a <var>TDatasource</var> instance from memory</short>
<descr>
<var>Destroy</var> notifies all <link id="TDataLink"/> instances connected to it that the dataset is no loner available, 
and then removes itself from the <var>TDatalink</var> instance. It then cleans up all resources and calls the inherited 
constructor.
</descr>
<seealso>
<link id="TDatasource.Create"/>
<link id="TDatalink"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Edit -->
<element name="TDataSource.Edit">
<short>Put the dataset in edit mode, if needed</short>
<descr>
<var>Edit</var> will check <link id="TDatasource.AutoEdit">AutoEdit</link>: if it is <var>True</var>, then it puts the 
<link id="TDatasource.Dataset">Dataset</link> it is connected to in edit mode, if it was in browse mode. If <var>AutoEdit</var> 
is <var>False</var>, then nothing happens.  Application or component code that deals with GUI development should always 
attempt to set a dataset in edit mode through this method instead of calling <link id="TDataset.Edit"/> directly.
</descr>
<errors>
An <link id="EDatabaseError"/> exception can occur if the dataset is read-only or fails to set itself in edit mode.
(e.g. unidirectional datasets).
</errors>
<seealso>
<link id="TDatasource.AutoEdit"/>
<link id="TDataset.Edit"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- function Visibility: public
     Declaration: function IsLinkedTo(ADataSet: TDataSet) : Boolean -->
<element name="TDataSource.IsLinkedTo">
<short>Check if a dataset is linked to a certain dataset</short>
<descr>
<var>IsLinkedTo</var> checks if it is somehow linked to <var>ADataset</var>: it checks the <link
id="TDatasource.Dataset">Dataset</link> property, and returns <var>True</var> if it is the same. 
If not, it continues by checking any detail dataset fields that the dataset posesses (recursively). 
This function can be used to detect circular links in e.g. master-detail relationships.
</descr>
<seealso>
<link id="TDatasource.Dataset"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TDataSource.IsLinkedTo.Result">
<short><var>True</var> if the datasource is linked to <var>ADataset</var></short>
</element>

<!-- argument Visibility: default
     Declaration: ADataSet: TDataSet -->
<element name="TDataSource.IsLinkedTo.ADataSet">
<short>Dataset to check</short>
</element>

<!-- property Visibility: public
     Declaration: State : TDataSetState -->
<element name="TDataSource.State">
<short>State of the dataset</short>
<descr>
<var>State</var> contains the <link id="Tdataset.State">State</link> of the dataset it is connected to, or <var>dsInactive</var> if the dataset property is not set or
the datasource is not enabled. Components connected to a dataset through a datasource property should always check <var>TDatasource.State</var> instead of checking 
<link id="TDataset.State"/> directly, to take into account the effect of the <link id="TDatasource.Enabled">Enabled</link> property.
</descr>
<seealso>
<link id="TDataset.State"/>
<link id="TDatasource.Enabled"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: AutoEdit : Boolean -->
<element name="TDataSource.AutoEdit">
<short>Should the dataset be put in edit mode automatically</short>
<descr>
<var>AutoEdit</var> can be set to <var>True</var> to prevent visual controls from putting the dataset in edit mode. Visual controls use the <link id="TDatasource.Edit"/> method to
attempt to put the dataset in edit mode as soon as the user changes something. If <var>AutoEdit</var> is set to <var>False</var> then the <var>Edit</var> method does nothing.
The effect is that the user must explicitly set the dataset in edit mode (by clicking some button or some other action) before the fields can be edited.
</descr>
<seealso>
<link id="TDatasource.Edit"/>
<link id="TDataset.Edit"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DataSet : TDataSet -->
<element name="TDataSource.DataSet">
<short>Dataset this datasource is connected to</short>
<descr>
<var>Dataset</var> must be set by the applictaion programmer to the <link id="TDataset"/> instance for which this datasource is handling events.
Setting it to <var>Nil</var> will disable all controls that are connected to this datasource instance.  Once it is set and the datasource is enabled, 
the datasource will start  sending data events to the controls or components connected to it.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatasource.Enabled"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Enabled : Boolean -->
<element name="TDataSource.Enabled">
<short>Enable or disable sending of events</short>
<descr>
<var>Enabled</var> is by default set to <var>True</var>: the datasource instance communicates events from the dataset to components connected to
the datasource, and vice versa: components can interact with the dataset. If the <var>Enabled</var> property is set to <var>False</var> then no 
events are communicated to connected components: it is as if the dataset property was set to <var>Nil</var>. Reversely, the components cannot 
interact with the dataset if the <var>Enabled</var> property is set to <var>False</var>.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDatasource.Dataset"/>
<link id="TDatasource.AutoEdit"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnStateChange : TNotifyEvent -->
<element name="TDataSource.OnStateChange">
<short>Called whenever the state of the dataset changes</short>
<descr>
<var>OnStateChange</var> is called whenever the <link id="TDataset.State"/> property changes, and the datasource is enabled. It can be used in application code
to react to state changes: enabling or disabling non-DB-Aware controls, setting empty values etc.
</descr>
<seealso>
<link id="TDatasource.OnUpdateData"/>
<link id="TDatasource.OnStateChange"/>
<link id="TDataset.State"/>
<link id="TDatasource.Enabled"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnDataChange : TDataChangeEvent -->
<element name="TDataSource.OnDataChange">
<short>Called whenever data changes in the current record</short>
<descr>
<var>OnDatachange</var> is called whenever a field value changes: if the <var>Field</var> parameter is set, a single field value changed. 
If the <var>Field</var> parameter is <var>Nil</var>, then the whole record changed: when the dataset is opened, 
when the user scrolls to a new record. This event handler can be set to react to data changes:
to update the contents of non-DB-aware controls for instance. The event is not called when the datasource is not enabled.
</descr>
<seealso>
<link id="TDatasource.OnUpdateData"/>
<link id="TDatasource.OnStateChange"/>
<link id="TDataset.AfterScroll"/>
<link id="TField.OnChange"/>
<link id="TDatasource.Enabled"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnUpdateData : TNotifyEvent -->
<element name="TDataSource.OnUpdateData">
<short>Called whenever the data in the dataset must be updated</short>
<descr>
<var>OnUpdateData</var> is called whenever the dataset needs the latest data from the controls: usually just before a <link id="TDataset.Post"/>
operation. It can be used to copy data from non-db-aware controls to the dataset just before the dataset is posting the changes to the underlying 
database.
</descr>
<seealso>
<link id="TDatasource.OnDataChange"/>
<link id="TDatasource.OnStateChange"/>
<link id="TDataset.Post"/>
</seealso>
</element>

<!-- "class of" type Visibility: default
     Declaration: TDBDatasetClass = Class of TDBDataset -->
<element name="TDBDatasetClass">
<short>Class of <var>TDBDataset</var></short>
<descr>
<var>TDBDatasetClass</var> is the class pointer for <link id="TDBDataset"/>
</descr>
<seealso>
<link id="TDBDataset"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TDBDataset
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TDBDataset">
<short>Dataset connected to a database.</short>
<descr>
<p>
<var>TDBDataset</var> is a <var>TDataset</var> descendent which introduces the concept of a database: a central component (<link id="TDatabase"/>)
which represents a connection to a database. This central component is exposed in the <link id="TDBDataset.Database"/> property. When the database
is no longer connected, or is no longer in memory, all <var>TDBDataset</var> instances connected to it are disabled.
</p>
<p>
<var>TDBDataset</var> also introduces the notion of a transaction, exposed in the <link id="TDBDataset.Transaction">Transaction</link> property.
</p>
<p>
<var>TDBDataset</var> is an abstract class, it should never be used directly.
</p>
<p>
Dataset component writers should descend their component from <var>TDBDataset</var> if they wish to introduce a central database connection component.
The database connection logic will be handled automatically by <var>TDBDataset</var>.
</p>
</descr>
<seealso>
<link id="TDatabase"/>
<link id="TDBTransaction"/>
</seealso>
</element>

<!-- destructor Visibility: public
     Declaration: destructor destroy;  Override -->
<element name="TDBDataset.destroy">
<short>Remove the <var>TDBDataset</var> instance from memory.</short>
<descr>
<var>Destroy</var> will disconnect the <var>TDBDataset</var> from its 
<link id="TDBDataset.Database">Database</link> and <link id="TDBDataset.Transaction">Transaction</link>. 
After this it calls the inherited destructor.
</descr>
<seealso>
<link id="TDBDataset.Database"/>
<link id="TDatabase"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataBase : TDataBase -->
<element name="TDBDataset.DataBase">
<short>Database this dataset is connected to</short>
<descr>
<p><var>Database</var> should be set to the <link id="TDatabase"/> instance this dataset is connected to. 
It can only be set when the dataset is closed.
</p>
<p>
Descendent classes should check in the property setter whether the database instance is of the correct class.
</p>
</descr>
<errors>
If the property is set when the dataset is active, an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TDatabase"/>
<link id="TDBDataset.Transaction"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Transaction : TDBTransaction -->
<element name="TDBDataset.Transaction">
<short>Transaction in which this dataset is running.</short>
<descr>
<p>
<var>Transaction</var> points to a <link id="TDBTransaction"/> component that represents the transaction this 
dataset is active in. This property should only be used for databases that support transactions.
</p>
<p>
The property can only be set when the dataset is disabled.
</p>
</descr>
<seealso>
<link id="TDBTransaction"/>
<link id="TDBDataset.Database"/>
</seealso>
</element>

<!-- "class of" type Visibility: default
     Declaration: TDBTransactionClass = Class of TDBTransaction -->
<element name="TDBTransactionClass">
<short>Class of <var>TDBTransaction</var></short>
<descr>
<var>TDBTransactionClass</var> is the class pointer for the <link id="TDBTransaction"/> class.
</descr>
<seealso>
<link id="TDBTransaction"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDBTransaction.Create">
<short>Transaction property</short>
<descr>
<var>Create</var> initializes a new <var>TDBTransaction</var> instance. It sets up the necessary
resources, after having called the inherited constructor.
</descr>
<seealso>
<link id="TDBTransaction.Destroy"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDBTransaction.Create.AOwner">
<short>Owner for the new <var>TDBTransaction</var> instance.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor destroy;  Override -->
<element name="TDBTransaction.destroy">
<short>Remove a <var>TDBTransaction</var> instance from memory.</short>
<descr>
<var>Destroy</var> first disconnects all connected <link id="TDBDataset"/> instances
and then cleans up the resources allocated in the <link id="TDBTransaction.Create">Create</link> 
constructor. After that it calls the inherited destructor.
</descr>
<seealso>
<link id="TDBTransaction.Create"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CloseDataSets -->
<element name="TDBTransaction.CloseDataSets">
<short>Close all connected datasets</short>
<descr>
<var>CloseDatasets</var> closes all connected datasets (All <link id="TDBDataset"/> instances whose 
<link id="TDBDataset.Transaction">Transaction</link> property points to this <var>TDBTransaction</var> instance).
</descr>
<seealso>
<link id="TDBDataset"/>
<link id="TDBDataset.Transaction"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataBase : TDataBase -->
<element name="TDBTransaction.DataBase">
<short>Database this transaction is connected to</short>
<descr>
<var>Database</var> points to the database that this transaction is part of. This property can be set only when
the transaction is not active.
</descr>
<errors>
Setting this property to a new value when the transaction is active will result in an <link id="EDatabaseError"/> 
exception.
</errors>
<seealso>
<link id="TDBTransaction.Active"/>
<link id="TDatabase"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Active : Boolean -->
<element name="TDBTransaction.Active">
<short>Is the transaction active or not</short>
<descr>
<var>Active</var> is <var>True</var> if a transaction was started using <link id="TDBTransaction.StartTransaction"/>. 
Reversely, setting <var>Active</var> to <var>True</var> will call <var>StartTransaction</var>, setting it to <var>False</var> 
will call <link id="TDBTransaction.EndTransaction"/>.
</descr>
<seealso>
<link id="TDBTransaction.StartTransaction"/>
<link id="TDBTransaction.EndTransaction"/>
</seealso>
</element>

<!-- procedure type Visibility: default
     Declaration: TLoginEvent = procedure(Sender: TObject;Username: String;
                        Password: String) of object -->
<element name="TLoginEvent">
<short>Login event handler</short>
<descr>
<var>TLoginEvent</var> is the prototype for the <link id="TCustomConnection.OnLogin"/>
event handler. It gets passed the <var>TCustomConnection</var> instance that is trying to login,
and the initial username and password.
</descr>
<seealso>
<link id="TCustomConnection.OnLogin"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Sender: TObject -->
<element name="TLoginEvent.Sender">
<short><var>TCustomConnection</var> that is attempting a login</short>
</element>

<!-- argument Visibility: default
     Declaration: Username: String -->
<element name="TLoginEvent.Username">
<short>Username used to log in</short>
</element>

<!-- argument Visibility: default
     Declaration: Password: String -->
<element name="TLoginEvent.Password">
<short>Password used to log in.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TCustomConnection
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TCustomConnection">
<short>Abstract class for connections to a server</short>
<descr>
<var>TCustomConnection</var> must be used for all database classes that need a connection to a server.
The class introduces some methods and classes to activate the connection (<link id="TCustomConnection.Open">Open</link>)
and to deactivate the connection (<link id="TCustomConnection.Close"/>), plus a property to inspect the state 
(<link id="TCustomConnection.Connected">Connected</link>) of the connected.
</descr>
<seealso>
<link id="TCustomConnection.Open"/>
<link id="TCustomConnection.Close"/>
<link id="TCustomConnection.Connected"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Close -->
<element name="TCustomConnection.Close">
<short>Close the connection</short>
<descr>
<p>
<var>Close</var> closes the connection with the server if it was connected.  
Calling this method first triggers the <link id="TCustomConnection.BeforeDisconnect">BeforeDisconnect</link> event.
If an exception is raised during the execution of that event handler, the disconnect process is aborted. After calling
this event, the connection is actually closed. After the
connection was closed, the <link id="TCustomConnection.AfterDisconnect">AfterDisconnect</link> event is triggered.
</p>
<p>
Calling the <var>Close</var> method is equivalent to setting the <link id="TCustomConnection.Connected">Connected</link>
property to <var>False</var>.
</p>
<p>
If <var>ForceClose</var> is <var>True</var> then the descendent should ignore errors from the underlying
connection, allowing all datasets to be closed properly.
</p>
</descr>
<errors>
If the connection cannot be broken for some reason, an <link id="EDatabaseError"/> exception will be raised.
</errors>
<seealso>
<link id="TCustomConnection.BeforeDisconnect"/>
<link id="TCustomConnection.AfterDisconnect"/>
<link id="TCustomConnection.Open"/>
<link id="TCustomConnection.Connected"/>
</seealso>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TCustomConnection.Destroy">
<short>Remove the <var>TCustomconnection</var> instance from memory</short>
<descr>
<var>Destroy</var> closes the connection, and then calls the inherited destructor.
</descr>
<errors>
If an exception is raised during the disconnect process, an exception will be raise, and the instance is not
removed from memory.
</errors>
<seealso>
<link id="TCustomConnection.Close"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Open -->
<element name="TCustomConnection.Open">
<short>Makes the connection to the server</short>
<descr>
<p>
<var>Open</var> establishes the connection with the server if it was not yet connected.
Calling this method first triggers the <link id="TCustomConnection.BeforeConnect">BeforeConnect</link> event.
If an exception is raised during the execution of that event handler, the connect process is aborted.  
If <link id="TCustomConnection.LoginPrompt">LoginPrompt</link> is <var>True</var>, the <link id="TCustomConnection.OnLogin">OnLogin</link>  
event handler is called. Only after this event, the connection is actually established. After the
connection was established, the <link id="TCustomConnection.AfterConnect">AfterConnect</link> event is triggered.
</p>
<p>
Calling the <var>Open</var> method is equivalent to setting the <link id="TCustomConnection.Connected">Connected</link>
property to <var>True</var>.
</p>
</descr>
<errors>
If an exception is raised during the <var>BeforeConnect</var> or <var>OnLogin</var> handlers, the connection is not actually established.
</errors>
<seealso>
<link id="TCustomConnection.BeforeConnect"/>
<link id="TCustomConnection.LoginPrompt"/>
<link id="TCustomConnection.OnLogin"/>
<link id="TCustomConnection.AfterConnect"/>
<link id="TCustomConnection.Connected"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSetCount : LongInt -->
<element name="TCustomConnection.DataSetCount">
<short>Number of datasets connected to this connection</short>
<descr>
<var>DatasetCount</var> is the number of datasets connected to this connection component. 
The actual datasets are available through the <link id="TCustomConnection.Datasets">Datasets</link>
array property.
As implemented in <var>TCustomConnection</var>, this property is always zero. Descendent classes implement
the actual count.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TCustomConnection.Datasets"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: DataSets[Index: LongInt]: TDataSet -->
<element name="TCustomConnection.DataSets">
<short>Datasets linked to this connection</short>
<descr>
<var>Datasets</var> allows indexed access to the datasets connected to this connection. <var>Index</var> is a zero-based indexed, it's maximum value is <link id="TCustomConnection.DatasetCount">DatasetCount-1</link>.
</descr>
<seealso>
<link id="TCustomConnection.DatasetCount">DatasetCount</link>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: LongInt -->
<element name="TCustomConnection.DataSets.Index">
<short>Zero based index, upper bound equals <var>DatasetCount-1</var></short>
</element>

<!-- property Visibility: published
     Declaration: Connected : Boolean -->
<element name="TCustomConnection.Connected">
<short>Is the connection established or not</short>
<descr>
<var>Connected</var> is <var>True</var> if the connection to the server is established, <var>False</var> if it is disconnected. 
The property can be set to <var>True</var> to establish a connection (equivalent to calling <link id="TCustomConnection.Open"/>, 
or to <var>False</var> to break it (equivalent to calling <link id="TCustomConnection.Close"/>.
</descr>
<seealso>
<link id="TCustomConnection.Open"/>
<link id="TCustomConnection.Close"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: LoginPrompt : Boolean -->
<element name="TCustomConnection.LoginPrompt">
<short>Should the <var>OnLogin</var> be triggered</short>
<descr>
<var>LoginPrompt</var> can be set to <var>True</var> if the <var>OnLogin</var> handler should be called when the <var>Open</var> 
method is called. If it is not <var>True</var>, then the event handler is not called.
</descr>
<seealso>
<link id="TCustomConnection.OnLogin"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: AfterConnect : TNotifyEvent -->
<element name="TCustomConnection.AfterConnect">
<short>Event triggered after a connection is made.</short>
<descr>
<var>AfterConnect</var> is called after a connection is succesfully established in <link id="TCustomConnection.Open"/>. It can be used to open
datasets, or indicate a connection status change.
</descr>
<seealso>
<link id="TCustomConnection.Open"/>
<link id="TCustomConnection.BeforeConnect"/>
<link id="TCustomConnection.OnLogin"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: AfterDisconnect : TNotifyEvent -->
<element name="TCustomConnection.AfterDisconnect">
<short>Event triggered after a connection is closed</short>
<descr>
<var>AfterDisConnect</var> is called after a connection is succesfully closed in <link id="TCustomConnection.Close"/>.
It can be used for instance to indicate a connection status change.
</descr>
<seealso>
<link id="TCustomConnection.Close"/>
<link id="TCustomConnection.BeforeDisconnect"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: BeforeConnect : TNotifyEvent -->
<element name="TCustomConnection.BeforeConnect">
<short>Event triggered before a connection is made.</short>
<descr>
<var>BeforeConnect</var> is called before a connection is attempted in <link id="TCustomConnection.Open"/>. It can be used to set connection parameters, or to abort the
establishing of the connection: if an exception is raised during this event, the connection attempt is aborted.
</descr>
<seealso>
<link id="TCustomConnection.Open"/>
<link id="TCustomConnection.AfterConnect"/>
<link id="TCustomConnection.OnLogin"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: BeforeDisconnect : TNotifyEvent -->
<element name="TCustomConnection.BeforeDisconnect">
<short>Event triggered before a connection is closed</short>
<descr>
<var>BeforeDisConnect</var> is called before a connection is closed in <link id="TCustomConnection.Close"/>.
It can be used for instance to check for unsaved changes, to save thise changes, or to abort the disconnect
operation: if an exception is raised during the event handler, the disconnect operation is aborted entirely.
</descr>
<seealso>
<link id="TCustomConnection.Close"/>
<link id="TCustomConnection.AfterDisconnect"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: OnLogin : TLoginEvent -->
<element name="TCustomConnection.OnLogin">
<short>Event triggered when a login prompt is shown.</short>
<descr>
<var>OnLogin</var> is triggered when the connection needs a login prompt during the  call: 
it is triggered when the <link id="TCustomConnection.LoginPrompt">LoginPrompt</link> property is <var>True</var>, after the 
<link id="TCustomConnection.BeforeConnect"/> event, but before the connection is actually established.
</descr>
<seealso>
<link id="TCustomConnection.BeforeConnect"/>
<link id="TCustomConnection.LoginPrompt"/>
<link id="TCustomConnection.Open"/>
</seealso>
</element>

<!-- "class of" type Visibility: default
     Declaration: TDatabaseClass = Class of TDataBase -->
<element name="TDatabaseClass">
<short>Class pointer for <var>TDatabase</var>.</short>
<descr>
<var>TDatabaseClass</var> is the class pointer for the <link id="TDatabase"/> class.
</descr>
<seealso>
<link id="TDatabase"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TComponent);  Override -->
<element name="TDatabase.Create">
<short>Initialize a new <var>TDatabase</var> class instance.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TDatabase</var> class. It allocates some resources
and then calls the inherited constructor.
</descr>
<seealso>
<link id="TDBDataset"/>
<link id="TDBTransaction"/>
<link id="TDatabase.Destroy"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TComponent -->
<element name="TDatabase.Create.AOwner">
<short>Owner for the new <var>TDatabase</var> instance.</short>
</element>

<!-- destructor Visibility: public
     Declaration: destructor Destroy;  Override -->
<element name="TDatabase.Destroy">
<short>Remove a <var>TDatabase</var> instance from memory.</short>
<descr>
<var>Destroy</var> starts by disconnecting the database (thus closing all datasets and ending all transactions), 
then notifies all connected datasets and transactions that it is about to be released.
After this, it releases all resources used by the <var>TDatabase</var> instance
</descr>
<seealso>
<link id="TDatabase.CloseDatasets"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CloseDataSets -->
<element name="TDatabase.CloseDataSets">
<short>Close all connected datasets</short>
<descr>
<var>CloseDatasets</var> closes all connected datasets. It is called automatically when the connection is closed.
</descr>
<seealso>
<link id="TCustomConnection.Close"/>
<link id="TDatabase.CloseTransactions"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CloseTransactions -->
<element name="TDatabase.CloseTransactions">
<short>End all transactions</short>
<descr>
<var>CloseTransaction</var> calls <link id="TDBTransaction.EndTransaction"/> on all connected transactions. 
It is called automatically when the connection is closed, after all datasets are closed.
</descr>
<seealso>
<link id="TCustomConnection.Close"/>
<link id="TDatabase.CloseDatasets"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure StartTransaction;  Virtual;  Abstract -->
<element name="TDatabase.StartTransaction">
<short>Start a new transaction.</short>
<descr>
<var>StartTransaction</var> must be implemented by descendent classes to start a new transaction.
This method is provided for Delphi compatibility: new applications shoud use a <link id="TDBTransaction"/> 
component instead and invoke the <link id="TDBTransaction.StartTransaction"/> method.
</descr>
<seealso>
<link id="TDBTransaction"/>
<link id="TDBTransaction.StartTransaction"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure EndTransaction;  Virtual;  Abstract -->
<element name="TDatabase.EndTransaction">
<short>End an active transaction.</short>
<descr>
<var>EndTransaction</var> must be implemented by descendent classes to end an active transaction.
This method is provided for Delphi compatibility: new applications shoud use a <link id="TDBTransaction"/> 
component instead and invoke the <link id="TDBTransaction.EndTransaction"/> method.
</descr>
<seealso>
<link id="TDBTransaction"/>
<link id="TDBTransaction.EndTransaction"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: TransactionCount : LongInt -->
<element name="TDatabase.TransactionCount">
<short>Number of transaction components connected to this database.</short>
<descr>
<var>TransactionCount</var> is the number of transaction components which are connected to this database instance.
It is the upper bound for the <link id="TDatabase.Transactions"/> array property.
</descr>
<seealso>
<link id="TDatabase.Transactions"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Transactions[Index: LongInt]: TDBTransaction -->
<element name="TDatabase.Transactions">
<short>Indexed access to all transaction components connected to this database.</short>
<descr>
<var>Transactions</var> provides indexed access to the transaction components connected to this database. The 
<var>Index</var> is zero based: it runs from 0 to <var>TransactionCount-1</var>.
</descr>
<seealso>
<link id="TDatabase.TransactionCount"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: LongInt -->
<element name="TDatabase.Transactions.Index">
<short>Zero based array index</short>
</element>

<!-- property Visibility: public
     Declaration: Directory : String -->
<element name="TDatabase.Directory">
<short>Directory for the database</short>
<descr>
<var>Directory</var> is provided for Delphi compatibility: it indicates (for Paradox and dBase based databases)
the directory where the database files are located. It is not used in the Free Pascal implementation of <link id="TDatabase"/>.
</descr>
<seealso>
<link id="TDatabase.Params"/>
<link id="TDatabase.IsSQLBased"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: IsSQLBased : Boolean -->
<element name="TDatabase.IsSQLBased">
<short>Is the database SQL based.</short>
<descr>
<var>IsSQLbased</var> is a read-only property which indicates whether a property is SQL-Based, i.e. whether
the database engine accepts SQL commands.
</descr>
<seealso>
<link id="TDatabase.Params"/>
<link id="TDatabase.Directory"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Connected : Boolean -->
<element name="TDatabase.Connected" link="TCustomConnection.Connected">
<short>Is the datbase connected</short>
<descr>
<var>Connected</var> is simply promoted to published property from <link id="TCustomConnection.Connected"/>.
</descr>
<seealso>
<link id="TCustomConnection.Connected"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DatabaseName : String -->
<element name="TDatabase.DatabaseName">
<short>Database name or path</short>
<descr>
<var>DatabaseName</var> specifies the path of the database. For directory-based databases this will be the same
as the <link id="TDatabase.Directory">Directory</link> property. For other databases this will be the name of
a known pre-configured connection, or the location of the database file.
</descr>
<seealso>
<link id="TDatabase.Directory"/>
<link id="TDatabase.Params"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: KeepConnection : Boolean -->
<element name="TDatabase.KeepConnection">
<short>Should the connection be kept active</short>
<descr>
<var>KeepConnection</var> is provided for Delphi compatibility, and is not used in the Free Pascal implementation
of <var>TDatabase</var>.
</descr>
<seealso>
<link id="TDatabase.Params"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Params : TStrings -->
<element name="TDatabase.Params">
<short>Connection parameters</short>
<descr>
<var>Params</var> is a catch-all storage mechanism for database connection parameters. It is a list of strings in the form of <var>Name=Value</var> pairs.
Which name/value pairs are supported depends on the <var>TDatabase</var> descendent, but the <var>user_name</var> and <var>password</var> parameters 
are commonly used to store the login credentials for the database.
</descr>
<seealso>
<link id="TDatabase.Directory"/>
<link id="TDatabase.DatabaseName"/>
</seealso>
</element>

<!-- alias type Visibility: default
     Declaration: TBlobData = String -->
<element name="TBlobData">
<short>Alias type to store blob data</short>
<descr>
<var>TBlobData</var> should never be used directly in application code.
</descr>
<seealso>
<link id="TBlobField"/>
</seealso>
</element>

<!-- array type Visibility: default
     Declaration: TParamBinding = Array of Integer -->
<element name="TParamBinding">
<short>Auxiliary type, used when binding parameters.</short>
<descr>
<var>TParamBinding</var> is an axuiliary type  used when parsing and binding parameters in SQL statements.
It should never be used directly in application code.
</descr>
<seealso>
<link id="TParams"/>
<link id="TParam"/>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TParamType = (ptUnknown,ptInput,ptOutput,ptInputOutput,ptResult) -->
<element name="TParamType">
<short>Parameter type</short>
<descr>
<p>
<var>TParamType</var> indicates the kind of parameter represented by a <link id="TParam"/> instance.
it has one of the following values:
</p>
<dl>
<dt>ptUnknown</dt><dd><printshort id="TParamType.ptUnknown"/></dd>
<dt>ptInput</dt><dd><printshort id="TParamType.ptInput"/></dd>
<dt>ptOutput</dt><dd><printshort id="TParamType.ptOutput"/></dd>
<dt>ptInputOutput</dt><dd><printshort id="TParamType.ptInputOutput"/></dd>
<dt>ptResult</dt><dd><printshort id="TParamType.ptResult"/></dd>
</dl>
</descr>
<seealso>
<link id="TParam"/>
<link id="TParam.ParamType"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: ptUnknown -->
<element name="TParamType.ptUnknown">
<short>Unknown type</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ptInput -->
<element name="TParamType.ptInput">
<short>Input parameter</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ptOutput -->
<element name="TParamType.ptOutput">
<short>Output paramete, filled on result</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ptInputOutput -->
<element name="TParamType.ptInputOutput">
<short>Input/output parameter</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: ptResult -->
<element name="TParamType.ptResult">
<short>Result parameter</short>
</element>

<!-- set type Visibility: default
     Declaration: TParamTypes= Set of (ptUnknown,ptInput,ptOutput,ptInputOutput,ptResult) -->
<element name="TParamTypes">
<short>Set of <var>TParamType</var></short>
<descr>
<var>TParamTypes</var> is defined for completeness: a set of <link id="TParamType"/> values.
</descr>
<seealso>
<link id="TParam.ParamType"/>
<link id="TParamType"/>
</seealso>
</element>

<!-- enumeration type Visibility: default
     Declaration: TParamStyle = (psInterbase,psPostgreSQL,psSimulated) -->
<element name="TParamStyle">
<short>Style of parameter</short>
<descr>
<p>
<var>TParamStyle</var> denotes the style in which parameters are specified in a query. 
It is used in the <link id="TParams.ParseSQl"/> method, and can have the following values:
</p>
<dl>
<dt>psInterbase</dt><dd><printshort id="TParamStyle.psInterbase"/></dd>
<dt>psPostgreSQL</dt><dd><printshort id="TParamStyle.psPostGreSQL"/></dd>
<dt>psSimulated</dt><dd><printshort id="TParamStyle.psSimulated"/></dd>
</dl>
</descr>
<seealso>
<link id="TParams.ParseSQL"/>
</seealso>
</element>

<!-- enumeration value Visibility: default
     Declaration: psInterbase -->
<element name="TParamStyle.psInterbase">
<short>Parameters are specified by a ? character</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: psPostgreSQL -->
<element name="TParamStyle.psPostgreSQL">
<short>Parameters are specified by a $N character.</short>
</element>

<!-- enumeration value Visibility: default
     Declaration: psSimulated -->
<element name="TParamStyle.psSimulated">
<short>Parameters are specified by a $N character.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TParams
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TParams">
<short>A collection of parameter values for SQL-based datasets</short>
<descr>
<p>
<var>TParams</var> is a collection of <link id="TParam"/> values. It is used to specify parameter values for parametrized SQL statemens,
but is also used to specify parameter values for stored procedures. Its default property is an array of <link id="TParam"/> values. 
The class also offers a method to scan a SQL statement for parameter names and replace them with placeholders understood by the 
SQL engine: <link id="TParams.ParseSQL"/>.
</p>
<p>
<link id="TDataset"/> itself does not use <var>TParams</var>. The class is provided in the <file>DB</file> unit, so all <var>TDataset</var>
descendents that need some kind of parametrization make use of the same interface. The <link id="TMasterParamsDataLink"/> class can be used 
to establish a master-detail relationship between a parameter-aware <var>TDataset</var> instance and another dataset; it will automatically
refresh parameter values when the fields in the master dataset change. To this end, the <link id="TParams.CopyParamValuesFromDataset"/> method 
exists.
</p>
</descr>
<seealso>
<link id="TDataset"/>
<link id="TMasterParamsDataLink"/>
<link id="TParam"/>
<link id="TParams.ParseSQL"/>
<link id="TParams.CopyParamValuesFromDataset"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TParam
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TParam">
<short>Parameter description class</short>
<descr>
<var>TParam</var> is one item in a <link id="TParams"/> collection. It describes the name (<link id="TParam.Name"/>), type 
(<link id="TParam.Paramtype">ParamType</link>) and value (<link id="TParam.Value"/>) of a parameter in a parametrized query
or stored procedure. Under normal circumstances, it should never be necessary to create a <var>TParam</var> instance manually; 
the <link id="TDataset"/> descendent that owns the parameters should have created all necessary <var>TParam</var> instances.
</descr>
<seealso>
<link id="TParams"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ACollection: TCollection);  Override;  Overload -->
<element name="TParam.Create">
<short>Create a new parameter value</short>
<descr>
<var>Create</var> first calls the inherited create, and then initializes the parameter properties. The first form creates
a default parameter, the second form is a convenience function and initializes a parameter of a certain kind (<var>AParamType</var>), 
in which case the owning <var>TParams</var> collection must be specified in <var>AParams</var></descr>
<seealso>
<link id="TParams"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ACollection: TCollection -->
<element name="TParam.Create.ACollection">
<short>Collection this parameter is part of</short>
</element>

<!-- argument Visibility: default
     Declaration: AParams: TParams -->
<element name="TParam.Create.AParams">
<short><var>TParams</var> instance this parameter is part of</short>
</element>

<!-- argument Visibility: default
     Declaration: AParamType: TParamType -->
<element name="TParam.Create.AParamType">
<short>Parameter type for the new parameter instance</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Assign(Source: TPersistent);  Override -->
<element name="TParam.Assign">
<short>Assign one parameter instance to another</short>
<descr>
<var>Assign</var> copies the <var>Name</var>, <var>ParamType</var>, <var>Bound</var>, <var>Value</var>, <var>Size</var>
<var>Precision</var> and <var>NumericScale</var> properties from <var>ASource</var>  if it is of type <var>TParam</var>.
If <var>Source</var> is of type <link id="TField"/>, then it is passed to <link id="TParam.AssignField"/>. 
If <var>Source</var> is of type <var>TStrings</var>, then it is assigned to <link id="TParams.AsMemo"/>.
</descr>
<errors>
If <var>Source</var> is not of type <var>TParam</var>, <var>TField</var> or <var>TStrings</var>, an exception will be raised.
</errors>
<seealso>
<link id="TField"/>
<link id="TParam.Name"/>
<link id="TParam.Bound"/>
<link id="TParam.NumericScale"/>
<link id="TParam.ParamType"/>
<link id="TParam.value"/>
<link id="TParam.Size"/>
<link id="TParam.AssignField"/>
<link id="Tparam.AsMemo"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Source: TPersistent -->
<element name="TParam.Assign.Source">
<short>Source object to copy value from</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignField(Field: TField) -->
<element name="TParam.AssignField">
<short>Copy value from field instance</short>
<descr>
<var>AssignField</var> copies the <var>Field</var>, <link
id="TField.FieldName">FieldName</link> and <link
id="TField.Value">Value</link> to
the parameter instance. The parameter is bound after this operation.
If <var>Field</var> is <var>Nil</var> then the parameter name and value are cleared.
</descr>
<seealso>
<link id="TParam.assign"/>
<link id="TParam.AssignToField"/>
<link id="TParam.AssignFieldValue"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TParam.AssignField.Field">
<short>Field instance to copy field name and value from.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignToField(Field: TField) -->
<element name="TParam.AssignToField">
<short>Assign parameter value to field</short>
<descr>
<var>AssignToField</var> copies the parameter <link id="TParam.Value">value</link> to the <var>field</var> instance.
If <var>Field</var> is <var>Nil</var>, nothing happens.
</descr>
<errors>
An <link id="EDatabaseError"/> exception is raised if the field has an unsupported field type 
(for types ftCursor, ftArray, ftDataset,ftReference).
</errors>
<seealso>
<link id="TParam.Assign"/>
<link id="TParam.AssignField"/>
<link id="TParam.AssignFromField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TParam.AssignToField.Field">
<short>Field instance to assign value to.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignFieldValue(Field: TField;const AValue: Variant) -->
<element name="TParam.AssignFieldValue">
<short>Assign field value to the parameter.</short>
<descr>
<var>AssignFieldValue</var> copies only the field type from <var>Field</var> and the value from the <var>AValue</var> parameter.
It sets the <link id="TParam.Bound"/> bound parameter to <var>True</var>. This method is called from <link id="TParam.AssignField"/>.
</descr>
<seealso>
<link id="TField"/>
<link id="TParam.AssignField"/>
<link id="TParam.Bound"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TParam.AssignFieldValue.Field">
<short>Field to copy parameter type from.</short>
</element>

<!-- argument Visibility: default
     Declaration: AValue: Variant -->
<element name="TParam.AssignFieldValue.AValue">
<short>Value to assign to parameter.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignFromField(Field: TField) -->
<element name="TParam.AssignFromField">
<short>Copy field type and value</short>
<descr>
<var>AssignFromField</var> copies the field <link id="TField.Value">value</link>  and data type (<link id="TField.DataType"/>)
to the parameter instance. If <var>Field</var> is <var>Nil</var>, nothing happens.
This is the reverse operation of <link id="TParam.AssignToField"/>.
</descr>
<errors>
An <link id="EDatabaseError"/> exception is raised if the field has an unsupported field type 
(for types ftCursor, ftArray, ftDataset,ftReference).
</errors>
<seealso>
<link id="TParam.Assign"/>
<link id="TParam.AssignField"/>
<link id="TParam.AssignToField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Field: TField -->
<element name="TParam.AssignFromField.Field">
<short>Field to copy type and value from.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure Clear -->
<element name="TParam.Clear">
<short>Clear the parameter value</short>
<descr>
<var>Clear</var> clears the parameter value, it is set to <var>UnAssigned</var>. The Datatype, parameter type or name are not touched.
</descr>
<seealso>
<link id="TParam.Value"/>
<link id="TParam.Name"/>
<link id="TParam.ParamType"/>
<link id="TParam.DataType"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetData(Buffer: Pointer) -->
<element name="TParam.GetData">
<short>Get the parameter value from a memory buffer</short>
<descr>
<var>GetData</var> retrieves the parameter value and stores it in <var>buffer</var>
It uses the same data layout as <link id="TField"/>, and can be used to copy the parameter value to a record buffer.
</descr>
<errors>
Only basic field types are supported. Using an unsupported field type will result in an <link id="EdatabaseError"/> exception.
</errors>
<seealso>
<link id="TParam.SetData"/>
<link id="TField"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TParam.GetData.Buffer">
<short>Buffer to copy parameter value to.</short>
</element>

<!-- function Visibility: public
     Declaration: function GetDataSize : Integer -->
<element name="TParam.GetDataSize">
<short>Return the size of the data.</short>
<descr>
<var>GetDataSize</var> returns the size (in bytes) needed to store the current value of the parameter.
</descr>
<errors>
For an unsupported data type, an <link id="EDatabaseError"/> exception is raised when this function is called.
</errors>
<seealso>
<link id="TParam.GetData"/>
<link id="TParam.SetData"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParam.GetDataSize.Result">
<short>Size (in bytes) for the current value</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure LoadFromFile(const FileName: String;BlobType: TBlobType) -->
<element name="TParam.LoadFromFile">
<short>Load a parameter value from file</short>
<descr>
<var>LoadFromFile</var> can be used to load a BLOB-type parameter from a file named <var>FileName</var>. 
The <var>BlobType</var> parameter can be used to set the exact data type of the parameter: it must be one of the BLOB data types.
This function simply creates a <var>TFileStream</var> instance and passes it to <link id="TParam.LoadFromStream"/>.
</descr>
<errors>
If the specified <var>FileName</var> is not a valid file, or the file is not readable, an exception will occur.
</errors>
<seealso>
<link id="TParam.LoadFromStream"/>
<link id="TBlobType"/>
<link id="TParam.SaveToFile"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: FileName: String -->
<element name="TParam.LoadFromFile.FileName">
<short>Name of existing file to load blob data from.</short>
</element>

<!-- argument Visibility: default
     Declaration: BlobType: TBlobType -->
<element name="TParam.LoadFromFile.BlobType">
<short>New value for <var>DataType</var></short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure LoadFromStream(Stream: TStream;BlobType: TBlobType) -->
<element name="TParam.LoadFromStream">
<short>Load a parameter value from stream</short>
<descr>
<var>LoadFromStream</var> can be used to load a BLOB-type parameter from a stream.
The <var>BlobType</var> parameter can be used to set the exact data type of the parameter: it must be one of the BLOB data types.
</descr>
<errors>
If the stream does not support taking the <var>Size</var> of the stream, an exception will be raised.
</errors>
<seealso>
<link id="TParam.LoadFromFile"/>
<link id="TParam.SaveToStream"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Stream: TStream -->
<element name="TParam.LoadFromStream.Stream">
<short>Stream to load BLOB data from.</short>
</element>

<!-- argument Visibility: default
     Declaration: BlobType: TBlobType -->
<element name="TParam.LoadFromStream.BlobType">
<short>Data type for the parameter</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetBlobData(Buffer: Pointer;ASize: Integer) -->
<element name="TParam.SetBlobData">
<short>Set BLOB data</short>
<descr>
<var>SetBlobData</var> reads the value of a BLOB type parameter from a memory buffer:
 the data is read from the memory buffer <var>Buffer</var> and is assumed to be <var>Size</var> bytes long.
</descr>
<errors>
No checking is performed on the validity of the data buffer. If the data buffer is invalid or the size is wrong, an exception may occur.
</errors>
<seealso>
<link id="TParam.LoadFromStream"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TParam.SetBlobData.Buffer">
<short>Memory buffer to load data from</short>
</element>

<!-- argument Visibility: default
     Declaration: ASize: Integer -->
<element name="TParam.SetBlobData.ASize">
<short>Size of memory buffer to load data from</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure SetData(Buffer: Pointer) -->
<element name="TParam.SetData">
<short>Set the parameter value from a buffer</short>
<descr>
<var>SetData</var> performs the rever operation of <link id="TParam.GetData"/>: it reads the parameter value from the memory
area pointed to by <var>Buffer</var>. The size of the data read is determined by <link id="TParam.GetDataSize"/> and the 
type of data by <link id="TParam.DataType"/> : it is the same storage mechanism used by <link id="TField"/>, and so can be used to copy
the value from a <link id="TDataset"/> record buffer.
</descr>
<errors>
Not all field types are supported. If an unsupported field type is encountered, an <link id="EDatabaseError"/> exception is raised.
</errors>
<seealso>
<link id="TDataset"/>
<link id="TParam.GetData"/>
<link id="TParam.DataType"/>
<link id="TParam.GetDataSize"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer: Pointer -->
<element name="TParam.SetData.Buffer">
<short>Buffer to read data from</short>
</element>

<!-- property Visibility: public
     Declaration: AsBlob : TBlobData -->
<element name="TParam.AsBlob">
<short>Return parameter value as a blob</short>
<descr>
<var>AsBlob</var> returns the parameter value as a blob: currently this is a string. It can be set to set the parameter value.
</descr>
<seealso>
<link id="TParam.AsString"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsBoolean : Boolean -->
<element name="TParam.AsBoolean">
<short>Get/Set parameter value as a boolean value</short>
<descr>
<var>AsBoolean</var> will return the parameter value as a boolean value. If it is written, the value is set to the specified value
and the data type is set to <var>ftBoolean</var>.
</descr>
<seealso>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsCurrency : Currency -->
<element name="TParam.AsCurrency">
<short>Get/Set parameter value as a currency value</short>
<descr>
<var>AsCurrency</var> will return the parameter value as a currency value. If it is written, the value is set to the specified value
and the data type is set to <var>ftCurrency</var>.
</descr>
<seealso>
<link id="TParam.AsFloat"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsDate : TDateTime -->
<element name="TParam.AsDate">
<short>Get/Set parameter value as a date (TDateTime) value</short>
<descr>
<var>AsDate</var> will return the parameter value as a date value. If it is written, the value is set to the specified value
and the data type is set to <var>ftDate</var>.
</descr>
<seealso>
<link id="TParam.AsDateTime"/>
<link id="TParam.AsTime"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsDateTime : TDateTime -->
<element name="TParam.AsDateTime">
<short>Get/Set parameter value as a date/time (TDateTime) value</short>
<descr>
<var>AsDateTime</var> will return the parameter value as a TDateTime value. If it is written, the value is set to the specified value
and the data type is set to <var>ftDateTime</var>.
</descr>
<seealso>
<link id="TParam.AsDate"/>
<link id="TParam.asTime"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsFloat : Double -->
<element name="TParam.AsFloat">
<short>Get/Set parameter value as a floating-point value</short>
<descr>
<var>AsFLoat</var> will return the parameter value as a double floating-point value. If it is written, the value is set to the specified value
and the data type is set to <var>ftFloat</var>.
</descr>
<seealso>
<link id="TParam.AsCurrency"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsInteger : LongInt -->
<element name="TParam.AsInteger">
<short>Get/Set parameter value as an integer (32-bit) value</short>
<descr>
<var>AsInteger</var> will return the parameter value as a 32-bit signed integer value. If it is written, the value is set to the specified value
and the data type is set to <var>ftInteger</var>.
</descr>
<seealso>
<link id="TParam.AsLargeInt"/>
<link id="TParam.AsSmallInt"/>
<link id="TParam.AsWord"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsLargeInt : LargeInt -->
<element name="TParam.AsLargeInt">
<short>Get/Set parameter value as a 64-bit integer value</short>
<descr>
<var>AsLargeInt</var> will return the parameter value as a 64-bit signed integer value. If it is written, the value is set to the specified value
and the data type is set to <var>ftLargeInt</var>.
</descr>
<seealso>
<link id="TParam.asInteger"/>
<link id="TParam.asSmallint"/>
<link id="TParam.AsWord"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsMemo : String -->
<element name="TParam.AsMemo">
<short>Get/Set parameter value as a memo (string) value</short>
<descr>
<var>AsMemo</var> will return the parameter value as a memo (string) value. If it is written, the value is set to the specified value
and the data type is set to <var>ftMemo</var>.
</descr>
<seealso>
<link id="TParam.asString"/>
<link id="TParam.LoadFromStream"/>
<link id="TParam.SaveToStream"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsSmallInt : LongInt -->
<element name="TParam.AsSmallInt">
<short>Get/Set parameter value as a smallint value</short>
<descr>
<var>AsSmallint</var> will return the parameter value as a 16-bit signed integer value. If it is written, the value is set to the specified value
and the data type is set to <var>ftSmallint</var>.
</descr>
<seealso>
<link id="TParam.AsInteger"/>
<link id="TParam.AsLargeInt"/>
<link id="TParam.AsWord"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsString : String -->
<element name="TParam.AsString">
<short>Get/Set parameter value as a string value</short>
<descr>
<var>AsString</var> will return the parameter value as a string value. If it is written, the value is set to the specified value
and the data type is set to <var>ftString</var>.
</descr>
<seealso>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsTime : TDateTime -->
<element name="TParam.AsTime">
<short>Get/Set parameter value as a time (TDateTime) value</short>
<descr>
<var>AsTime</var> will return the parameter value as a time (TDateTime) value. If it is written, the value is set to the specified value
and the data type is set to <var>ftTime</var>.
</descr>
<seealso>
<link id="TParam.AsDate"/>
<link id="TParam.AsDateTime"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsWord : LongInt -->
<element name="TParam.AsWord">
<short>Get/Set parameter value as a word value</short>
<descr>
<var>AsWord</var> will return the parameter value as an integer. If it is written, the value is set to the specified value
and the data type is set to <var>ftWord</var>.
</descr>
<seealso>
<link id="TParam.AsInteger"/>
<link id="TParam.AsLargeInt"/>
<link id="TParam.AsSmallint"/>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Bound : Boolean -->
<element name="TParam.Bound">
<short>Is the parameter value bound (set to fixed value)</short>
<descr>
<var>Bound</var> indicates whether a parameter has received a fixed value: setting the parameter value will set <var>Bound</var> to <var>True</var>.
When creating master-detail relationships, parameters with their <var>Bound</var> property set to <var>True</var> will not receive a value from the 
master dataset: their value will be kept. Only parameters where <var>Bound</var> is <var>False</var> will receive a new value from the master dataset.
</descr>
<seealso>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Dataset : TDataSet -->
<element name="TParam.Dataset">
<short>Dataset to which this parameter belongs</short>
<descr>
<var>Dataset</var> is the dataset that owns the <link id="TParams"/> instance of which this <var>TParam</var> instance is a part.
It is <var>Nil</var> if the collection is not set, or is not a <var>TParams</var> instance.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TParams"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: IsNull : Boolean -->
<element name="TParam.IsNull">
<short>Is the parameter empty</short>
<descr>
<var>IsNull</var> is <var>True</var> is the value is empty or not set (Null or UnAssigned).
</descr>
<seealso>
<link id="TParam.Clear"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: NativeStr : String -->
<element name="TParam.NativeStr">
<short>No description available</short>
<descr>
No description available
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Text : String -->
<element name="TParam.Text">
<short>Read or write the value of the parameter as a string</short>
<descr>
<var>AsText</var> returns the same value as <link id="TParam.AsString"/>, but, when written, does not set the data type: instead, it
attempts to convert the value to the type specified in <link id="TParam.Datatype"/>.
</descr>
<seealso>
<link id="TParam.AsString"/>
<link id="TParam.DataType"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Value : Variant -->
<element name="TParam.Value">
<short>Value as a variant</short>
<descr>
<var>Value</var> returns (or sets) the value as a variant value.
</descr>
<seealso>
<link id="TParam.DataType"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: AsWideString : WideString -->
<element name="TParam.AsWideString">
<short>Get/Set the value as a widestring</short>
<descr>
<var>AsWideString</var> returns the parameter value as a widestring value. Setting the property will set the value of the parameter 
and will also set the <link id="TParam.DataType">DataType</link> to <var>ftWideString</var>.
</descr>
<seealso>
<link id="TParam.AsString"/>
<link id="TParam.Value"/>
<link id="TParam.DataType"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: DataType : TFieldType -->
<element name="TParam.DataType">
<short>Data type of the parameter</short>
<descr>
<var>DataType</var> is the current data type of the parameter value. It is set automatically when one of the various <var>AsXYZ</var> 
properties is written, or when the value is copied from a field value.
</descr>
<seealso>
<link id="TParam.IsNull"/>
<link id="TParam.Value"/>
<link id="TParam.AssignField"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Name : String -->
<element name="TParam.Name">
<short>Name of the parameter</short>
<descr>
<var>Name</var> is the name of the parameter. The name is usually determined automatically from the SQL statement the parameter is
part of. Each parameter name should appear only once in the collection.
</descr>
<seealso>
<link id="TParam.DataType"/>
<link id="TParam.Value"/>
<link id="TParams.ParamByName"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: NumericScale : Integer -->
<element name="TParam.NumericScale">
<short>Numeric scale</short>
<descr>
<var>NumericScale</var> can be used to store the numerical scale for BCD values. It is currently unused.
</descr>
<seealso>
<link id="TParam.Precision"/>
<link id="TParam.Size"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: ParamType : TParamType -->
<element name="TParam.ParamType">
<short>Type of parameter</short>
<descr>
<p>
<var>ParamTyp</var> specifies the type of parameter: is the parameter value written to the database engine, 
or is it received from the database engine, or both ? It can have the following value:
</p>
<dl>
<dt>ptUnknown</dt><dd><printshort id="TParamType.ptUnknown"/></dd>
<dt>ptInput</dt><dd><printshort id="TParamType.ptInput"/></dd>
<dt>ptOutput</dt><dd><printshort id="TParamType.ptOutput"/></dd>
<dt>ptInputOutput</dt><dd><printshort id="TParamType.ptInputOutput"/></dd>
<dt>ptResult</dt><dd><printshort id="TParamType.ptResult"/></dd>
</dl>
<p>
The <var>ParamType</var> property is usually set by the database engine that creates the parameter instances.
</p>
</descr>
<seealso>
<link id="TParam.DataType"/>
<link id="TParam.DataSize"/>
<link id="TParam.Name"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Precision : Integer -->
<element name="TParam.Precision">
<short>Precision of the BCD value</short>
<descr>
<var>Precision</var> can be used to store the numerical precision for BCD values. It is currently unused.
</descr>
<seealso>
<link id="TParam.NumericScale"/>
<link id="TParam.Size"/>
</seealso>
</element>

<!-- property Visibility: published
     Declaration: Size : Integer -->
<element name="TParam.Size">
<short>Size of the parameter</short>
<descr>
<var>Size</var> is the declared size of the parameter. In the current implementation, this parameter is ignored other
than copying it from <link id="TField.DataSize"/> in the <link id="TParam.AssignFieldValue"/> method.
The actual size can be retrieved through the <link id="TParam.Datasize"/> property.
</descr>
<seealso>
<link id="TParam.Datasize"/>
<link id="TField.DataSize"/>
<link id="TParam.AssignFieldValue"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(AOwner: TPersistent);  Overload -->
<element name="TParams.Create">
<short>Create a new instance of <var>TParams</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TParams</var>. It calls the inherited constructor with <link id="TParam"/> as the 
collection's item class, and sets <var>AOwner</var>  as the owner of the collection. Usually, <var>AOwner</var> will be the dataset that
needs parameters.
</descr>
<seealso>
<link id="#rtl.classes.TCollection.create"/>
<link id="TParam"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: AOwner: TPersistent -->
<element name="TParams.Create.AOwner">
<short>Owner of the collection.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AddParam(Value: TParam) -->
<element name="TParams.AddParam">
<short>Add a parameter to the collection</short>
<descr>
<var>AddParam</var> adds <var>Value</var> to the collection. 
</descr>
<errors>
No checks are done on the <var>TParam</var> instance. If it is <var>Nil</var>, an exception will be raised.
</errors>
<seealso>
<link id="TParam"/>
<link id="#rtl.classes.tcollection.add"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: TParam -->
<element name="TParams.AddParam.Value">
<short><var>TParam</var> instance to add to the collection.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure AssignValues(Value: TParams) -->
<element name="TParams.AssignValues">
<short>Copy values from another collection</short>
<descr>
<var>AssignValues</var> examines all <link id="TParam"/> instances in <var>Value</var>, and looks in its own items
for a <var>TParam</var> instance with the same name. If it is found, then the value and type of the parameter are
 copied (using <link id="TParam.Assign"/>). If it is not found, nothing is done.
</descr>
<seealso>
<link id="TParam"/>
<link id="TParam.Assign"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: TParams -->
<element name="TParams.AssignValues.Value">
<short>Set of parameters to copy values from.</short>
</element>

<!-- function Visibility: public
     Declaration: function CreateParam(FldType: TFieldType;const ParamName: String;
                    ParamType: TParamType) : TParam -->
<element name="TParams.CreateParam">
<short>Create and add a new parameter to the collection</short>
<descr>
<var>CreateParam</var> creates a new <link id="TParam"/> instance with datatype equal to <var>fldType</var>, <var>Name</var>
equal to <var>ParamName</var> and sets its <var>ParamType</var> property to <var>ParamType</var>. 
The parameter is then added to the collection.
</descr>
<seealso>
<link id="TParam"/>
<link id="TParam.Name"/>
<link id="TParam.Datatype"/>
<link id="TParam.Paramtype"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParams.CreateParam.Result">
<short>Newly added <var>TParam</var> instance.</short>
</element>

<!-- argument Visibility: default
     Declaration: FldType: TFieldType -->
<element name="TParams.CreateParam.FldType">
<short>Value for the <var>DataType</var> property of the new instance.</short>
</element>

<!-- argument Visibility: default
     Declaration: ParamName: String -->
<element name="TParams.CreateParam.ParamName">
<short>Value for the <var>Name</var> property of the new instance.</short>
</element>

<!-- argument Visibility: default
     Declaration: ParamType: TParamType -->
<element name="TParams.CreateParam.ParamType">
<short>Value for the <var>ParamType</var> property of the new instance.</short>
</element>

<!-- function Visibility: public
     Declaration: function FindParam(const Value: String) : TParam -->
<element name="TParams.FindParam">
<short>Find a parameter with given name</short>
<descr>
<p>
<var>FindParam</var> searches the collection for the <link id="TParam"/> instance with property <var>Name</var> equal to <var>Value</var>.
It will return the last instance with the given name, and will only return one instance. If no match is found, <var>Nil</var> is returned.
</p>
<remark>
A <var>TParams</var> collection can have 2 <var>TParam</var> instances with the same name: no checking for duplicates is done.
</remark>
</descr>
<seealso>
<link id="TParam.Name"/>
<link id="TParams.ParamByName"/>
<link id="TParams.GetParamList"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParams.FindParam.Result">
<short><var>TParam</var> instance with <var>Name</var> equal to <var>Value</var> or <var>Nil</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="TParams.FindParam.Value">
<short>Parameter name to search for.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure GetParamList(List: TList;const ParamNames: String) -->
<element name="TParams.GetParamList">
<short>Fetch a list of <var>TParam</var> instances</short>
<descr>
<var>GetParamList</var> examines the parameter names in the semicolon-separated list <var>ParamNames</var>. 
It searches each <var>TParam</var> instance from the names in the list and adds it to <var>List</var>.
</descr>
<errors>
If the <var>ParamNames</var> list contains an unknown parameter name, then an exception is raised. 
Whitespace is not discarded.
</errors>
<seealso>
<link id="TParam"/>
<link id="TParam.Name"/>
<link id="TParams.ParamByName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: List: TList -->
<element name="TParams.GetParamList.List">
<short>List to add <var>TParam</var> instances to.</short>
</element>

<!-- argument Visibility: default
     Declaration: ParamNames: String -->
<element name="TParams.GetParamList.ParamNames">
<short>Semicolon-separated list of parameter names.</short>
</element>

<!-- function Visibility: public
     Declaration: function IsEqual(Value: TParams) : Boolean -->
<element name="TParams.IsEqual">
<short>Is the list of parameters equal</short>
<descr>
<var>IsEqual</var> compares the parameter count of <var>Value</var> and if it matches, it compares all <var>TParam</var> items
of <var>Value</var> with the items it owns. If all items are equal (all properties match), then <var>True</var> is returned.
The items are compared on index, so the order is important.
</descr>
<seealso>
<link id="TParam"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParams.IsEqual.Result">
<short><var>True</var> if all items in <var>Value</var> match the own items</short>
</element>

<!-- argument Visibility: default
     Declaration: Value: TParams -->
<element name="TParams.IsEqual.Value">
<short>Collection of <var>TParam</var> values.</short>
</element>

<!-- function Visibility: public
     Declaration: function ParamByName(const Value: String) : TParam -->
<element name="TParams.ParamByName">
<short>Return a parameter by name</short>
<descr>
<p>
<var>ParamByName</var> searches the collection for the <link id="TParam"/> instance with property <var>Name</var> equal to <var>Value</var>.
It will return the last instance with the given name, and will only return one instance. If no match is found, an exception is raised.
</p>
<remark>
A <var>TParams</var> collection can have 2 <var>TParam</var> instances with the same name: no checking for duplicates is done.
</remark>
</descr>
<seealso>
<link id="TParam.Name"/>
<link id="TParams.FindParam"/>
<link id="TParams.GetParamList"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParams.ParamByName.Result">
<short><var>TParam</var> instance with <var>Name</var> equal to <var>Value</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: Value: String -->
<element name="TParams.ParamByName.Value">
<short><var>Name</var> to search for.</short>
</element>

<!-- function Visibility: public
     Declaration: function ParseSQL(SQL: String;DoCreate: Boolean) : String;  Overload -->
<element name="TParams.ParseSQL">
<short>Parse SQL statement, replacing parameter names with SQL parameter placeholders</short>
<descr>
<p>
<var>ParseSQl</var> parses the <var>SQL</var> statement for parameter names in the form <var>:ParamName</var>. It replaces them with a
SQL parameter placeholder. If <var>DoCreate</var> is <var>True</var> then a <var>TParam</var> instance is added to the collection with
the found parameter name.
</p>
<p>
The parameter placeholder is determined by the <var>ParameterStyle</var> property, which can have the following values:
</p>
<dl>
<dt>psInterbase</dt><dd><printshort id="TParamStyle.psInterbase"/></dd>
<dt>psPostgreSQL</dt><dd><printshort id="TParamStyle.psPostGreSQL"/></dd>
<dt>psSimulated</dt><dd><printshort id="TParamStyle.psSimulated"/></dd>
</dl>
<p>
<var>psInterbase</var> is the default.
</p>
<p>If the <var>EscapeSlash</var> parameter is <var>True</var>, then backslash characters are used to quote the next character in the SQL statement. 
If it is <var>False</var>, the backslash character is regarded as a normal character.
</p>
<p>
If the <var>EscapeRepeat</var> parameter is <var>True</var> (the default) then embedded quotes in string literals
are escaped by repeating themselves. If it is <var>false</var> then they should be quoted with backslashes.
</p>
<p>
<var>ParamBinding</var>, if specified, is filled with the indexes of the parameter instances in the parameter collection: for each SQL parameter placeholder,
the index of the corresponding <var>TParam</var> instance is returned in the array. 
</p>
<p>
<var>ReplaceString</var>, if specified, contains the placeholder used for the parameter names (by default, $). It has effect only when
<var>ParameterStyle</var> equals <var>psSimulated</var>.
</p>
<p>
The function returns the SQL statement with the parameter names replaced by placeholders.
</p>
</descr>
<seealso>
<link id="TParam"/>
<link id="TParam.Name"/>
<link id="TParamStyle"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="TParams.ParseSQL.Result">
<short>SQL statement with parameter names replaced with placeholders</short>
</element>

<!-- argument Visibility: default
     Declaration: SQL: String -->
<element name="TParams.ParseSQL.SQL">
<short>SQL statement to scan for parameter names</short>
</element>

<!-- argument Visibility: default
     Declaration: DoCreate: Boolean -->
<element name="TParams.ParseSQL.DoCreate">
<short>Set to <var>True</var> if <var>TParam</var> instances must be created for the found parameters.</short>
</element>

<!-- argument Visibility: default
     Declaration: EscapeSlash: Boolean -->
<element name="TParams.ParseSQL.EscapeSlash">
<short><var>True</var> if the backslash character acts as an escape token.</short>
</element>

<!-- argument Visibility: default
     Declaration: EscapeRepeat: Boolean -->
<element name="TParams.ParseSQL.EscapeRepeat">
<short><var>True</var> if quotes are escaped by specifying them two times.</short>
</element>

<!-- argument Visibility: default
     Declaration: ParameterStyle: TParamStyle -->
<element name="TParams.ParseSQL.ParameterStyle">
<short>SQL Placeholder style</short>
</element>

<!-- argument Visibility: default
     Declaration: ParamBinding: TParamBinding -->
<element name="TParams.ParseSQL.ParamBinding">
<short>On return, filled with indexes of <var>TParam</var> instances corresponding to the placeholders</short>
</element>

<!-- argument Visibility: default
     Declaration: ReplaceString: String -->
<element name="TParams.ParseSQL.ReplaceString">
<short>Placeholder string.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure RemoveParam(Value: TParam) -->
<element name="TParams.RemoveParam">
<short>Remove a parameter from the collection</short>
<descr>
<var>RemoveParam</var> removes the parameter <var>Value</var> from the collection, but does not free the instance.
</descr>
<errors>
<var>Value</var> must be a valid instance, or an exception will be raised.
</errors>
<seealso>
<link id="TParam"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Value: TParam -->
<element name="TParams.RemoveParam.Value">
<short>Parameter to remove from the collection.</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CopyParamValuesFromDataset(ADataset: TDataSet;
                                    CopyBound: Boolean) -->
<element name="TParams.CopyParamValuesFromDataset">
<short>Copy parameter values from the fields in a dataset.</short>
<descr>
<var>CopyParamValuesFromDataset</var> assigns values to all parameters in the collection 
by searching in <var>ADataset</var> for fields with the same name, and assigning the value 
of the field to the <var>Tparam</var> instances using <link id="TParam.AssignField"/>.
By default, this operation is only performed on <var>TParam</var> instances with their 
<link id="TParam.Bound">Bound</link> property set to <var>False</var>. If <var>CopyBound</var> is true,
then the operation is performed on all <var>TParam</var> instances in the collection.
</descr>
<errors>
If, for some <var>TParam</var> instance, <var>ADataset</var> misses a field with the same name,
an <var>EDatabaseError</var> exception will be raised.
</errors>
<seealso>
<link id="TParam"/>
<link id="TParam.Bound"/>
<link id="TParam.AssignField"/>
<link id="TDataset"/>
<link id="TDataset.FieldByName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataset: TDataSet -->
<element name="TParams.CopyParamValuesFromDataset.ADataset">
<short>Dataset to copy values from</short>
</element>

<!-- argument Visibility: default
     Declaration: CopyBound: Boolean -->
<element name="TParams.CopyParamValuesFromDataset.CopyBound">
<short>Copy value also for bound parameters ?</short>
</element>

<!-- property Visibility: public
     Declaration: Dataset : TDataSet -->
<element name="TParams.Dataset">
<short>Dataset that owns the <var>TParams</var> instance</short>
<descr>
<var>Dataset</var> is the <link id="TDataset"/> instance that was specified when the <var>TParams</var> instance was created.
</descr>
<seealso>
<link id="TParams.Create"/>
<link id="TDataset"/>
</seealso>
</element>

<!-- property Visibility: public
     Declaration: Items[Index: Integer]: TParam; default -->
<element name="TParams.Items">
<short>Indexed access to <var>TParams</var> instances in the collection</short>
<descr>
<var>Items</var> is overridden by <var>TParams</var> so it has the proper type (<var>TParam</var>). The <var>Index</var> runs from 0 to <var>Count-1</var>.
</descr>
<seealso>
<link id="TParams"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Index: Integer -->
<element name="TParams.Items.Index">
<short>Zero-based index to the array</short>
</element>

<!-- property Visibility: public
     Declaration: ParamValues[ParamName: String]: Variant -->
<element name="TParams.ParamValues">
<short>Named access to the parameter values.</short>
<descr>
<p>
<var>ParamValues</var> provides access to the parameter values (<link id="TParam.Value"/>) by name. It is equivalent to
reading and writing </p>
<code>
ParamByName(ParamName).Value
</code>
</descr>
<seealso>
<link id="TParam.Value"/>
<link id="TParams.ParamByName"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ParamName: String -->
<element name="TParams.ParamValues.ParamName">
<short>Parameter name to read/write</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TMasterParamsDataLink
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TMasterParamsDataLink">
<short>Class to establish a master-detail relationship between dataset, based on parameters</short>
<descr>
<var>TMasterParamsDataLink</var> is a <link id="TDataLink"/> descendent that can be used to establish 
a master-detail relationship between 2 <var>TDataset</var> instances where the detail dataset is 
parametrized using a <var>TParams</var> instance. It takes care of closing and opening the detail
dataset and copying the parameter values from the master dataset whenever the data in the master 
dataset changes.
</descr>
<seealso>
<link id="TDatalink"/>
<link id="TDataset"/>
<link id="TParams"/>
<link id="TParam"/>
</seealso>
</element>

<!-- constructor Visibility: public
     Declaration: constructor Create(ADataSet: TDataSet);  Override -->
<element name="TMasterParamsDataLink.Create">
<short>Initialize a new <var>TMasterParamsDataLink</var> instance</short>
<descr>
<var>Create</var> first calls the inherited constructor using <var>ADataset</var>, and then looks for
a property named <var>Params</var> of type <link id="TParams"/> in the published properties of 
<var>ADataset</var> and assigns it to the <link id="TMasterParamsDataLink.Params">Params</link> property.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TParams"/>
<link id="TMasterParamsDataLink.Params"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: ADataSet: TDataSet -->
<element name="TMasterParamsDataLink.Create.ADataSet">
<short>Detail dataset</short>
</element>

<!-- procedure Visibility: public
     Declaration: procedure RefreshParamNames;  Virtual -->
<element name="TMasterParamsDataLink.RefreshParamNames">
<short>Refresh the list of parameter names</short>
<descr>
<var>RefreshParamNames</var> scans the <link id="TMasterParamsDataLink.Params">Params</link> property and
sets the <link id="TMasterDataLink.FieldNames">FieldNames</link> property to the list of parameter names.
</descr>
<seealso>
<link id="TMasterParamsDataLink.Params"/>
<link id="TMasterDataLink.FieldNames"/>
</seealso>
</element>

<!-- procedure Visibility: public
     Declaration: procedure CopyParamsFromMaster(CopyBound: Boolean);  Virtual -->
<element name="TMasterParamsDataLink.CopyParamsFromMaster">
<short>Copy parameter values from master dataset.</short>
<descr>
<var>CopyParamsFromMaster</var> calls <link id="TParams.CopyParamValuesFromDataset"/>, 
passing it the master dataset: it provides the parameters of the detail dataset with 
their new values. If <var>CopyBound</var> is <var>false</var>, then only parameters 
with their <link id="TParam.Bound">Bound</link> property set to <var>False</var> are copied.
If it is <var>True</var> then the value is set for all parameters.
</descr>
<errors>
If the master dataset does not have a corresponding field for each parameter, then an exception will be raised.
</errors>
<seealso>
<link id="TParams.CopyParamValuesFromDataset"/>
<link id="TParam.Bound"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: CopyBound: Boolean -->
<element name="TMasterParamsDataLink.CopyParamsFromMaster.CopyBound">
<short>Should <var>Bound</var> parameters also get a new value ?</short>
</element>

<!-- property Visibility: public
     Declaration: Params : TParams -->
<element name="TMasterParamsDataLink.Params">
<short>Parameters of detail dataset.</short>
<descr>
<var>Params</var> is the <var>TParams</var> instance of the detail dataset. 
If the detail dataset contains a property named <var>Params</var> of type <var>TParams</var>, 
then it will be set when the <var>TMasterParamsDataLink</var> instance was created. 
If the property is not published, or has another name, then the <var>Params</var> property must be set in code.
</descr>
<seealso>
<link id="Tparams"/>
<link id="TMasterParamsDataLink.Create"/>
</seealso>
</element>

<!-- constant Visibility: default
     Declaration: FieldTypetoVariantMap : Array[TFieldType] of Integer = (varError,varOleStr,varSmallint,varInteger,varSmallint,varBoolean,varDouble,varCurrency,varCurrency,varDate,varDate,varDate,varOleStr,varOleStr,varInteger,varOleStr,varOleStr,varOleStr,varOleStr,varOleStr,varOleStr,varOleStr,varError,varOleStr,varOleStr,varError,varError,varError,varError,varError,varOleStr,varOleStr,varVariant,varUnknown,varDispatch,varOleStr,varOleStr,varOleStr,varOleStr,varOleStr ) -->
<element name="FieldTypetoVariantMap">
<short>Map field types on variant types</short>
<descr>
<var>FieldTypetoVariantMap</var> contains for each field datatype the variant value type that corresponds to it.
If a field type cannot be expressed by a variant type, then <var>varError</var> is stored in the variant value.
</descr>
<seealso>
<link id="TFieldType"/>
<link id="TField.Value"/>
<link id="TParam.Value"/>
</seealso>
</element>

<!-- constant Visibility: default
     Declaration: Fieldtypenames : Array[TFieldType] of String = ('Unknown','String','Smallint','Integer','Word','Boolean','Float','Currency','BCD','Date','Time','DateTime','Bytes','VarBytes','AutoInc','Blob','Memo','Graphic','FmtMemo','ParadoxOle','DBaseOle','TypedBinary','Cursor','FixedChar','WideString','Largeint','ADT','Array','Reference','DataSet','OraBlob','OraClob','Variant','Interface','IDispatch','Guid','TimeStamp','FMTBcd','FixedWideChar','WideMemo' ) -->
<element name="Fieldtypenames">
<short>Human-readable names of field types</short>
<descr>
<var>FieldTypeNames</var> contains the names (in english) for the various field data types.
</descr>
<seealso>
<link id="TFieldType"/>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- constant Visibility: default
     Declaration: DefaultFieldClasses : Array[TFieldType] of TFieldClass = (Tfield,TStringField,TSmallIntField,TLongintField,TWordField,TBooleanField,TFloatField,TCurrencyField,TBCDField,TDateField,TTimeField,TDateTimeField,TBytesField,TVarBytesField,TAutoIncField,TBlobField,TMemoField,TGraphicField,TBlobField,TBlobField,TBlobField,TBlobField,nil,TStringField,TWideStringField,TLargeIntField,nil,nil,nil,nil,TBlobField,TMemoField,TVariantField,nil,nil,TGuidField,nil,nil,TWideStringField,TWideMemoField ) -->
<element name="DefaultFieldClasses">
<short>Default field classes to use when creating a new <var>TField</var> instance.</short>
<descr>
<var>DefaultFieldClasses</var> contains the <link id="TField"/> descendent class to use when a <var>TDataset</var> 
instance needs to create fields based on the <link id="TFieldDefs"/> field definitions when opening the dataset.
The entries can be set to create customized <var>TField</var> descendents for certain field datatypes in all datasets.
</descr>
<seealso>
<link id="TFieldType"/>
<link id="TField"/>
<link id="TField.DataType"/>
</seealso>
</element>

<!-- constant Visibility: default
     Declaration: dsEditModes = [dsEdit,dsInsert,dsSetKey] -->
<element name="dsEditModes">
<short>Edit modes</short>
<descr>
<var>dsEditModes</var> contains the various values of <link id="TDataset.State"/> for which the dataset is in edit mode, 
i.e. states in which it is possible to set field values for that dataset.
</descr>
<seealso>
<link id="TDatasetState"/>
<link id="TDataset.State"/>
<link id="TDataset.Edit"/>
<link id="TDataset.Insert"/>
</seealso>
</element>

<!-- constant Visibility: default
     Declaration: dsWriteModes = [dsEdit,dsInsert,dsSetKey,dsCalcFields,dsFilter,dsNewValue,dsInternalCalc] -->
<element name="dsWriteModes">
<short>Field write modes</short>
<descr>
<var>dsWriteModes</var> contains the various values of <link id="TDataset.State"/> for which data can be written to
the dataset buffer.
</descr>
<seealso>
<link id="TDatasetState"/>
<link id="TDataset.State"/>
</seealso>
</element>

<!-- procedure Visibility: default
     Declaration: procedure DatabaseError(const Msg: String);  Overload -->
<element name="DatabaseError">
<short>Raise an <var>EDatabaseError</var> exception.</short>
<descr>
<var>DatabaseError</var> raises an <link id="EDatabaseError"/> exception, passing it <var>Msg</var>. 
If <var>Comp</var> is specified, the name of the component is prepended to the message.
</descr>
<seealso>
<link id="DatabaseErrorFmt"/>
<link id="EDatabaseError"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Msg: String -->
<element name="DatabaseError.Msg">
<short>Message to specify for the exception</short>
</element>

<!-- argument Visibility: default
     Declaration: Comp: TComponent -->
<element name="DatabaseError.Comp">
<short>Prepend the name of this Component to the message</short>
</element>

<!-- procedure Visibility: default
     Declaration: procedure DatabaseErrorFmt(const Fmt: String;Args: Array of const)
                          ;  Overload -->
<element name="DatabaseErrorFmt">
<short>Raise an <var>EDatabaseError</var> exception with a formatted message</short>
<descr>
<var>DatabaseErrorFmt</var> raises an <link id="EDatabaseError"/> exception, passing it a 
message made by calling <link id="#rtl.sysutils.format"/> with the <var>fmt</var> and <var>Args</var> arguments.
If <var>Comp</var> is specified, the name of the component is prepended to the message.
</descr>
<seealso>
<link id="DatabaseError"/>
<link id="EDatabaseError"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Fmt: String -->
<element name="DatabaseErrorFmt.Fmt">
<short>Formatting string</short>
</element>

<!-- argument Visibility: default
     Declaration: Args: Array of const -->
<element name="DatabaseErrorFmt.Args">
<short>Formatting arguments</short>
</element>

<!-- argument Visibility: default
     Declaration: Comp: TComponent -->
<element name="DatabaseErrorFmt.Comp">
<short>Prepend the name of this Component to the message</short>
</element>

<!-- function Visibility: default
     Declaration: function ExtractFieldName(const Fields: String;var Pos: Integer)
                          : String -->
<element name="ExtractFieldName">
<short>Extract the field name at position</short>
<descr>
<var>ExtractFieldName</var> returns the string starting at position <var>Pos</var> till the next semicolon (;) character or the end of the string.
On return, <var>Pos</var> contains the position of the first character after the semicolon character (or one more than 
the length of the string).
</descr>
<seealso>
<link id="Tfields.GetFieldList"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="ExtractFieldName.Result">
<short>Name of the field</short>
</element>

<!-- argument Visibility: default
     Declaration: Fields: String -->
<element name="ExtractFieldName.Fields">
<short>Semicolon-separated list of field names</short>
</element>

<!-- argument Visibility: default
     Declaration: Pos: Integer -->
<element name="ExtractFieldName.Pos">
<short>Position to start copying.</short>
</element>

<!-- function Visibility: default
     Declaration: function DateTimeRecToDateTime(DT: TFieldType;Data: TDateTimeRec)
                               : TDateTime -->
<element name="DateTimeRecToDateTime">
<short>Convert <var>TDateTimeRec</var> record to a <var>TDateTime</var> value.</short>
<descr>
<var>DateTimeRecToDateTime</var> examines <var>Data</var> and <var>Dt</var> and uses <var>dt</var> to convert the timestamp in <var>Data</var> to 
a <var>TDateTime</var> value.
</descr>
<seealso>
<link id="TFieldType"/>
<link id="TDateTimeRec"/>
<link id="DateTimeToDateTimeRec"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="DateTimeRecToDateTime.Result">
<short><var>TDateTime</var> value corresponding to timestamp in <var>Data</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: DT: TFieldType -->
<element name="DateTimeRecToDateTime.DT">
<short>Datatype of <var>Data</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: Data: TDateTimeRec -->
<element name="DateTimeRecToDateTime.Data">
<short>Timestamp specification in <var>TDateTimeRec</var> formar.</short>
</element>

<!-- function Visibility: default
     Declaration: function DateTimeToDateTimeRec(DT: TFieldType;Data: TDateTime)
                               : TDateTimeRec -->
<element name="DateTimeToDateTimeRec">
<short>Convert <var>TDateTime</var> value to a <var>TDateTimeRec</var> record.</short>
<descr>
<var>DateTimeToDateTimeRec</var> examines <var>Data</var> and <var>Dt</var> and uses <var>dt</var> to convert the date/time valuein <var>Data</var> to 
a <var>TDateTimeRec</var> record.
</descr>
<errors>
</errors>
<seealso>
<link id="TFieldType"/>
<link id="TDateTimeRec"/>
<link id="DateTimeRecToDateTime"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="DateTimeToDateTimeRec.Result">
<short><var>TDateTimeRec</var> record corresponding to timestamp in <var>Data</var>.</short>
</element>

<!-- argument Visibility: default
     Declaration: DT: TFieldType -->
<element name="DateTimeToDateTimeRec.DT">
<short>Datatype for result</short>
</element>

<!-- argument Visibility: default
     Declaration: Data: TDateTime -->
<element name="DateTimeToDateTimeRec.Data">
<short>Timestam specification in <var>TDateTime</var> format.</short>
</element>

<!-- procedure Visibility: default
     Declaration: procedure DisposeMem(var Buffer;Size: Integer) -->
<element name="DisposeMem">
<short>Dispose of a heap memory block and <var>Nil</var> the pointer (deprecated)</short>
<descr>
<var>DisposeMem</var> disposes of the heap memory area pointed to by <var>Buffer</var> (<var>Buffer</var> must be of type <var>Pointer</var>). 
The <var>Size</var> parameter 
indicates the size of the memory area (it is, in fact, ignored by the heap manager). The pointer <var>Buffer</var> is set
to <var>Nil</var>. If <var>Buffer</var> is <var>Nil</var>, then nothing happens. Do not use <var>DisposeMem</var> on objects,
because their destructor will not be called.
</descr>
<errors>
If <var>Buffer</var> is not pointing to a valid heap memory block, then memory corruption may occur.
</errors>
<seealso>
<link id="#rtl.system.FreeMem"/>
<link id="#rtl.sysutils.freeandnil"/>
</seealso>
</element>

<!-- argument Visibility: default
     Declaration: Buffer -->
<element name="DisposeMem.Buffer">
<short>Pointer to memory area</short>
</element>

<!-- argument Visibility: default
     Declaration: Size: Integer -->
<element name="DisposeMem.Size">
<short>Size of the memory block</short>
</element>

<!-- function Visibility: default
     Declaration: function BuffersEqual(Buf1: Pointer;Buf2: Pointer;Size: Integer)
                      : Boolean -->
<element name="BuffersEqual">
<short>Check whether 2 memory buffers are equal</short>
<descr>
<var>BuffersEqual</var> compares the memory areas pointed to by the <var>Buf1</var>
and <var>Buf2</var> pointers and returns <var>True</var> if the contents are equal. 
The memory areas are compared for the first <var>Size</var> bytes. If all bytes in 
the indicated areas are equal, then <var>True</var> is returned, otherwise <var>False</var> is returned.
</descr>
<errors>
If <var>Buf1</var> or <var>Buf2</var> do not point to a valid memory area or <var>Size</var> is too large, 
then an exception may occur
</errors>
<seealso>
<link id="#rtl.sysutils.Comparemem"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="BuffersEqual.Result">
<short><var>True</var> if the memory areas have the same content.</short>
</element>

<!-- argument Visibility: default
     Declaration: Buf1: Pointer -->
<element name="BuffersEqual.Buf1">
<short>Pointer to first memory area.</short>
</element>

<!-- argument Visibility: default
     Declaration: Buf2: Pointer -->
<element name="BuffersEqual.Buf2">
<short>Pointer to second memory area</short>
</element>

<!-- argument Visibility: default
     Declaration: Size: Integer -->
<element name="BuffersEqual.Size">
<short>Number of bytes to compare.</short>
</element>

<!-- function Visibility: default
     Declaration: function SkipComments(var p: PChar;EscapeSlash: Boolean;
                     EscapeRepeat: Boolean) : Boolean -->
<element name="SkipComments">
<short>Skip SQL comments</short>
<descr>
<p>
<var>SkipComments</var> examines the null-terminated string in <var>P</var> and skips any SQL comment or string literal 
found at the start. It returns <var>P</var> the first non-comment or non-string literal position. The <var>EscapeSlash</var> parameter determines whether the 
backslash character (\) functions as an escape character (i.e. the following character is not considered a delimiter).
<var>EscapeRepeat</var> must be set to <var>True</var> if the quote character is repeated to indicate itself. 
</p>
<p>
The function returns <var>True</var> if a comment was found and skipped, <var>False</var> otherwise.
</p>
</descr>
<errors>
No checks are done on the validity of <var>P</var>.
</errors>
<seealso>
<link id="TParams.ParseSQL"/>
</seealso>
</element>

<!-- function result Visibility: default
     Declaration: Result -->
<element name="SkipComments.Result">
<short><var>True</var> if a comment was skipped.</short>
</element>

<!-- argument Visibility: default
     Declaration: p: PChar -->
<element name="SkipComments.p">
<short>Pointer to null-terminated string containing a SQL statement.</short>
</element>

<!-- argument Visibility: default
     Declaration: EscapeSlash: Boolean -->
<element name="SkipComments.EscapeSlash">
<short>Is a backslash an escape character</short>
</element>

<!-- argument Visibility: default
     Declaration: EscapeRepeat: Boolean -->
<element name="SkipComments.EscapeRepeat">
<short>Are repeated quotes considered a single character</short>
</element>

<element name="TField.EditMask">
<short>Specify an edit mask for an edit control</short>
<descr>
<p>
<var>EditMask</var> can be used to specify an edit mask for controls that
allow to edit this field. It has no effect on the field value, and serves
only to ensure that the user can enter only correct data for this field.
</p>
<p>
For more information on valid edit masks, see the documentation of the GUI
controls.
</p>
</descr>  
<seealso> 
<link id="TDateTimeField.EditMask"/>
<link id="TStringField.EditMask"/>
</seealso>
</element>

<element name="TField.EditMaskPtr">
<short>Alias for EditMask</short>
<descr>
<var>EditMaskPtr</var> is a read-only alias for the <link
id="TField.EditMask">EditMask</link> property. It is not used.
</descr>
<seealso>
<link id="TField.EditMask"/>
</seealso>
</element>

<element name="TDateTimeField.EditMask">
<short>Specify an edit mask for an edit control</short>
<descr>
<p>
<var>EditMask</var> can be used to specify an edit mask for controls that
allow to edit this field. It has no effect on the field value, and serves
only to ensure that the user can enter only correct data for this field. 
</p>
<p>
<var>TDateTimeField</var> just changes the visibility of the
<var>EditMark</var> property, it is introduced in <var>TField</var>.
</p>
<p>
For more information on valid edit masks, see the documentation of the GUI
controls.
</p>
</descr>
<seealso>
<link id="TField.EditMask"/>
</seealso>
</element>

<element name="TStringField.EditMask">
<short>Specify an edit mask for an edit control</short>
<descr>
<p>
<var>EditMask</var> can be used to specify an edit mask for controls that
allow to edit this field. It has no effect on the field value, and serves
only to ensure that the user can enter only correct data for this field. 
</p>
<p>
<var>TStringField</var> just changes the visibility of the
<var>EditMark</var> property, it is introduced in <var>TField</var>.
</p>
<p> 
For more information on valid edit masks, see the documentation of the GUI
controls.
</p>
</descr>
<seealso>
<link id="TField.EditMask"/>
</seealso>
</element>

<element name="TStringField.SetFieldType">
<short>Set the field type</short>
<descr>
<var>SetFieldType</var> is overridden in <link id="TStringField"/>
to check the data type more accurately (<var>ftString</var> and
<var>ftFixedChar</var>). 
No extra functionality is added.
</descr>
<seealso>
<link id="TField.DataType"/>
</seealso>
</element>

<element name="TWideStringField.SetFieldType">
<short>Set the field type</short>
<descr>
<var>SetFieldType</var> is overridden in <link id="TWideStringField"/>
to check the data type more accurately (<var>ftWideString</var> and
<var>ftFixedWideChar</var>). 
No extra functionality is added.
</descr>
<seealso>
<link id="TField.DataType"/>
</seealso>
</element>

<element name="Tfields.GetEnumerator">
<short>Return an enumerator for the <var>for..in</var> construct</short>
<descr>
<var>GetEnumerator</var> is the implementation of <var>IEnumerable</var> and
returns an instance of <link id="TFieldsEnumerator"/>
</descr>
<seealso>
<link id="TFieldsEnumerator"/>
<link id="#rtl.system.IEnumerable"/>
</seealso>
</element>

<element name="TFieldsEnumerator">
<short>Default enumerator for the fields collection of a dataset.</short>
<descr>
<p>
<var>TFieldsEnumerator</var> implements all the methods of
<var>IEnumerator</var> so a <link id="TFields"/> instance can be used in a
for..in construct. <var>TFieldsEnumerator</var> returns all the fields in
the <var>TFields</var> collection. Therefor the following construct is possible:
</p>
<code>
Var
  F : TField;
  
begin
   // ...
   For F in MyDataset.Fields do
     begin
     // F is of type TField.
     end;
   // ...  
</code>
<p>
Do not create an instance of <var>TFieldsEnumerator</var> manually. The
compiler will do all that is needed when it encounters the for..in
construct.
</p>
</descr>
<seealso>
<link id="TField"/>
<link id="TFields"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<element name="TFieldsEnumerator.Create">
<short>Create a new instance of <var>TFieldsEnumerator</var>.</short>
<descr>
<var>Create</var> instantiates a new instance of
<var>TFieldsEnumerator</var>. It stores the <var>AFields</var> reference,
pointing to the <link id="TFields"/> instance that created the enumerator.
It initializes the enumerator position.
</descr>
</element>

<element name="TFieldsEnumerator.MoveNext">
<short>Move the current field to the next field in the collection.</short>
<descr>
<var>MoveNext</var> moves the internal pointer to the next field in the
fields collection, and returns <var>True</var> if the operation was a
success. If no more fields are available, then <var>False</var> is returned.
</descr>
<seealso> 
<link id="TFieldsEnumerator.Current"/>
</seealso>
</element>

<element name="TFieldsEnumerator.Current">
<short>Return the current field</short>
<descr>
<var>Current</var> returns the current field. It will return a non-nil value
only after <var>MoveNext</var> returned <var>True</var>.
</descr>
<seealso>
<link id="TFieldsEnumerator.MoveNext"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="EUpdateError.OriginalException">
<short>Originally raised exception</short>
<descr>
<var>OriginalException</var> is the originally raised exception that is
transformed to an <var>EUpdateError</var> exception.
</descr>
<seealso>
<link id="DB.EDatabaseError"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TField.AsBytes">
<short>Retrieve the contents of the field as an array of bytes</short>
<descr>
<var>AsBytes</var> returns the contents of the field as an array of bytes.
For blob data this is the actual blob content.
</descr>
<seealso>
<link id="TBlobField"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TStringField.SetFieldType.AValue">
<short>Value to set the field type to.</short>
</element>

<!-- argument Visibility: public -->
<element name="TWideStringField.SetFieldType.AValue">
<short>Value to set the field type to.</short>
</element>

<!--
  ********************************************************************
    #fcl.db.TFMTBCDField
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFMTBCDField">
<short>Fixed precision floating point data field</short>
<descr>
<var>TFMTBCDField</var> is the field created when a data type of
<var>ftFMTBCD</var> is encountered. It represents usually a fixed-precision
floating point data type (BCD : Binary Coded Decimal data) such as the
<var>DECIMAL</var> or <var>NUMERIC</var> field types in an SQL database.
</descr>
<seealso>
<link id="TFloatField"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFMTBCDField.Create">
<short>Create a new instance of the <var>TFMTBCDField</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TFMTBCDField</var>
class: it sets the <link id="MinValue"/>, <link id="MaxValue"/>, <link
id="TField.Size">Size</link> (15) and <link id="Precision"/> (2) fields to their
default values.
</descr>
<seealso>
<link id="MinValue"/>
<link id="MaxValue"/> 
<link id="TField.Size">Size</link>
<link id="Precision"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TFMTBCDField.Create.AOwner">
<short>Owner of the field, usually the dataset.</short>
</element>

<!-- function Visibility: public -->
<element name="TFMTBCDField.CheckRange">
<short>Check value if it is in the range defined by MinValue and MaxValue</short>
<descr>
<var>CheckRange</var> checks whether <var>AValue</var> is between <link
id="MinValue"/> and <link id="MaxValue"/> if they are both nonzero. 
If either of them is zero, then <var>True</var> is returned. The
<var>MinValue</var> and <var>MaxValue</var> values themselves are also valid values.
</descr>
<errors>
</errors>
<seealso>
<link id="MinValue"/>
<link id="MaxValue"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TFMTBCDField.CheckRange.Result">
<short><var>True</var> if <var>AValue</var> is in the range [<var>MinValue</var>,<var>MaxValue</var>]</short>
</element>

<!-- argument Visibility: public -->
<element name="TFMTBCDField.CheckRange.AValue">
<short>Value to check</short>
</element>

<!-- property Visibility: public -->
<element name="TFMTBCDField.Value">
<short>The value of the field as a BCD value</short>
<descr>
<var>Value</var> is the value of the field as a BCD (Binary Coded Decimal) value.
</descr>
<seealso>
<link id="TField.AsFloat"/>
<link id="TField.AsCurrency"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TFMTBCDField.Precision">
<short>Total number of digits in the BCD data</short>
<descr>
<var>Precision</var> is the total number of digits in the BCD data. 
The maximum precision is 32.
</descr>
<seealso>
<link id="TField.AsFloat"/>
<link id="TField.AsCurrency"/>
<link id="Size"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TFMTBCDField.Currency">
<short>Does the field contain currency data ?</short>
<descr>
<var>Currency</var> determines how the textual representation of the data is
formatted. It has no influence on the actual data itself. If <var>True</var> 
it is represented as a currency (monetary value). 
If <link id="TField.DisplayFormat">DisplayFormat</link> or 
<link id="TField.EditFormat">EditFormat</link> are set, these values are used
instead to format the value.
</descr>
<seealso>
<link id="TField.DisplayFormat"/>
<link id="TField.EditFormat"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TFMTBCDField.MaxValue">
<short>Maximum value for the field</short>
<descr>
<var>MaxValue</var> can be set to a nonzero value to indicate the maximum
value the field may contain. It must be set together with <link
id="MinValue"/> or it will not have any effect.
</descr>
<seealso>
<link id="TFMTBCDField.CheckRange"/>
<link id="MinValue"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TFMTBCDField.MinValue">
<short>Minimum value for the field</short>
<descr>
<var>MinValue</var> can be set to a nonzero value to indicate the maximum
value the field may contain. It must be set together with <link id="MaxValue"/> 
or it will not have any effect.
</descr>
<seealso>
<link id="TFMTBCDField.CheckRange"/>
<link id="MaxValue"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TFMTBCDField.Size">
<short>Number of digits after the decimal point</short>
<descr>
<var>Size</var> is the maximum number of digits allowed after the decimal point.
Together with the <link id="Precision"/> property it determines the maximum
allowed range of values for the field. This range can be restricted using
the <link id="MinValue"/> and <link id="MaxValue"/> properties.
</descr>
<seealso>
<link id="MinValue"/>
<link id="MaxValue"/>
<link id="Precision"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TFieldsEnumerator.Create.AFields">
<short>TFields instance for which the enumerator is created</short>
</element>

<!-- function result Visibility: public -->
<element name="TFieldsEnumerator.MoveNext.Result">
<short>True if there is a next value, false otherwise.</short>
</element>

<!-- function result Visibility: public -->
<element name="TFields.GetEnumerator.Result">
<short><var>TFieldsEnumerator</var> instance used in enumerator.</short>
</element>

<!-- property Visibility: public -->
<element name="TParam.AsFMTBCD">
<short>Parameter value as a BCD value</short>
<descr>
<var>AsFMTBCD</var> can be used to get or set the parameter's value as a BCD
typed value.
</descr>
<seealso>
<link id="AsFloat"/>
<link id="AsCurrency"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TRecordBufferBaseType">
<short>Opaque base type for <var>TRecordBuffer</var></short>
<descr>
<var>TRecordBufferBaseType</var> should not be used directly. It just serves
as an (opaque) base type to <link id="TRecordBuffer"/>
</descr>
<seealso>
<link id="TRecordBuffer"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TRecordBuffer">
<short>Pointer type for record data buffer</short>
<descr>
<var>TRecordBuffer</var> is the type used by <link id="TDataset"/> to point to a
record's data buffer. It is used in several internal <var>TDataset</var> routines.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TPSCommandType">
<short>Type of SQL command</short>
<descr>
<var>TPSCommandType</var> is used in the <link id="IProviderSupport.PSGetCommandType"/>
call to determine the type of SQL command that the provider is exposing. 
It is meaningless for datasets that are not SQL based.
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctUnknown">
<short>Unknown SQL type or not SQL based</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctQuery">
<short>General SQL statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctTable">
<short>Table contents (select * from table)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctStoredProc">
<short>Stored procedure statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctSelect">
<short>SQL SELECT Statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctInsert">
<short>SQL INSERT Statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctUpdate">
<short>SQL UPDATE statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctDelete">
<short>SQL DELETE Statement</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TPSCommandType.ctDDL">
<short>SQL DDL statement</short>
</element>

<!--
  ********************************************************************
    #fcl.db.IProviderSupport
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IProviderSupport">
<short>Interface for Provider support</short>
<descr>
<var>IProviderSupport</var> is an interface used by Delphi's TProvider (datasnap) technology. 
It is currently not used in Free Pascal, but is provided for Delphi
compatibility. The <link id="TDataset"/> class implements all the methods of
this interface for the benefit of descendent classes, but does not publish
the interface in it's declaration.
</descr>
<seealso>
<link id="TDataset"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSEndTransaction">
<short>End an active transaction</short>
<descr>
<var>PSEndTransaction</var> ends an active transaction if an transaction is
active. (<link id="PSInTransaction"/> returns <var>True</var>). If
<var>ACommit</var> is <var>True</var> then the transaction is committed,
else it is rollbacked.
</descr>
<seealso>
<link id="PSInTransaction"/>
<link id="PSStartTransaction"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSEndTransaction.ACommit">
<short>Should the transaction be committed or rollbacked?</short>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSExecute">
<short>Execute the current command-text.</short>
<descr>
<var>PSExecute</var> executes the current SQL statement: the command as it is returned by <link id="PSGetCommandText"/>.
</descr>
<seealso>
<link id="PSGetCommandText"/>
<link id="PSExecuteStatement"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSExecuteStatement">
<short>Execute a SQL statement.</short>
<descr>
<p>
<var>PSExecuteStatement</var> will execute the <var>ASQL</var> SQL statement in the current transaction.
The SQL statement can have parameters embedded in it (in the form <var>:ParamName</var>), values for these 
parameters will be taken from <var>AParams</var>. If the SQL statement returns a result-set, then the
result set can be returned in <var>ResultSet</var>. The function returns
<var>True</var> if the statement was executed succefully.
</p>
<p>
<var>PSExecuteStatement</var> does not modify the content of
<var>CommandText</var>: <link id="PSGetCommandText"/> returns the same value
before and after a call to <var>PSExecuteStatement</var>.
</p>
</descr>
<seealso>
<link id="PSGetCommandText"/>
<link id="PSSetCommandText"/>
<link id="PSExecuteStatement"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSExecuteStatement.Result">
<short>True if the statement ASQL was executed succesfully.</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSExecuteStatement.ASQL">
<short>SQL statement to execute (may contain parameters)</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSExecuteStatement.AParams">
<short>Parameter values to substitute when executing ASQL</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSExecuteStatement.ResultSet">
<short>Pointer to resultset (if any)</short>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSGetAttributes">
<short>Get a list of attributes (metadata)</short>
<descr>
<var>PSGetAttributes</var> returns a set of <var>name=value</var> pairs which is
included in the data packet sent to a client. 
</descr>
<seealso>
<link id="PSGetCommandText"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSGetAttributes.List">
<short>List of attributes</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetCommandText">
<short>Return the SQL command executed for getting data.</short>
<descr>
<var>PSGetCommandText</var> returns the SQL command that is executed when the <link id="PSExecute"/>
function is called (for a TSQLQuery this would be the SQL property) or when
the dataset is opened.
</descr>
<seealso>
<link id="PSExecute"/>
<link id="PSSetCommandText"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetCommandText.Result">
<short>SQL statement</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetCommandType">
<short>Return SQL command type</short>
<descr>
<var>PSGetCommandType</var> should return the kind of SQL statement that is
executed by the command (as returned by <link id="PSGetCommandText"/>). The
list of possible command types is enumerated in <link id="TPSCommandType"/>.
</descr>
<seealso>
<link id="PSGetCommandText"/>
<link id="TPSCommandType"/>
<link id="PSExecute"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetCommandType.Result">
<short>The kind of SQL command.</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetDefaultOrder">
<short>Default order index definition</short>
<descr>
<var>PSGetDefaultOrder</var> should return the index definition from the
list of indexes (as returned by <link id="PSGetIndexDefs"/>) that represents
the default sort order.
</descr>
<seealso>
<link id="PSGetIndexDefs"/>
<link id="PSGetKeyFields"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetDefaultOrder.Result">
<short>Index definition for default order</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetIndexDefs">
<short>Return a list of index definitions</short>
<descr>
<var>PSGetIndexDefs</var> should return a list of index definitions, limited
to the types of indexes in <var>IndexTypes</var>.
</descr>
<seealso>
<link id="PSGetDefaultOrder"/>
<link id="PSGetKeyFields"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetIndexDefs.Result">
<short>The collection of index definitions.</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSGetIndexDefs.IndexTypes">
<short>Types of indexes that should be included in the result.</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetKeyFields">
<short>Return a list of key fields in the dataset</short>
<descr>
<var>PSGetKeyFields</var> returns a semicolon-separated list of fieldnames that make up the
unique key for a record. Normally, these are the names of the fields that
have <var>pfInKey</var> in their <link id="TField.ProviderOptions">ProviderOptions</link>
property.
</descr>
<seealso>
<link id="PSGetIndexDefs"/>
<link id="PSGetDefaultOrder"/>
<link id="TField.ProviderOptions"/>
<link id="TProviderFlags"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetKeyFields.Result">
<short>Semicolon separated list of fieldnames which form the unique key for a record.</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetParams">
<short>Get the parameters in the commandtext</short>
<descr>
<var>PSGetParams</var> returns the list of parameters in the command-text
(as returned by <link id="PSGetCommandText"/>). This is usually the
<var>Params</var> property of a <link id="TDataset"/> descendant.
</descr>
<seealso>
<link id="PSGetCommandText"/>
<link id="PSSetParams"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetParams.Result">
<short>The list of parameters in the SQL statement</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetQuoteChar">
<short>Quote character for quoted strings</short>
<descr>
<var>PSGetQuoteChar</var> returns the quote character needed to enclose
string literals in an SQL statement for the underlying database.
</descr>
<seealso>
<link id="PSGetTableName"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetQuoteChar.Result">
<short>The actual quote character</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetTableName">
<short>Name of database table which must be updated</short>
<descr>
<var>PSGetTableName</var> returns the name of the table for which update SQL statements must be constructed. 
The provider can create and execute SQL statements to update the underlying database
by itself. For this, it uses <var>PSGetTableName</var> as the name of the table to update.
</descr>
<seealso>
<link id="PSGetQuoteChar"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetTableName.Result">
<short>Name of database table to update</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSGetUpdateException">
<short>Transform exception to <var>UpdateError</var></short>
<descr>
<var>PSGetUpdateException</var> is called to transform and chain exceptions
that occur during an ApplyUpdates operation. The exception <var>E</var> must
be transformed to an <link id="EUpdateError"/> exception.  The previous
<var>EUpdateError</var> exception in the update batch is passed in
<var>Prev</var>.
</descr>
<seealso>
<link id="EUpdateError"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSGetUpdateException.Result">
<short>The new <var>EUpdateError</var>exception</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSGetUpdateException.E">
<short>The originally raised excepion</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSGetUpdateException.Prev">
<short>The previous exception in the applyupdates batch (can be nil).</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSInTransaction">
<short>Is the dataset in an active transaction.</short>
<descr>
<var>PSInTransaction</var> returns <var>True</var> if the dataset is in an
active transaction or <var>False</var> if  no transaction is active.
</descr>
<seealso>
<link id="PSEndTransaction"/>
<link id="PSStartTransaction"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSInTransaction.Result">
<short><var>True</var> if a transaction is currently active</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSIsSQLBased">
<short>Is the dataset SQL based</short>
<descr>
<var>PSIsSQLBased</var> returns <var>True</var> if the dataset is SQL based
or not. Note that this is different from <link id="PSIsSQLSupported"/> which
indicates whether SQL statements can be executed using <link id="PSExecuteCommand"/>
</descr>
<seealso>
<link id="PSIsSQLSupported"/>
<link id="PSExecuteCommand"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSIsSQLBased.Result">
<short>True if the dataset is based on an SQL statement</short>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSIsSQLSupported">
<short>Can the dataset support SQL statements</short>
<descr>
<var>PSIsSQLSupported</var> returns <var>True</var> if <link
id="PSExecuteCommand"/> can be used to execute SQL statements on the
underlying database.
</descr>
<seealso>
<link id="PSExecuteCommand"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSIsSQLSupported.Result">
<short>Can SQL statements be executed or not</short>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSReset">
<short>Position the dataset on the first record</short>
<descr>
<var>PSReset</var> repositions the dataset on the first record. For
bi-directional datasets, this usually means that first is called, but for
unidirectional datasets this may result in re-fetching the data from the
underlying database.
</descr>
<seealso>
<link id="TDataset.First"/>
<link id="TDataset.Open"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSSetCommandText">
<short>Set the command-text of the dataset</short>
<descr>
<var>PSSetCommandText</var> sets the commandtext (SQL) statement that is executed by 
<var>PSExecute</var> or that is used to open the dataset.
</descr>
<seealso>
<link id="PSExecute"/>
<link id="PSGetCommandText"/>
<link id="PSSetParams"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSSetCommandText.CommandText">
<short>New SQL command to be used</short>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSSetParams">
<short>Set the parameters for the command text</short>
<descr>
<var>PSSetParams</var> sets the values of the parameters that should be used
when executing the commandtext SQL statement.
</descr>
<seealso>
<link id="PSSetCommandText"/>
<link id="PSGetParams"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSSetParams.AParams">
<short>Value for the parameters</short>
</element>

<!-- procedure Visibility: default -->
<element name="IProviderSupport.PSStartTransaction">
<short>Start a new transaction</short>
<descr>
<var>PSStartTransaction</var> is used by the provider to start a new transaction.
It will only be called if no transaction was active yet (i.e. <link
id="PSIntransaction"/> returned <var>False</var>).
</descr>
<errors>
</errors>
<seealso>
<link id="PSEndTransaction"/>
<link id="PSIntransaction"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IProviderSupport.PSUpdateRecord">
<short>Update a record</short>
<descr>
<p>
<var>PSUpdateRecord</var> is called before attempting to update the records
through generated SQL statements. The update to be performed is passed in
<var>UpdateKind</var> parameter. The <var>Delta</var> Dataset's current
record contains all data for the record that must be updated.
</p>
<p>
The function returns <var>True</var> if the update was succesfully applied,
<var>False</var> if not. In that case the provider will attempt to update
the record using SQL statements if the dataset allows it.
</p>
</descr>
<seealso>
<link id="PSIsSQLSupported"/>
<link id="PSExecuteCommand"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IProviderSupport.PSUpdateRecord.Result">
<short><var>True</var> if the record was succesfully updated.</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSUpdateRecord.UpdateKind">
<short>Type of update to perform.</short>
</element>

<!-- argument Visibility: default -->
<element name="IProviderSupport.PSUpdateRecord.Delta">
<short>Data for the record that must be updated.</short>
</element>

<!-- property Visibility: public -->
<element name="TDataSet.BlockReadSize">
<short>Number of records to read</short>
<descr>
<var>BlockReadSize</var> can be set to a positive number to prevent the
dataset from sending notifications to DB-Aware controls while scrolling
through the data. Setting it to zero will re-enable sending of
notifications, as will putting the dataset in another state (edit etc.).
</descr>
<seealso>
<link id="EnableControls"/>
<link id="DisableControls"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TCustomConnection.Close.ForceClose">
<short>Ignore errors when closing the connection.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TDataSetState.dsRefreshFields">
<short>Dataset is refreshing field values from server after an update.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TProviderFlag.pfRefreshOnInsert">
<short>This field's value should be refreshed after insert.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TProviderFlag.pfRefreshOnUpdate">
<short>This field's value should be refreshed after update.</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFieldDefClass">
<short>Class of <var>TFieldDef</var>.</short>
<descr>
<var>TFieldDefClass</var> is used to be able to customize the actual
<link id="TDataset.FieldDefs"/> items class.
</descr>
<seealso>
<link id="TDataset.FieldDefs"/>
<link id="TFieldDef"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TFieldDefs.Add.Result">
<short>Add new fieldDef result</short>
</element>

<!-- argument Visibility: public -->
<element name="TFieldDefs.Add.AFieldNo">
<short>Number of the field </short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFieldDefsClass">
<short>Class of <var>TFieldDefs</var></short>
<descr>
<var>TFieldDefClass</var> is used to be able to customize the actual
<link id="TDataset.FieldDefs"/>  class used in a <link id="TDataset"/>
descendent.
</descr>
<seealso>
<link id="TDataset"/>
<link id="TDataset.FieldDefs"/> 
<link id="TFieldDefs"/> 
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TField.FieldDef">
<short>Fielddef associated with this field</short>
<descr>
<var>FieldDef</var> references the <var>TFieldDef</var> instance to which
this field instance is bound. When a dataset is opened, the <link
id="TDataset.FieldDefs"/> property is filled with field definitions as
returned from the server. After this fields are created, or if they already
exist, are bound to these fielddefs.
</descr>
<seealso>
<link id="TDataset.FieldDefs"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFieldsClass">
<short>Class of TFields</short>
<descr>
<var>TFieldsClass</var> is needed to be able to specify the class of fields
used in <link id="TDataset.Fields"/>;
</descr>
<seealso>
<link id="TDataset.Fields"/>
<link id="TFields"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TParam.AsBCD">
<short>Get or set parameter value as BCD value</short>
<descr>
<var>AsBCD</var> can be used to get or set a parameter value as a BCD
encoded floating point value.
</descr>
<seealso>
<link id="TParam.AsFloat"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TParam.AsBytes">
<short>Get or set parameter value as <var>TBytes</var></short>
<descr>
<var>AsBCD</var> can be used to get or set a parameter value as a <var>TBytes</var>
value. This should normally only be used for blob type parameters.
</descr>
<seealso>
<link id="TParam.AsString"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TParamClass">
<short>Class of <var>TParam</var></short>
<descr>
<var>TParamClass</var> is needed to be able to  specify the type of
parameters when instantiating a <link id="TParams"/> collection.
</descr>
<seealso>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.db.TParamsEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TParamsEnumerator">
<short>Enumerator for parameters</short>
<descr>
<var>TParamsEnumerator</var> is a helper class to implement enumeration
(<var>for..in</var>) of parameters. It implements the <var>IEnumerator</var>
interface.
</descr>
<seealso>
<link id="TParams.GetEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TParamsEnumerator.Create">
<short>Create a new <var>TParamsEnumerator</var> instance</short>
<descr>
<var>Create</var> instantiates a new enumerator for <var>AParams</var>.
</descr>
<seealso>
<link id="TParams.GetEnumerator"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TParamsEnumerator.Create.AParams">
<short>TParams instance which must be enumerated</short>
</element>

<!-- function Visibility: public -->
<element name="TParamsEnumerator.MoveNext">
<short>Go to next TParam</short>
<descr>
<var>MoveNext</var> will move to the next TParam instance if possible. If it
returns <var>True</var> then <link id="TParamsEnumerator.Current"/> will
return the new current <var>TParam</var>
</descr>
<errors>
</errors>
<seealso>
<link id="TParamsEnumerator.Current"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TParamsEnumerator.MoveNext.Result">
<short><var>True</var> if there was a next <var>TParam</var>, <var>False</var> if none existed </short>
</element>

<!-- property Visibility: public -->
<element name="TParamsEnumerator.Current">
<short>Current <var>TParam</var> instance</short>
<descr>
<var>Current</var> is the current <var>TParam</var> instance. It is only valid if
<link id="TParamsEnumerator.MoveNext"/> returned true.
</descr>
<seealso>
<link id="TParamsEnumerator.MoveNext"/>
</seealso>
</element>

<!-- argument Visibility: public -->
<element name="TParams.Create.AItemClass">
<short>Item class to use for this <var>TParams</var> instance.</short>
</element>

<!-- function Visibility: public -->
<element name="TParams.GetEnumerator">
<short>Return an enumerator for the parameters</short>
<descr>
<var>GetEnumerator</var> returns an enumerator that loops over all
parameters (as implemented by <link id="TParamsEnumerator"/>)
</descr>
<seealso>
<link id="TParamsEnumerator"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TParams.GetEnumerator.Result">
<short>The <var>TParamsEnumerator</var> instance.</short>
</element>

<!-- constant Visibility: default -->
<element name="ftBlobTypes">
<short>Constant enumerating all blob types</short>
<descr>
<var>ftBlobTypes</var> is a constant containing all blob field data types. 
It is to be preferred over the <link id="TBlobType"/> range, which contains
some non-blob types as well.
</descr>
<seealso>
<link id="TBlobType"/>
</seealso>
</element>

</module> <!-- db -->

</package>
</fpdoc-descriptions>
