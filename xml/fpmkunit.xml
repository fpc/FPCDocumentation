<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="fcl">

<!--
  ====================================================================
    fpmkunit
  ====================================================================
-->

<module name="fpmkunit">
<short>Free Pascal package building and installation engine</short>
<descr>
<p>The <var>fpmkunit</var> unit implements the core building and installation engine for Free Pascal packages.
It provides a complete set of classes and functions for managing package compilation, dependency resolution,
file installation, and archive creation.</p>
<p>This unit forms the foundation of the fpmake build system, offering classes like <link id="TPackage">TPackage</link>
for package management, <link id="TTarget">TTarget</link> for build targets, <link id="TDependency">TDependency</link>
for dependency tracking, and various installer classes for deployment.</p>
<p>The building engine supports cross-platform compilation with CPU and OS-specific conditional compilation,
package variants, custom commands, and flexible installation schemes.</p>
</descr>

<topic name="Dependencies">
<short>Handling dependencies</short>
<descr>
<p>When compiling units and programs, the installer will by default compile all targets in the order that they were specified</p>
<p>However, if <var>unita</var> depends on <var>unitb</var>, and <var>unita</var> was specified before <var>unitb</var>,
then <var>unitb</var> will be compiled twice: when compiling <var>unita</var> the compiler will compile it because it needs <var>unitb</var>.
Then <var>unitb2</var> will be compiled because it is in the list of targets. Clearly, this is not ideal or efficient. 
</p>
<p>There are 2 ways to solve this:</p>
<ol>
<li> Specify the dependencies of the units.
In this case, when a target has dependencies, the installer will compile dependencies first,
and will compile the target last</li>
<li> Switch to using a "build unit".
This unit is an empty unit which simply lists all units to be compiled.
Instead of compiling the units one by one, the installer will try to compile the buildunit,
and then the compiler will make sure that the units are compiled in the correct order,
so every unit is compiled only once (for interdependent units the compiler may still compile them twice).
</li>
</ol>
<p>
The latter is clearly the easier solution. When using a build unit,
the installer will of course delete the unit sources and <var>.ppu</var> file after compiling,
since they are not needed any more after compilation.
</p>
<p>
When running the installer, you can request that it tries to use a build-unit by giving the <var>-bu</var> or <var>--buildunit</var> command-line option.
However, there are some cases when using a build unit is not an option. Therefore, the <link id="TPackage.SupportedBuildModes"/>
property can be used to indicate which build modes can be used for a package.
if the <var>bmBuildUnit</var> build mode (<link id="TBuildMode"/>) is not in the set of buildmodes,
then the installer will compile one by one, even when a buildunit was requested.
</p>
<p>To specify dependencies, you can use the <link id="TTarget.Dependencies">Dependencies</link> property of <link id="TTarget"/>:</p>
<code>
uses fpmkunit;

var
  P: TPackage;
  T : TTarget;
  
begin
  With Installer do
    begin
    P:=Packages.AddPackage('mypackage');
    P.Dependencies.Clear;
    T:=P.Targets.AddUnit('src2/unita.pp');
    T.Dependencies.AddUnit('unitb');
    P.Targets.AddUnit('src2/unitb.pp');
    Run;
    end;
end.
</code>
<p>You can add a unit to the dependencies using <link id="TDependencies.AddUnit"/>, or a complete package using <link id="TDependencies.Add"/>.</p>
<p>When compiling the above and running it, the following output can be seen</p>
<pre>
./fpmake4 compile -v
Start compiling package mypackage for target x86_64-linux.
      Compiling target unitb
        Executing command "/home/michael/bin/fpc \
                           -Tlinux -Px86_64 \
                           -FUunits/x86_64-linux/ \
                           src2/unitb.pp"
  Compiling target unita
    Executing command "/home/michael/bin/fpc \
                       -Tlinux -Px86_64 \
                       -FUunits/x86_64-linux/ \
                       src2/unita.pp"
Generating "mypackage-x86_64-linux.fpm"
[100%] Compiled package mypackage
</pre>
<p>As you can see, the installed compiled <var>unitb</var> first. </p>
</descr>
<seealso>
<link id="CommandLineOptions"/>
<link id="Usage"/>
</seealso>
</topic>

<topic name="CommandLineOptions">
<short>Commandline options</short>
<descr>
<p>
The <var>fpmkunit</var> unit takes control of parsing the command-line to decide what to do and what options to set.
The command-line takes a mandatory command name followed by options controlling the behaviour.
</p>
<pre>
fpmake command [options]
</pre>
<p>
The <var>command</var> must be one of the following:
</p>
<dl>
<dt>compile</dt><dd>Compile all units in the selected package or packages.</dd>
<dt>build</dt><dd>Force a build of all units in the selected package or packages.</dd>
<dt>install</dt><dd>Install all units in the selected package or packages.</dd>
<dt>buildinstall</dt><dd>Build and install all units in the selected package or packages.</dd>
<dt>uninstall</dt><dd>Uninstall the selected package or packages.</dd>
<dt>clean</dt><dd>Remove all generated files in the selected package or packages for current CPU-OS target.</dd>
<dt>distclean</dt><dd>Remove all generated files in the selected package or packages for all targets.</dd>
<dt>archive</dt><dd>Create archive (zip) with all units in the selected package or packages.</dd>
<dt>manifest</dt><dd>Create a manifest suitable for import in repository.</dd>
<dt>zipinstall</dt><dd>Install all units in the selected package or packages into an archive.</dd>
<dt>pkglist</dt><dd>Create list of all packages suitable for FPC installer.</dd>
<dt>fpdocproject</dt><dd>Create fpdoc project file(s) for all packages</dd>
</dl>
<p>
The behaviour of the command can be controlled by specifying one of the many options:
</p>
<dl>
<dt><var>-h</var> or <var>--help</var></dt>
<dd>Shows a help message</dd>
<dt><var>-lc</var><var>--list-commands</var></dt>
<dd>list commands instead of actually executing them.</dd>
<dt><var>-n</var><var>--nofpccfg</var></dt>
<dd>Compiler will not use fpc.cfg</dd>
<dt><var>-v</var><var>--verbose</var></dt>
<dd>Be verbose when working.</dd>
<dt><var>-d</var><var>--debug</var></dt>
<dd>Add debug information when working.</dd>
<dt><var>-I</var><var>--interactive</var></dt>
<dd>Allow to interact with child processes.</dd>
<dt><var>-e</var><var>--useenv</var></dt>
<dd>Use environment to pass options to compiler.</dd>
<dt><var>-ie</var><var>--installexamples</var></dt>
<dd>Install the example-sources.</dd>
<dt><var>-bu</var><var>--buildunit</var></dt>
<dd>Compile package in Build-unit mode.</dd>
<dt><var>-sap</var><var>--skipallprograms</var></dt>
<dd>Skip all programs even if native-compiling/installing.</dd>
<dt><var>-scp</var><var>--skipcrossprograms</var></dt>
<dd>Skip programs when cross-compiling/installing.</dd>
<dt><var>-io</var><var>--ignoreinvalidoption</var></dt>
<dd>Ignore further invalid options.</dd>
<dt><var>-C</var><var>--cpu=Value</var></dt>
<dd>Compile for indicated CPU.</dd>
<dt><var>-O</var><var>--os=Value</var></dt>
<dd>Compile for indicated OS.</dd>
<dt><var>-s</var><var>--subtarget=Value</var></dt>
<dd>Compile for indicated subtarget.</dd>
<dt><var>-t</var><var>--target=Value</var></dt>
<dd>Compile for indicated target, string in the form CPU-OS(-subtarget).</dd>
<dt><var>-P</var><var>--prefix=Value</var></dt>
<dd>Use indicated prefix directory for all commands.</dd>
<dt><var>-B</var><var>--baseinstalldir=Value</var></dt>
<dd>Use indicated directory as base install dir.</dd>
<dt><var>-BI</var><var>--bininstalldir=Value</var></dt>
<dd>Use indicated directory as base install dir.</dd>
<dt><var>-LI</var><var>--libinstalldir=Value</var></dt>
<dd>Use indicated directory as base install dir.</dd>
<dt><var>-UL</var><var>--localunitdir=Value</var></dt>
<dd>Use indicated directory as local (user) unit dir.</dd>
<dt><var>-UG</var><var>--globalunitdir=Value</var></dt>
<dd>Use indicated directory as global unit dir.</dd>
<dt><var>-sp</var><var>--searchpath=Value</var></dt>
<dd>Add search directory for packages.</dd>
<dt><var>-U</var><var>--unitinstalldir=Value</var></dt>
<dd>Use indicated directory to install units into.</dd>
<dt><var>-r</var><var>--compiler=Value</var></dt>
<dd>Use indicated binary as compiler.</dd>
<dt><var>-f</var><var>--config=Value</var></dt>
<dd>Use indicated config file when compiling.</dd>
<dt><var>-o</var><var>--options=Value</var></dt>
<dd>Pass extra options to the compiler.</dd>
<dt><var>-df</var><var>--doc-folder=Value</var></dt>
<dd>Use indicated directory as fpdoc output folder.</dd>
<dt><var>-sd</var><var>--single-docfile=Value</var></dt>
<dd>Create a single fpdoc project file for all projects.</dd>
<dt><var>-do</var><var>--doc-options=Value</var></dt>
<dd>Name=Value File with options for fpdoc project file.</dd>
<dt><var>-fsp</var><var>--fpunitsrcpath=Value</var></dt>
<dd>Sourcepath to replace in fpunits.cfg on installation.</dd>
<dt><var>-zp</var><var>--zipprefix=Value</var></dt>
<dd>Use indicated prefix for generated archives.</dd>
<dt><var>-T</var><var>--threads=Value</var></dt>
<dd>Enable the indicated amount of worker threads.</dd>
<dt><var>--data2inc=Value</var></dt>
<dd>Use indicated data2inc executable.</dd>
</dl>
<p>
Packages can come in variants. To add a package-variant to all packages:
</p>
<pre>
 +[variantname]+=[variant1],variant2,...
</pre>
<p>
To add a package-variant to all packages which other packages will inherit:
</p>
<pre>
 +[variantname]*=[variant1],variant2,...
</pre> 
<p>
To add specific options for one package-variant:
</p>
<pre>
--options_[variantname]_[variant1]=Value
</pre>
</descr>
<seealso>
<link id="Usage"/>
<link id="Dependencies"/>
</seealso>
</topic>

<topic name="Usage">
<short>Usage description</short>
<descr>
<p>
The <var>fpmkunit</var> unit is meant to be used to create a program that handles compilation,
archiving and installation of a set of pascal sources, collected in so-called packages.
The unit can handle multiple packages, and will manage dependencies of packages automatically.
Customarily this program is called <file>fpmake</file>. When using fppkg or in the FPC sources,
use of this name is mandatory.
</p>
<p>
The unit supports the following operations:
</p>
<ul>
<li> Compilation of units, programs or libraries.</li>
<li> installation of the compiled results to standard locations.</li>
<li> Creation of a .zip file with the sources of the files.</li>
<li> Generation of documentation with fpdoc.</li>
<li> Execution of custom commands when compiling, installing or packaging</li>
</ul>
<p>
The unit consists of a series of classes which are designed to work together.
An instance of these classes is created for you, they are ready to be used.
</p>
<dl>
<dt>Installer</dt><dd>This function returns the main <link id="TCustomInstaller"/> instance. This class is the entry point for all functionality:
it manages settings and package definitions and processes command-line options</dd>
<dt>Defaults</dt><dd>The main <link id="TCustomDefaults"/> Instance. Here you can set compiler options such as CPU, OS,
all kinds of search paths, executable paths and directories</dd>
<dt>Installer.BuildEngine</dt><dd>This is the engine that does all the work.</dd>
</dl>
<p>
For the majority of cases, it suffices to define some packages using <link id="TCustomInstaller.Packages">Installer.Packages</link>,
and to call <link id="TCustomInstaller.Run">Installer.Run</link>.
The <var>Run</var> method will examine the <link id="TCustomInstaller.RunMode">RunMode</link> property to
determine what action is expected, and then it proceeds to execute the
action using the <link id="TCustomInstaller.BuildEngine">BuildEngine</link>.
The latter does all the work, and contains all the logic to launch commands in the correct order to execute the specified action.
</p>
<p>
To demonstrate this, a simple program can be made:
</p>
<code>
program fpmake1;

uses fpmkunit;

var
  P: TPackage;
  
begin
  With Installer do
    begin
    P:=Packages.AddPackage('mypackage');
    P.Dependencies.Clear;
    P.Targets.AddUnit('src/unit1.pp');
    Run;
    end;
end.
</code>
<p>
The <link id="TCustomInstaller"/> class maintains a collection of <link id="TCustomInstaller.Packages">Packages</link>. At least 1 package must be defined.
Every package has a list of files that must be compiled, and possibly a list of files that needs to be installed together with installed programs.
</p>
<p>Every file that needs to be compiled, is a <link id="TTarget"/>, and all targets are in the <link id="TPackage.Targets">Targets</link> property of the
<link id="TPackage"/> class. Installer will compile the targets in the order that they are specified, unless dependencies have been set up
(see also <link id="Dependencies"/>), in which case the order will be changed to compile dependencies of a target first, for any given target.
</p>
<p>
After compiling the <file>fpmake1.pp</file> program, it can be used to compile the <file>unit1.pp</file> when run with the <var>compile</var> command;
</p>
<pre>
>  ./fpmake1 compile
Start compiling package mypackage for target x86_64-linux.
       Compiling src/unit1.pp
[100%] Compiled package mypackage
</pre>
<p>
To pass extra options to the compiler, we can use the <link id="Defaults"/> variable, which is valid as soon as the installer is created:
</p>
<code>
program fpmake2;

uses fpmkunit;

var
  P: TPackage;
  
begin
  With Installer do
    begin
    Defaults.Options.Add('-O2');
    P:=Packages.AddPackage('mypackage');
    P.Dependencies.Clear;
    P.Targets.AddUnit('src/unit1.pp');
    Run;
    end;
end;    
</code>
<p>
This program can be compiled, and when run with the <var>-v</var> option, you can see that the compiler is called with the extra option:
</p>
<pre>
./fpmake2 compile -v
Start compiling package mypackage for target x86_64-linux.
  Compiling target unit1
    Executing command "/home/michael/bin/fpc  \
                       -Tlinux -Px86_64 \
                       -FUunits/x86_64-linux/ \
                       -O2 src/unit1.pp"
Generating "mypackage-x86_64-linux.fpm"
[100%] Compiled package mypackage
</pre>
<p>(the lines have been split for readability. On the console the log would be on one line)</p>
<p>To make life easier, if you are using the 3.3.1 or higher version of fpmkunit, you can use the <link id="TCustomInstaller.AddPackageFromDir">AddPackageFromDir</link> call.</p>
<code>
uses fpmkunit;

begin
  With Installer do
    begin
    AddPackageFromDir('mypackage','src');
    Run;
    end;
end.
</code>
<p>
When compiled and run, the output is the following:
</p>
<pre>
> ./fpmake3 compile -v
Adding unit src/unit1.pp to targets of mypackage
Switching to buildunit compilation of package mypackage
Start compiling package mypackage for target x86_64-linux.
  Compiling target unit1
Compiling target BuildUnit_mypackage
Not using buildunit
  Executing command "/home/michael/bin/fpc \
                     -Tlinux -Px86_64 \
                     -FUunits/x86_64-linux/ \
                     -Fusrc \
                     units/x86_64-linux/BuildUnit_mypackage.pp"
Deleted file "units/x86_64-linux/BuildUnit_mypackage.ppu"
Deleted file "units/x86_64-linux/BuildUnit_mypackage.pp"
Generating "mypackage-x86_64-linux.fpm"
[100%] Compiled package mypackage
</pre>
<p>Note that the installer switched to using a build unit:
the <link id="AddPackageFromDir"/> command does not check dependencies of the units.
Instead, it switches to using a build unit (a unit that simply uses all units to be compiled)
and then compiles the buildunit: in that case, the compiler will compile all files in the correct order.
</p>
</descr>

<seealso>
<link id="CommandLineOptions"/>
<link id="Dependencies"/>
</seealso>
</topic>

<!-- uses unit Visibility: default -->
<element name="Types">
<short>Basic type definitions</short>
</element>

<!-- uses unit Visibility: default -->
<element name="SysUtils">
<short>System utility functions</short>
</element>

<!-- uses unit Visibility: default -->
<element name="Classes">
<short>Base classes and collections</short>
</element>

<!-- uses unit Visibility: default -->
<element name="process">
<short>Process execution functionality</short>
</element>

<!-- uses unit Visibility: default -->
<element name="libtar">
<short>TAR archive handling</short>
</element>

<!-- uses unit Visibility: default -->
<element name="zipper">
<short>ZIP archive creation and extraction</short>
</element>

<!-- uses unit Visibility: default -->
<element name="zstream">
<short>Compressed stream handling</short>
</element>

<!-- alias type Visibility: default -->
<element name="RTLString">
<short>Runtime library string type</short>
<descr>
<p><var>RTLString</var> is an alias for the standard string type used throughout the Free Pascal Runtime Library.
This type provides a consistent string representation across different platforms and compiler configurations,
ensuring compatibility when working with RTL functions and procedures in the FPMake build system.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFileType">
<short>File type classification for build targets</short>
<descr>
<p><var>TFileType</var> defines the different types of files that can be produced by build targets in the fpmake system.
This classification determines how files are compiled, linked, and installed.</p>
<dl>
<dt>ftSource</dt><dd> represents Pascal source code files (.pas, .pp, .p files) that contain program or unit source code.
These files are compiled by the Free Pascal Compiler to produce executable programs or compiled units.</dd>
<dt>ftUnit</dt><dd> represents compiled Pascal unit files (.ppu files) that contain compiled code and interface information.
These files are produced by the compiler and used for linking with other units and programs.</dd>
<dt>ftObject</dt><dd> represents object files (.o files on Unix, .obj on Windows) containing compiled machine code.
These intermediate files are produced during compilation and used by the linker to create final executables
or libraries.</dd>
<dt>ftResource</dt><dd> represents resource files (.res, .rc files) containing application resources such as icons,
bitmaps, strings, and other data. These files are compiled into applications to provide user interface elements
and embedded data.</dd>
<dt>ftExecutable</dt><dd> represents executable program files (.exe on Windows, no extension on Unix) that contain
runnable machine code. These files are the final output of compiling and linking Pascal programs.</dd>
<dt>ftStaticLibrary</dt><dd> represents static library files (.a files on Unix, .lib on Windows) containing compiled code
that is linked directly into executables at compile time. Static libraries become part of the final executable.</dd>
<dt>ftSharedLibrary</dt><dd> represents dynamic shared library files (.so on Unix, .dll on Windows) containing compiled code
that is loaded at runtime. Shared libraries can be used by multiple programs simultaneously and are loaded
dynamically when needed.</dd>
</dl>
</descr>
<seealso>
<link id="TTarget">TTarget</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftSource">
<short>Pascal source code file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftUnit">
<short>Compiled Pascal unit file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftObject">
<short>Object file produced by compilation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftResource">
<short>Resource file containing application resources</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftExecutable">
<short>Executable program file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftStaticLibrary">
<short>Static library file for linking</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFileType.ftSharedLibrary">
<short>Dynamic shared library file</short>
</element>

<!-- set type Visibility: default -->
<element name="TFileTypes">
<short>Set of file type flags for source files</short>
<descr>
<p><var>TFileTypes</var> is a set type that can contain multiple <link id="TFileType">TFileType</link> values,
allowing flexible specification of which file types are supported or required by build targets.
This set-based approach enables targets to accept multiple input file types or produce different output types
based on compilation settings.</p>
</descr>
<seealso>
<link id="TFileType"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCpu">
<short>Supported CPU architectures for compilation</short>
<descr>
<p><var>TCpu</var> enumerates the CPU architectures supported by the Free Pascal Compiler for cross-platform compilation.
This enumeration is used throughout the build system to specify target CPU architectures and handle CPU-specific
compilation requirements.</p>
</descr>
<seealso>
<link id="TOS">TOS</link>
<link id="TCPUS">TCPUS</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.cpuNone">
<short>No specific CPU architecture</short>
<descr>
<p><var>cpuNone</var> indicates no specific CPU architecture, used as a default or unspecified value
when CPU architecture is not relevant or has not been determined.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.i386">
<short>Intel 32-bit x86 architecture</short>
<descr>
<p><var>i386</var> represents the Intel 32-bit x86 architecture, compatible with 80386 processors and later.
This is one of the most widely supported architectures for desktop and server systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.m68k">
<short>Motorola 68000 architecture</short>
<descr>
<p><var>m68k</var> represents the Motorola 68000 series architecture, used in classic computers such as
Amiga, Atari ST, and early Macintosh systems. This architecture is still supported for embedded
and legacy system development.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.powerpc">
<short>PowerPC 32-bit architecture</short>
<descr>
<p><var>powerpc</var> represents the 32-bit PowerPC architecture, used in older Mac systems, embedded systems,
and various Unix workstations. This RISC architecture provides efficient performance for specific
application domains.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.sparc">
<short>SPARC 32-bit architecture</short>
<descr>
<p><var>sparc</var> represents the 32-bit SPARC (Scalable Processor Architecture) developed by Sun Microsystems.
This RISC architecture is primarily used in Unix workstations and servers, particularly Solaris systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.x86_64">
<short>Intel/AMD 64-bit x86 architecture</short>
<descr>
<p><var>x86_64</var> represents the 64-bit extension of the x86 architecture, also known as AMD64 or x64.
This is the dominant architecture for modern desktop, laptop, and server systems, providing large
memory addressing and improved performance.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.arm">
<short>ARM 32-bit architecture</short>
<descr>
<p><var>arm</var> represents the 32-bit ARM (Advanced RISC Machine) architecture, widely used in mobile devices,
embedded systems, and increasingly in desktop and server applications. ARM processors are known for
their power efficiency and performance.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.powerpc64">
<short>PowerPC 64-bit architecture</short>
<descr>
<p><var>powerpc64</var> represents the 64-bit PowerPC architecture, used in high-performance servers
and workstations. This architecture provides extended memory addressing and improved performance
over the 32-bit PowerPC variant.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.avr">
<short>Atmel AVR microcontroller architecture</short>
<descr>
<p><var>avr</var> represents the Atmel AVR 8-bit microcontroller architecture, widely used in embedded systems
and Arduino-compatible boards. This architecture is optimized for low-power applications and simple
embedded control tasks.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.armeb">
<short>ARM 32-bit big-endian architecture</short>
<descr>
<p><var>armeb</var> represents the 32-bit ARM architecture in big-endian byte order configuration.
This variant is used in specific embedded systems and network equipment where big-endian
byte ordering is required.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.mips">
<short>MIPS 32-bit big-endian architecture</short>
<descr>
<p><var>mips</var> represents the 32-bit MIPS (Microprocessor without Interlocked Pipeline Stages)
architecture in big-endian configuration. This RISC architecture is used in embedded systems,
routers, and various consumer electronics.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.mipsel">
<short>MIPS 32-bit little-endian architecture</short>
<descr>
<p><var>mipsel</var> represents the 32-bit MIPS architecture in little-endian byte order configuration.
This variant is commonly used in consumer devices and embedded systems that require
little-endian byte ordering.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.mips64">
<short>MIPS 64-bit big-endian architecture</short>
<descr>
<p><var>mips64</var> represents the 64-bit MIPS architecture in big-endian configuration.
This architecture provides extended memory addressing and is used in high-performance
embedded systems and specialized computing applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.mips64el">
<short>MIPS 64-bit little-endian architecture</short>
<descr>
<p><var>mips64el</var> represents the 64-bit MIPS architecture in little-endian byte order configuration.
This variant combines the benefits of 64-bit addressing with little-endian byte ordering
for specific application requirements.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.jvm">
<short>Java Virtual Machine bytecode target</short>
<descr>
<p><var>jvm</var> represents compilation to Java Virtual Machine bytecode, allowing Pascal code
to run on any platform supporting a Java Virtual Machine. This target enables cross-platform
compatibility through the JVM runtime environment.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.i8086">
<short>Intel 16-bit x86 architecture</short>
<descr>
<p><var>i8086</var> represents the Intel 16-bit x86 architecture, compatible with 8086 and 8088 processors.
This architecture is used for developing software for legacy systems and embedded applications
requiring 16-bit x86 compatibility.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.aarch64">
<short>ARM 64-bit architecture</short>
<descr>
<p><var>aarch64</var> represents the 64-bit ARM architecture, also known as ARM64 or ARMv8-A.
This modern ARM architecture is used in high-performance mobile devices, Apple Silicon Macs,
and increasingly in server applications, providing excellent performance and energy efficiency.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.wasm32">
<short>WebAssembly 32-bit architecture</short>
<descr>
<p><var>wasm32</var> represents the 32-bit WebAssembly target, enabling Pascal code to run in web browsers
and other WebAssembly runtimes. This target provides near-native performance for web applications
and cross-platform compatibility.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.sparc64">
<short>SPARC 64-bit architecture</short>
<descr>
<p><var>sparc64</var> represents the 64-bit SPARC architecture, also known as SPARC V9.
This architecture provides extended memory addressing and enhanced performance over 32-bit SPARC,
primarily used in high-end Unix servers and workstations.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.riscv32">
<short>RISC-V 32-bit architecture</short>
<descr>
<p><var>riscv32</var> represents the 32-bit RISC-V (Reduced Instruction Set Computing - Five) architecture.
This open-source instruction set architecture is gaining popularity in embedded systems, IoT devices,
and academic research applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.riscv64">
<short>RISC-V 64-bit architecture</short>
<descr>
<p><var>riscv64</var> represents the 64-bit RISC-V architecture, providing extended memory addressing
and enhanced computational capabilities. This open-source architecture is used in high-performance
computing, server applications, and next-generation processor development.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.xtensa">
<short>Xtensa processor architecture</short>
<descr>
<p><var>xtensa</var> represents the Tensilica Xtensa configurable processor architecture.
This architecture is commonly used in embedded systems, particularly in wireless and networking
applications, including ESP32 microcontrollers and similar IoT devices.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.z80">
<short>Zilog Z80 8-bit processor architecture</short>
<descr>
<p><var>z80</var> represents the Zilog Z80 8-bit microprocessor architecture, popular in vintage computers
and embedded systems. This architecture is still used in retro computing projects, embedded controllers,
and educational applications requiring 8-bit processing capabilities.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCpu.loongarch64">
<short>LoongArch 64-bit architecture</short>
<descr>
<p><var>loongarch64</var> represents the 64-bit LoongArch architecture developed by Loongson Technology.
This RISC architecture is used in Chinese-designed processors and computing systems, providing
an alternative architecture for desktop and server applications.</p>
</descr>
</element>

<!-- set type Visibility: default -->
<element name="TCPUS">
<short>Set of CPU architectures</short>
<descr>
<p><var>TCPUS</var> is a set type that can contain multiple <link id="TCpu">TCpu</link> values,
enabling the specification of multiple target CPU architectures for a single build configuration.
This allows packages and targets to support multiple CPU architectures simultaneously,
facilitating cross-platform development and deployment strategies.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TOS">
<short>Supported operating systems for compilation</short>
<descr>
<p><var>TOS</var> enumerates the operating systems supported by the Free Pascal Compiler for cross-platform compilation.
This enumeration is used throughout the build system to specify target operating systems and handle OS-specific
compilation and installation requirements.</p>
</descr>
<seealso>
<link id="TCpu">TCpu</link>
<link id="TOSes">TOSes</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.osNone">
<short>No specific operating system</short>
<descr>
<p><var>osNone</var> indicates no specific operating system, used as a default or unspecified value
when operating system is not relevant or has not been determined.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.linux">
<short>Linux operating system</short>
<descr>
<p><var>linux</var> represents the Linux operating system family, including various distributions
such as Ubuntu, Red Hat, SUSE, and others. This is one of the most widely supported
operating systems for Free Pascal development and deployment.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.go32v2">
<short>DOS 32-bit extender operating system</short>
<descr>
<p><var>go32v2</var> represents the GO32 version 2 DOS extender, allowing 32-bit applications
to run on MS-DOS systems. This target is used for developing legacy DOS applications
with extended memory capabilities.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.win32">
<short>Windows 32-bit operating system</short>
<descr>
<p><var>win32</var> represents 32-bit Microsoft Windows operating systems, including Windows 95/98/ME
and 32-bit versions of Windows NT/2000/XP/Vista/7/8/10/11. This target provides compatibility
with both legacy and modern Windows systems using 32-bit execution.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.os2">
<short>IBM OS/2 operating system</short>
<descr>
<p><var>os2</var> represents the IBM OS/2 operating system, a multitasking operating system
developed by IBM and Microsoft. This target supports development for OS/2 systems,
including modern variants like eComStation and ArcaOS.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.freebsd">
<short>FreeBSD operating system</short>
<descr>
<p><var>freebsd</var> represents the FreeBSD operating system, a Unix-like operating system
derived from BSD. FreeBSD is known for its stability, performance, and advanced networking
capabilities, making it popular for server applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.beos">
<short>BeOS operating system</short>
<descr>
<p><var>beos</var> represents the BeOS operating system and its modern successor Haiku.
This operating system is designed for multimedia applications and provides excellent
performance for audio and video processing tasks.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.netbsd">
<short>NetBSD operating system</short>
<descr>
<p><var>netbsd</var> represents the NetBSD operating system, a Unix-like operating system
derived from BSD. NetBSD is known for its portability and runs on a wide variety
of hardware architectures, from embedded systems to mainframes.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.amiga">
<short>Amiga operating system</short>
<descr>
<p><var>amiga</var> represents the Amiga operating system, used in Commodore Amiga computers.
This target supports development for classic Amiga systems and modern Amiga-compatible
systems like AROS and AmigaOS 4.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.atari">
<short>Atari TOS operating system</short>
<descr>
<p><var>atari</var> represents the Atari TOS (The Operating System) used in Atari ST computers.
This target supports development for classic Atari systems and modern Atari-compatible
systems and emulators.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.solaris">
<short>Solaris operating system</short>
<descr>
<p><var>solaris</var> represents the Oracle Solaris operating system (formerly Sun Solaris).
This Unix-based operating system is known for its reliability, scalability, and advanced
features, particularly in enterprise server environments.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.qnx">
<short>QNX real-time operating system</short>
<descr>
<p><var>qnx</var> represents the QNX real-time operating system, designed for embedded systems
and applications requiring real-time performance. QNX is commonly used in automotive,
medical, and industrial control systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.netware">
<short>Novell NetWare operating system</short>
<descr>
<p><var>netware</var> represents the Novell NetWare operating system, a network operating system
designed for local area networks. This target supports development for NetWare-based
network services and applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.openbsd">
<short>OpenBSD operating system</short>
<descr>
<p><var>openbsd</var> represents the OpenBSD operating system, a Unix-like operating system
derived from BSD. OpenBSD is known for its focus on security, correctness, and proactive
security features, making it popular for security-critical applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wdosx">
<short>WDOSX DOS extender</short>
<descr>
<p><var>wdosx</var> represents the WDOSX DOS extender environment, enabling 32-bit applications
to run on DOS systems. This target is used for developing DOS-based applications
with extended memory and functionality capabilities.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.palmos">
<short>Palm OS operating system</short>
<descr>
<p><var>palmos</var> represents the Palm OS operating system, used in Palm handheld devices
and other personal digital assistants (PDAs). This target supports development for
Palm-based mobile and embedded applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.macosclassic">
<short>Classic Mac OS operating system</short>
<descr>
<p><var>macosclassic</var> represents the classic Mac OS (System 7, Mac OS 8/9) used in
pre-Mac OS X Macintosh computers. This target supports development for legacy
Macintosh systems and applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.darwin">
<short>macOS (Darwin) operating system</short>
<descr>
<p><var>darwin</var> represents macOS and its underlying Darwin kernel, used in Apple Macintosh
computers. This target supports development for modern Mac systems, including
macOS desktop and server applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.emx">
<short>EMX DOS/OS2 extender</short>
<descr>
<p><var>emx</var> represents the EMX runtime environment, providing POSIX-like functionality
for DOS and OS/2 systems. This target enables Unix-style applications to run on
DOS and OS/2 platforms.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.watcom">
<short>Watcom DOS extender</short>
<descr>
<p><var>watcom</var> represents the Watcom DOS extender environment, enabling enhanced
DOS applications with extended memory access. This target supports development
for DOS-based applications using Watcom-compatible extensions.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.morphos">
<short>MorphOS operating system</short>
<descr>
<p><var>morphos</var> represents the MorphOS operating system, a modern Amiga-compatible
operating system. This target supports development for MorphOS systems, providing
Amiga-like functionality on PowerPC hardware.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.netwlibc">
<short>NetWare with LibC</short>
<descr>
<p><var>netwlibc</var> represents NetWare with LibC support, providing enhanced C library
functionality for NetWare applications. This target enables more portable code
development for NetWare server environments.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.win64">
<short>Windows 64-bit operating system</short>
<descr>
<p><var>win64</var> represents 64-bit Microsoft Windows operating systems, including
64-bit versions of Windows XP/Vista/7/8/10/11 and Windows Server editions.
This target provides native 64-bit execution with extended memory addressing.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wince">
<short>Windows CE operating system</short>
<descr>
<p><var>wince</var> represents Windows CE (Compact Edition), a real-time operating system
designed for embedded devices and mobile systems. This target supports development
for Windows CE-based devices and embedded applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.gba">
<short>Nintendo Game Boy Advance</short>
<descr>
<p><var>gba</var> represents the Nintendo Game Boy Advance handheld gaming console.
This target enables development of homebrew games and applications for the
Game Boy Advance platform.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.nds">
<short>Nintendo DS handheld system</short>
<descr>
<p><var>nds</var> represents the Nintendo DS dual-screen handheld gaming system.
This target supports development of homebrew games and applications for the
Nintendo DS platform.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.embedded">
<short>Generic embedded system</short>
<descr>
<p><var>embedded</var> represents a generic embedded system target without a specific
operating system. This target is used for bare-metal embedded development
and microcontroller programming.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.symbian">
<short>Symbian mobile operating system</short>
<descr>
<p><var>symbian</var> represents the Symbian mobile operating system, used in smartphones
and mobile devices. This target supports development for Symbian-based mobile
applications and system software.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.haiku">
<short>Haiku operating system</short>
<descr>
<p><var>haiku</var> represents the Haiku operating system, an open-source operating system
inspired by BeOS. Haiku focuses on personal computing with an emphasis on
multimedia capabilities and user interface design.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.iphonesim">
<short>iOS Simulator environment</short>
<descr>
<p><var>iphonesim</var> represents the iOS Simulator environment used for testing and
development of iOS applications on Mac systems. This target enables iOS development
without requiring physical iOS devices.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.aix">
<short>IBM AIX operating system</short>
<descr>
<p><var>aix</var> represents IBM AIX (Advanced Interactive eXecutive), a Unix operating system
running on IBM Power Systems. This target supports development for enterprise-grade
AIX server environments and applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.java">
<short>Java Virtual Machine platform</short>
<descr>
<p><var>java</var> represents the Java Virtual Machine platform, enabling Pascal code
to compile to Java bytecode. This target provides cross-platform compatibility
through the JVM runtime environment.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.android">
<short>Android mobile operating system</short>
<descr>
<p><var>android</var> represents the Android mobile operating system, based on Linux
and primarily used in smartphones and tablets. This target supports development
of Android applications and system components.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.nativent">
<short>Windows Native NT</short>
<descr>
<p><var>nativent</var> represents the Windows NT native environment, enabling development
of kernel-mode drivers and system-level components that run directly on the
Windows NT kernel without Win32 subsystem dependencies.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.msdos">
<short>MS-DOS operating system</short>
<descr>
<p><var>msdos</var> represents the Microsoft DOS operating system, a single-user,
single-tasking operating system. This target supports development of legacy
DOS applications and utilities.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wii">
<short>Nintendo Wii gaming console</short>
<descr>
<p><var>wii</var> represents the Nintendo Wii gaming console platform.
This target enables development of homebrew games and applications for the
Nintendo Wii console system.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.aros">
<short>AROS Research Operating System</short>
<descr>
<p><var>aros</var> represents AROS (AROS Research Operating System), an open-source
operating system compatible with AmigaOS. This target supports development
for AROS systems and Amiga-compatible applications.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.dragonfly">
<short>DragonFly BSD operating system</short>
<descr>
<p><var>dragonfly</var> represents DragonFly BSD, a Unix-like operating system forked
from FreeBSD. DragonFly BSD focuses on performance, scalability, and innovative
kernel design for multiprocessor systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.win16">
<short>Windows 16-bit operating system</short>
<descr>
<p><var>win16</var> represents 16-bit Microsoft Windows operating systems, including
Windows 1.x, 2.x, and 3.x. This target supports development of legacy Windows
applications using the 16-bit Windows API.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.freertos">
<short>FreeRTOS real-time operating system</short>
<descr>
<p><var>freertos</var> represents FreeRTOS, a real-time operating system kernel for embedded devices.
This target supports development of real-time embedded applications with deterministic
response times and multi-tasking capabilities.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.zxspectrum">
<short>ZX Spectrum home computer</short>
<descr>
<p><var>zxspectrum</var> represents the ZX Spectrum home computer platform.
This target enables development of applications and games for the classic
ZX Spectrum 8-bit computer system.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.msxdos">
<short>MSX-DOS operating system</short>
<descr>
<p><var>msxdos</var> represents MSX-DOS, a disk operating system for MSX computers.
This target supports development of applications for MSX-DOS-compatible
computer systems and MSX home computers.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.ios">
<short>Apple iOS mobile operating system</short>
<descr>
<p><var>ios</var> represents Apple iOS, the mobile operating system used in iPhones
and iPads. This target supports development of native iOS applications
for Apple mobile devices.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.amstradcpc">
<short>Amstrad CPC home computer</short>
<descr>
<p><var>amstradcpc</var> represents the Amstrad CPC (Color Personal Computer) series.
This target enables development of applications and games for the classic
Amstrad CPC 8-bit computer systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.sinclairql">
<short>Sinclair QL computer system</short>
<descr>
<p><var>sinclairql</var> represents the Sinclair QL (Quantum Leap) computer system.
This target supports development of applications for the Sinclair QL
16/32-bit home computer platform.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wasip1">
<short>WebAssembly System Interface preview 1</short>
<descr>
<p><var>wasip1</var> represents WebAssembly System Interface (WASI) preview 1,
providing a standard interface for WebAssembly modules to interact with
the host environment in a portable and secure manner.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.human68k">
<short>Human68k operating system</short>
<descr>
<p><var>human68k</var> represents Human68k, an operating system for Motorola 68000-based
Japanese computers such as the Sharp X68000 series. This target supports development
for these classic Japanese computer systems.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.ps1">
<short>Sony PlayStation 1 gaming console</short>
<descr>
<p><var>ps1</var> represents the Sony PlayStation 1 gaming console platform.
This target enables development of homebrew games and applications for the
original PlayStation console system.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wasip1threads">
<short>WebAssembly System Interface preview 1 with threads</short>
<descr>
<p><var>wasip1threads</var> represents WebAssembly System Interface (WASI) preview 1
with threading support, enabling multi-threaded WebAssembly applications
to run in a secure and portable environment.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOS.wasip2">
<short>WebAssembly System Interface preview 2</short>
<descr>
<p><var>wasip2</var> represents WebAssembly System Interface (WASI) preview 2,
the next evolution of WASI providing enhanced capabilities and improved
standards for WebAssembly system interaction.</p>
</descr>
</element>

<!-- set type Visibility: default -->
<element name="TOSes">
<short>Set of operating systems</short>
<descr>
<p><var>TOSes</var> is a set type that can contain multiple <link id="TOS">TOS</link> values,
allowing the specification of multiple target operating systems for build configurations.
This enables packages to define which operating systems they support or require,
and allows for flexible cross-platform compilation strategies within the FPMake system.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCompilerMode">
<short>Free Pascal Compiler language compatibility modes</short>
<descr>
<p><var>TCompilerMode</var> specifies the language compatibility mode used by the Free Pascal Compiler.
Each mode affects syntax rules, default behavior, and language feature availability during compilation.</p>
</descr>
<seealso>
<link id="TCompilerModes">TCompilerModes</link>
<link id="TTarget.Mode">TTarget.Mode</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmFPC">
<short>Standard Free Pascal mode</short>
<descr>
<p><var>cmFPC</var> represents the default Free Pascal compiler mode, providing standard Pascal
syntax with Free Pascal-specific extensions.
Specifying this mode passes <var>-mFPC</var> to the compiler.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmTP">
<short>Turbo Pascal compatibility mode</short>
<descr>
<p><var>cmTP</var> provides compatibility with Borland Turbo Pascal, enabling compilation
of legacy Turbo Pascal code with minimal modifications. This mode restricts language
features to those available in classic Turbo Pascal.
Specifying this mode passes <var>-mTP</var> to the compiler.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmObjFPC">
<short>Object Pascal mode with object-oriented features</short>
<descr>
<p><var>cmObjFPC</var> enables extended Object Pascal features, including classes, interfaces,
exceptions, and modern object-oriented programming constructs.
Specifying this mode passes <var>-mObjFPC</var> to the compiler.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmDelphi">
<short>Delphi compatibility mode</short>
<descr>
<p><var>cmDelphi</var> provides compatibility with Embarcadero Delphi syntax and behaviour,
enabling compilation of Delphi code with Free Pascal.
Specifying this mode passes <var>-mDelphi</var> to the compiler.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmMacPas">
<short>Macintosh Pascal compatibility mode</short>
<descr>
<p><var>cmMacPas</var> provides compatibility with traditional Macintosh Pascal dialects,
supporting syntax and conventions used in classic Mac development environments.
Specifying this mode passes <var>-mMacPas</var> to the compiler.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompilerMode.cmDelphiUnicode">
<short>Delphi Unicode compatibility mode</short>
<descr>
<p><var>cmDelphiUnicode</var> provides compatibility with modern Delphi versions that use
Unicode strings by default. This mode matches Delphi's Unicode string handling
and UTF-16 character support for enhanced internationalization.
Specifying this mode passes <var>-mDelphiUnicode</var> to the compiler.
</p>
</descr>
</element>

<!-- set type Visibility: default -->
<element name="TCompilerModes">
<short>Set of compiler modes</short>
<descr>
<p><var>TCompilerModes</var> is a set type that can contain multiple <link id="TCompilerMode">TCompilerMode</link> values,
allowing build configurations to specify which compiler language modes should be supported or used.
This enables flexible language compatibility settings for different parts of a package build process.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TInstallMode">
<short>Installation operation mode</short>
<descr>
<p><var>TInstallMode</var> specifies whether the current install run is installing or uninstalling.</p>
<dl>
<dt>imInstall</dt><dd> specifies that the installation operation should install package files
to their designated target locations in the system. This mode copies compiled units,
executables, and resources to the appropriate installation directories.</dd>
<dt>imUnInstall</dt><dd> specifies that the installation operation should remove previously
installed package files from the system. This mode cleans up installed units,
executables, and resources from the installation directories.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TInstallMode.imInstall">
<short>Install package files</short>
<descr>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TInstallMode.imUnInstall">
<short>Uninstall package files</short>
<descr>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTargetType">
<short>Classification of build target types</short>
<descr>
<p><var>TTargetType</var> defines the different categories of build targets supported by the fpmake system:</p>
<dl>
<dt>ttProgram</dt><dd>represents a build target that produces an executable program file</dd>
<dt>ttUnit</dt><dd> represents a build target that produces a compiled Pascal unit.
Unit targets generate .ppu files that can be used by other units and programs
through the uses clause.</dd>
<dt>ttImplicitUnit</dt><dd> represents a unit target that is compiled automatically when
needed by other targets, without being explicitly listed in the build process.</dd>
<dt>ttCleanOnlyUnit</dt><dd> represents a unit target that is only processed during clean
operations to remove generated files. These units are not compiled during normal
build processes but are included in cleanup operations.</dd>
<dt>ttExampleUnit</dt><dd> represents a unit target that serves as an example or demonstration.
Example units are typically compiled separately from the main package and may
have different installation rules.</dd>
<dt>ttExampleProgram</dt><dd>represents a program target that serves as an example or demonstration.
Example programs showcase package functionality and are typically compiled separately
from the main package components.</dd>
<dt>ttSharedLibrary</dt><dd> represents a build target that produces a dynamic shared library
(.so on Unix, .dll on Windows).</dd>
<dt>ttFPDoc</dt><dd> represents a target that generates documentation using the FPDoc
system. These targets documentation source code and XML documentation files.</dd>
</dl>
</descr>
<seealso>
<link id="TTarget">TTarget</link>
<link id="TTargetTypes">TTargetTypes</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttProgram">
<short>Executable program target</short>
<descr>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttUnit">
<short>Regular Pascal unit target</short>
<descr>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttImplicitUnit">
<short>Unit with implicit compilation dependencies</short>
<descr>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttCleanOnlyUnit">
<short>Unit processed only during clean operations</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttExampleUnit">
<short>Example unit for demonstration purposes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttExampleProgram">
<short>Example program for demonstration purposes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttFPDoc">
<short>FPDoc documentation generation target</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetType.ttSharedLibrary">
<short>Dynamic shared library target</short>
</element>

<!-- set type Visibility: default -->
<element name="TTargetTypes">
<short>Set of target types</short>
<descr>
<p>A set type containing one or more values from the <link id="TTargetType">TTargetType</link> enumeration.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPDocFormat">
<short>FPDoc documentation output formats</short>
<descr>
<p>Enumeration defining the various output formats supported by the FPDoc documentation generator.
Each format represents a different way to present the generated documentation.</p>
<dl>
<dt>ffHtml</dt><dd> generates documentation in HTML format, creating web pages that can
be viewed in any web browser.</dd>
<dt>ffHtm</dt><dd> generates documentation in HTM format, an alternative HTML format
with .htm file extension. This format provides the same functionality as HTML
but uses the traditional 8.3 filename convention.</dd>
<dt>ffXHtml</dt><dd> generates documentation in XHTML format, a stricter XML-compliant
version of HTML.</dd>
<dt>ffLaTex</dt><dd> generates documentation in LaTeX format, suitable for producing
high-quality printed documentation. LaTeX output can be processed to create
PDF, PostScript, or DVI files with professional typesetting.</dd>
<dt>ffXMLStruct</dt><dd> generates documentation in structured XML format, providing
a machine-readable representation of the documentation data.</dd>
<dt>ffChm</dt><dd> generates documentation in Compressed HTML Help (CHM) format,
creating Windows Help files with full-text search capabilities.</dd>
</dl>
</descr>
<seealso>
<link id="TFPDocFormats"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffHtml">
<short>HTML format output</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffHtm">
<short>HTM format output</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffXHtml">
<short>XHTML format output</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffLaTex">
<short>LaTeX format output</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffXMLStruct">
<short>XML structured output</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPDocFormat.ffChm">
<short>Compressed HTML Help format</short>
</element>

<!-- set type Visibility: default -->
<element name="TFPDocFormats">
<short>Set of FPDoc formats</short>
<descr>
<p>A set type containing one or more values from the <link id="TFPDocFormat">TFPDocFormat</link> enumeration.
Allows specifying multiple documentation output formats to be generated simultaneously.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTargetState">
<short>Build target state during compilation</short>
<descr>
<p><var>TTargetState</var> is an enumeration type that tracks the current state of a build target during the compilation process.
Used to prevent duplicate processing and ensure correct build order dependencies. It has the following values:</p>
<dl>
<dt>tsNeutral</dt><dd> indicates that a build target has not yet been processed or evaluated
for compilation. This is the initial state of targets before build operations begin.</dd>
<dt>tsConsidering</dt><dd> indicates that a build target is currently being evaluated
for compilation. This intermediate state prevents infinite recursion during
dependency analysis.</dd>
<dt>tsNoCompile</dt><dd> indicates that a build target should be excluded from compilation.
This state is used for targets that are not applicable to the current build
configuration or platform.</dd>
<dt>tsCompiled</dt><dd> indicates that a build target has been successfully compiled.
Targets in this state have completed the compilation phase and are ready for
installation or further processing.</dd>
<dt>tsInstalled</dt><dd> indicates that a build target has been successfully installed
to its destination location. This represents the final successful state in
the build and installation process.</dd>
<dt>tsNotFound</dt><dd> indicates that the source file for a build target could not be located.
This error state prevents compilation and signals missing or incorrectly
specified source files.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsNeutral">
<short>Neutral state, not yet processed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsConsidering">
<short>Being considered for compilation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsNoCompile">
<short>Should not be compiled</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsCompiled">
<short>Successfully compiled</short>

</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsInstalled">
<short>Successfully installed</short>

</element>

<!-- enumeration value Visibility: default -->
<element name="TTargetState.tsNotFound">
<short>Target file not found</short>

</element>

<!-- set type Visibility: default -->
<element name="TTargetStates">
<short>Set of target states</short>
<descr>
<p>A set type containing one or more values from the <link id="TTargetState">TTargetState</link> enumeration.
Used for filtering or checking multiple target states in batch operations.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TSourceType">
<short>Source file type classification</short>
<descr>
<p>Enumeration that classifies source files according to their type and role in the compilation process.
Determines how each source file should be processed during building.</p>
<dl>
<dt>stDoc</dt><dd> represents documentation source files, typically XML files used by FPDoc
to generate formatted documentation. These files are processed separately from
regular source code compilation.</dd>
<dt>stSrc</dt><dd> represents Pascal source code files (.pas, .pp) that contain
program or unit implementations. These files undergo normal compilation
processing by the Free Pascal Compiler.</dd>
<dt>stTest</dt><dd> represents test source files that contain unit tests or test programs
for validating package functionality. These files are compiled and executed
as part of the testing process.</dd>
<dt>stExample</dt><dd> represents example or demonstration source files that showcase
package functionality. These files are typically compiled separately and may
have different installation rules than regular package sources.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSourceType.stDoc">
<short>Documentation source file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSourceType.stSrc">
<short>Pascal source code file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSourceType.stExample">
<short>Example source file</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSourceType.stTest">
<short>Test source file</short>
</element>

<!-- set type Visibility: default -->
<element name="TSourceTypes">
<short>Set of source types</short>
<descr>
<p>A set type containing one or more values from the <link id="TSourceType">TSourceType</link> enumeration.
Used to specify multiple source file types for filtering or processing operations.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TVerboseLevel">
<short>Verbosity level for build output</short>
<descr>
<p>Enumeration that controls the amount of information displayed during build operations.
Higher verbosity levels include all messages from lower levels plus additional detail.</p>
<dl>
<dt>vlError</dt><dd> specifies the lowest verbosity level, showing only critical error messages.
This level provides minimal output, displaying only messages that indicate
serious problems or failures.</dd>
<dt>vlWarning</dt><dd> displays warning messages.
This level shows potential problems and issues that may not prevent
compilation but could affect the build process.</dd>
<dt>vlInfo</dt><dd> displays general informational messages about the build process,
including warnings and errors. This level provides feedback about what
operations are being performed during compilation and installation.</dd>
<dt>vldebug</dt><dd> displays detailed debug information for troubleshooting build issues.
This level provides extensive output including internal operations, variable
values, and detailed execution flow information.</dd>
<dt>vlCommand</dt><dd> displays the actual commands being executed during the build process.
This level shows compiler invocations, tool executions, and system commands,
enabling verification and debugging of build operations.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TVerboseLevel.vlError">
<short>Display only error messages</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TVerboseLevel.vlWarning">
<short>Display warning and error messages</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TVerboseLevel.vlInfo">
<short>Display informational messages</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TVerboseLevel.vldebug">
<short>Display debug messages</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TVerboseLevel.vlCommand">
<short>Display executed commands</short>
</element>

<!-- set type Visibility: default -->
<element name="TVerboseLevels">
<short>Set of verbose levels</short>
<descr>
<p>A set type containing one or more values from the <link id="TVerboseLevel">TVerboseLevel</link> enumeration.
Allows combining multiple verbosity levels for custom output filtering.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCommandAt">
<short>Command execution timing specification</short>
<descr>
<p>Enumeration that specifies when a custom command should be executed during the build process.
Determines the phase at which user-defined commands are run relative to compilation steps.</p>
<dl>
<dt>caBeforeCompile</dt><dd> specifies that a custom command should be executed before
the compilation phase begins.</dd>
<dt>caAfterCompile</dt><dd> specifies that a custom command should be executed after
compilation completes successfully.</dd>
<dt>caBeforeInstall</dt><dd> specifies that a custom command should be executed before
the installation phase begins.</dd>
<dt>caAfterInstall</dt><dd> specifies that a custom command should be executed after
installation completes successfully.</dd>
<dt>caBeforeArchive</dt><dd> specifies that a custom command should be executed before
archive creation begins.</dd>
<dt>caAfterArchive</dt><dd> specifies that a custom command should be executed after
archive creation completes.</dd>
<dt>caBeforeClean</dt><dd> specifies that a custom command should be executed before
the clean operation begins.</dd>
<dt>caAfterClean</dt><dd> specifies that a custom command should be executed after
the clean operation completes.</dd>
<dt>caBeforeDownload</dt><dd> specifies that a custom command should be executed before
download operations begin.</dd>
<dt>caAfterDownload</dt><dd> specifies that a custom command should be executed after
download operations complete successfully.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caBeforeCompile">
<short>Execute command before compilation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caAfterCompile">
<short>Execute command after compilation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caBeforeInstall">
<short>Execute command before installation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caAfterInstall">
<short>Execute command after installation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caBeforeArchive">
<short>Execute command before archive creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caAfterArchive">
<short>Execute command after archive creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caBeforeClean">
<short>Execute command before cleaning</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caAfterClean">
<short>Execute command after cleaning</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caBeforeDownload">
<short>Execute command before downloading</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCommandAt.caAfterDownload">
<short>Execute command after downloading</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TDependencyType">
<short>Types of dependencies supported by the build system</short>
<descr>

<p><var>TDependencyType</var> specifies the different kinds of dependencies that can be declared
in the fpmake build system. Each type affects how the dependency is resolved and processed.</p>
<dl>
<dt>depPackage</dt><dd> indicates a dependency on another complete package.
This type ensures the referenced package is available and properly compiled
before building the current package.</dd>
<dt>depImplicitPackage</dt><dd> indicates an automatic dependency on another package
that is discovered through code analysis. These dependencies are typically
detected automatically without explicit declaration.</dd>
<dt>depUnit</dt><dd> indicates a dependency on a specific Pascal unit.
This type ensures the referenced unit is compiled and available
before compiling units that use it.</dd>
<dt>depInclude</dt><dd> indicates a dependency on an include file (.inc, .pas files)
that is incorporated into source code using the {$I} directive.
Ensures include files are available during compilation.</dd>
</dl>
</descr>
<seealso>
<link id="TDependency">TDependency</link>
<link id="TDependencyTypes">TDependencyTypes</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TDependencyType.depPackage">
<short>Dependency on another package</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TDependencyType.depImplicitPackage">
<short>Implicit dependency on another package</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TDependencyType.depUnit">
<short>Dependency on a specific unit</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TDependencyType.depInclude">
<short>Dependency on an include file</short>
</element>

<!-- set type Visibility: default -->
<element name="TDependencyTypes">
<short>Set of dependency types</short>
<descr>
<p>A set type containing one or more values from the <link id="TDependencyType">TDependencyType</link> enumeration.
Used to specify multiple dependency types when filtering or processing package dependencies.</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TLogEvent">
<short>Event procedure for logging messages</short>
<descr>
<p>Procedure type used for handling logging messages in the build system.
Implemented by applications to receive and process log messages with specified verbosity levels.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TLogEvent.Level">
<short>Logging level for the message</short>
<descr>
<p><var>Level</var> parameter specifies the verbosity level of the log message,
determining whether the message should be displayed based on current
logging configuration and filtering settings.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TLogEvent.Msg">
<short>Log message text</short>
<descr>
<p><var>Msg</var> parameter contains the actual text content of the log message
to be displayed or processed by the logging system. This string contains
the formatted message text.</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TNotifyProcEvent">
<short>Procedure type for notification events</short>
<descr>
<p>Procedure type used for simple notification callbacks in the build system.
Provides a sender parameter to identify the object that triggered the notification.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyProcEvent.Sender">
<short>Object that triggered the notification</short>
<descr>
<p><var>Sender</var> parameter identifies the object that initiated the notification event.
This allows event handlers to determine the source of the notification and
take appropriate action based on the sender type.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TRunMode">
<short>Build system execution modes</short>
<descr>
<p>Enumeration that defines the different run (operation) modes available in the build system.
Determines what actions are performed when the build system is executed.</p>
<dl>
<dt>rmCompile</dt><dd> specifies that the build system should only compile source files
without performing installation or packaging operations. This mode produces
compiled units and executables in the build directory.</dd>
<dt>rmBuild</dt><dd> specifies that the build system should compile source files and
perform linking operations to create final executables and libraries.
This mode produces complete build artifacts ready for installation.</dd>
<dt>rmInstall</dt><dd> specifies that the build system should install compiled files
to their target locations in the system. This mode performs both building
and installation of package components.</dd>
<dt>rmBuildInstall</dt><dd> specifies that the build system should perform both compilation
and installation operations in a single step. This mode combines building
and installing for convenient package deployment.</dd>
<dt>rmArchive</dt><dd> specifies that the build system should create distribution archives
(.zip, .tar) containing package sources and compiled files. This mode prepares
packages for distribution and deployment.</dd>
<dt>rmClean</dt><dd> specifies that the build system should remove generated files
such as compiled units, object files, and executables. This mode cleans
the build environment for a fresh compilation.</dd>
<dt>rmDistClean</dt><dd> specifies that the build system should perform a thorough cleanup,
removing all generated files, directories, and build artifacts. This mode
returns the package to its original source-only state.</dd>
<dt>rmManifest</dt><dd> specifies that the build system should generate a package
manifest file listing all package components, dependencies, and metadata.
This mode creates documentation of package contents.</dd>
<dt>rmZipInstall</dt><dd> specifies that the build system should install a package
from a ZIP archive. This mode extracts and installs pre-packaged
distribution files.</dd>
<dt>rmPkgList</dt><dd> specifies that the build system should display a list of available
packages in the system. This mode provides information about installable
and installed packages.</dd>
<dt>rmUnInstall</dt><dd> specifies that the build system should remove previously
installed package files from the system. This mode performs cleanup
of installed package components.</dd>
<dt>rmDocProject</dt><dd> specifies that the build system should generate documentation
project files for use with FPDoc or other documentation tools. This mode
creates configuration files for documentation generation.</dd>
<dt>rmInfo</dt><dd> specifies that the build system should display detailed information
about a package, including version, dependencies, targets, and configuration.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmCompile">
<short>Compile mode - only compile sources</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmBuild">
<short>Build mode - compile and link</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmInstall">
<short>Install mode - install files</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmBuildInstall">
<short>Build and install mode</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmArchive">
<short>Archive mode - create distribution archive</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmClean">
<short>Clean mode - remove generated files</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmDistClean">
<short>Distribution clean mode - remove all generated files and directories</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmManifest">
<short>Generate package manifest file</short>
</element>

<element name="TRunMode.rmUnInstall">
<short>Uninstall mode - remove installed package files</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmZipInstall">
<short>Install package from ZIP archive</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmPkgList">
<short>List available packages</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmInfo">
<short>Information mode - display package information</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRunMode.rmDocProject">
<short>Generate documentation project file</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TBuildMode">
<short>Build execution modes for package compilation</short>
<descr>
<p><var>TBuildMode</var> specifies how the build process should execute package compilation:</p>
<dl>
<dt>bmOneByOne</dt><dd> specifies that build targets should be compiled sequentially,
one after another. This mode relies on proper dependency specification.</dd>
<dt>bmBuildUnit</dt><dd> specifies that individual Pascal units should not be compiled
separately. Rather they are compiled as part of a larger unit compilation: the build unit.</dd>
</dl>
</descr>
<seealso>
<link id="TCustomDefaults.BuildMode"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuildMode.bmOneByOne">
<short>Build targets one by one sequentially</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuildMode.bmBuildUnit">
<short>Use a build unit</short>
</element>

<!-- set type Visibility: default -->
<element name="TBuildModes">
<short>Set of build execution modes</short>
<descr>
<p>Set containing one or more <link id="TBuildMode">TBuildMode</link> values.</p>
<p>Used to specify multiple build modes.</p>
</descr>
<seealso>
<link id="TBuildMode">TBuildMode</link>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TProcessPackageResult">
<short>Result codes for package processing operations</short>
<descr>
<p><var>TProcessPackageResult</var> indicates the outcome of package processing operations.</p>
<p>Used to communicate success, failure, or special handling conditions during package operations.</p>
<dl>
<dt>ppHandled</dt><dd> indicates that the package processing operation completed
successfully and all required actions were performed. This result signals
successful completion of the package operation.</dd>
<dt>ppDelayed</dt><dd> indicates that the package processing operation has been delayed
and will be executed at a later time. This result is used for dependency
ordering or deferred processing scenarios.</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TProcessPackageResult.ppHandled">
<short>Package was successfully processed and handled</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TProcessPackageResult.ppDelayed">
<short>Package processing was delayed for later execution</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCheckDependencyResult">
<short>Result codes for dependency availability checking</short>
<descr>
<p><var>TCheckDependencyResult</var> indicates the status of dependency availability checks.</p>
<p>Used to determine whether required dependencies are available for compilation.</p>
<dl>
<dt>cdAvailable</dt><dd> indicates that the required dependency is present in the system
and can be used for compilation. This result allows the build process to proceed.</dd>
<dt>cdNotAvailable</dt><dd> indicates that the required dependency cannot be found
in the system and is not available for use. This result prevents the build
process from proceeding due to missing dependencies.</dd>
<dt>cdNotYetAvailable</dt><dd> indicates that the dependency is not currently available
but will become available after other dependencies are built or installed</dd>
</dl>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCheckDependencyResult.cdAvailable">
<short>Dependency is available and can be used</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCheckDependencyResult.cdNotAvailable">
<short>Dependency is not available and cannot be found</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCheckDependencyResult.cdNotYetAvailable">
<short>Dependency is not yet available but may become available later</short>
</element>

<!-- record type Visibility: default -->
<element name="TCompileTarget">
<short>Record type representing a compilation target</short>
<descr>
<p>Record that defines the target platform for compilation, specifying the operating system, CPU architecture,
and optional subtarget. Used to identify the specific platform configuration for cross-compilation.</p>
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TCompileTarget.OS">
<short>Target operating system</short>
<descr>
<p><var>OS</var> field specifies the target operating system for compilation.
This field contains a value from the <link id="TOS">TOS</link> enumeration
identifying the specific operating system platform.</p>
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TCompileTarget.CPU">
<short>Target CPU architecture</short>
<descr>
<p><var>CPU</var> field specifies the target CPU architecture for compilation.
This field contains a value from the <link id="TCpu">TCpu</link> enumeration
identifying the specific processor architecture.</p>
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TCompileTarget.Subtarget">
<short>Subtarget identifier string</short>
<descr>
<p><var>Subtarget</var> field specifies an optional subtarget identifier for
specialized compilation variants. This string provides additional
platform-specific configuration information.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCompileTarget.Equals">
<short>Compares two compile targets for equality</short>
<descr>
<p>Returns <var>True</var> if this compile target equals the specified target.</p>
<p>Comparison is based on CPU, OS, and subtarget values.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCompileTarget.Equals.Result">
<short><var>True</var> if targets are equal, <var>False</var> otherwise</short>
<descr>
<p><var>Result</var> returns <var>True</var> if the compile targets have identical
OS, CPU, and Subtarget values, <var>False</var> if any field differs.
Used for compile target comparison operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCompileTarget.Equals.aValue">
<short>Compile target to compare with</short>
<descr>
<p><var>aValue</var> parameter specifies the compile target to compare with the current
target. This parameter should contain the OS, CPU, and Subtarget values
for comparison against the current compile target.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCompileTarget.ToString">
<short>Converts compile target to string representation</short>
<descr>
<p>Returns a string representation of the compile target showing CPU, OS, and subtarget.</p>
<p>Optionally limits the string length for compatibility with older systems.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCompileTarget.ToString.Result">
<short>String representation of the compile target</short>
<descr>
<p><var>Result</var> returns a formatted string containing the compile target information.
The string format shows CPU and OS identifiers, optionally formatted for
8.3 filename compatibility when requested.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCompileTarget.ToString.aLimit83">
<short>Whether to limit filename to 8.3 format</short>
<descr>
<p><var>aLimit83</var> parameter specifies whether the returned string should be
limited to 8.3 filename format for compatibility with older file systems.
When <var>True</var>, the string is truncated to meet DOS filename constraints.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCompileTarget.AsString">
<short>String representation of the compile target</short>
<descr>
<p>Returns a string representation of the compile target containing CPU and OS information.</p>
<p>Used for display, logging, and configuration purposes during build operations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="Amd64">
<short>AMD64/x86_64 CPU architecture identifier</short>
<descr>
<p>Constant representing the AMD64/x86_64 CPU architecture in the FPMake build system.
This 64-bit architecture is commonly used on modern desktop and server systems from both AMD and Intel,
providing extended memory addressing capabilities and improved performance over 32-bit architectures.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PPC">
<short>PowerPC 32-bit CPU architecture identifier</short>
<descr>
<p>Represents the PowerPC 32-bit architecture in the FPMake build system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PPC64">
<short>PowerPC 64-bit CPU architecture identifier</short>
<descr>
<p>Represents the PowerPC 64-bit architecture in the FPMake build system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DOS">
<short>DOS operating system identifier</short>
<descr>
<p>Represents the DOS operating system in the FPMake build system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="MacOSX">
<short>macOS operating system identifier</short>
<descr>
<p>Represents the macOS (formerly Mac OS X) operating system in the FPMake build system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllOSes">
<short>Set containing all supported operating systems</short>
<descr>
<p>A predefined set that includes all operating systems supported by the Free Pascal Compiler. This constant is used for targets that should be compiled for all available platforms.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllCPUs">
<short>Set containing all supported CPU architectures</short>
<descr>
<p>Constant set containing all CPU architectures supported by the Free Pascal Compiler.
Used for platform-independent operations or when checking CPU compatibility across all architectures.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllUnixOSes">
<short>Set containing all Unix-like operating systems</short>
<descr>
<p>Constant set containing all operating systems that follow Unix conventions and standards.
Includes Linux, BSD variants, and other POSIX-compatible systems.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllBSDOSes">
<short>Set containing all BSD operating systems</short>
<descr>
<p>Constant set containing all Berkeley Software Distribution (BSD) operating system variants.
Includes FreeBSD, OpenBSD, NetBSD, and Darwin/macOS.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllWindowsOSes">
<short>Set containing all Windows operating systems</short>
<descr>
<p>Constant set containing all Microsoft Windows operating system versions supported by Free Pascal.
Includes desktop and server editions across different Windows generations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllAmigaLikeOSes">
<short>Set containing all Amiga-like operating systems</short>
<descr>
<p>Constant set containing operating systems that are compatible with or derived from AmigaOS.
Includes classic AmigaOS and modern Amiga-compatible systems.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllLimit83fsOses">
<short>Set containing OSes with 8.3 filename limitations</short>
<descr>
<p>Constant set containing operating systems that enforce the traditional 8.3 filename format limitation.
Used to determine when filenames need to be truncated or adjusted for compatibility.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllSmartLinkLibraryOSes">
<short>Set containing OSes supporting smart-linked libraries</short>
<descr>
<p>Constant set containing operating systems that support smart linking of libraries.
Smart linking allows the linker to include only used symbols, reducing executable size.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllImportLibraryOSes">
<short>Set containing OSes requiring import libraries</short>
<descr>
<p>Constant set containing operating systems that require import libraries for dynamic linking.
Import libraries contain stubs for symbols exported from dynamic libraries.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="OSCPUSupported">
<short>Matrix of supported OS/CPU combinations</short>
<descr>
<p>Two-dimensional array that defines which CPU architectures are supported for each operating system.
Used to validate target platform combinations before attempting compilation.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="UnitExt">
<short>Pascal unit file extension</short>
<descr>
<p>Constant defining the standard file extension for Free Pascal unit source files ('.pas').
This extension is used by the FPMake system to identify and process unit source files
during compilation and package building operations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PPUExt">
<short>Pascal compiled unit file extension</short>
<descr>
<p>Constant defining the file extension for Free Pascal compiled unit files ('.ppu').
These binary files contain the compiled interface and implementation of Pascal units,
allowing for separate compilation and linking in the FPMake build process.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PasExt">
<short>Pascal source file extension</short>
<descr>
<p>Constant defining the standard file extension for Pascal source files ('.pas').
Used to identify Pascal source files in package building and compilation operations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PPExt">
<short>Pascal program file extension</short>
<descr>
<p>Constant defining the file extension for Pascal program files ('.pp').
Designates main program files that contain an executable program rather than a unit.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="IncExt">
<short>Pascal include file extension</short>
<descr>
<p>Constant defining the file extension for Pascal include files ('.inc').
These files contain source code that is included into other Pascal files using include directives.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ObjExt">
<short>Object file extension</short>
<descr>
<p>Constant defining the file extension for compiled object files.
Object files contain machine code generated from source compilation and are linked together to create executables.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LTOExt">
<short>Link Time Optimization file extension</short>
<descr>
<p>Constant defining the file extension for Link Time Optimization intermediate files.
These files contain optimization information used during the linking phase to improve final executable performance.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="RstExt">
<short>Resource string file extension</short>
<descr>
<p>Constant defining the file extension for resource string files ('.rst').
These files contain compiled resource strings extracted from Pascal source files for localization and internationalization.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="RsjExt">
<short>Resource string JSON file extension</short>
<descr>
<p>Constant defining the file extension for resourcestring files in JSON format ('.rsj').
These files store resource strings in JSON format for localization and internationalization.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LibExt">
<short>Static library file extension</short>
<descr>
<p>Constant defining the file extension for static library files.
Static libraries contain precompiled object code that is linked directly into executables at compile time.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="SharedLibExt">
<short>Shared library file extension</short>
<descr>
<p>Constant defining the platform-specific file extension for shared/dynamic libraries.
Shared libraries are loaded at runtime and can be shared between multiple executables.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="WasiSharedLibExt">
<short>WASI shared library file extension</short>
<descr>
<p>Constant defining the file extension for WASI (WebAssembly System Interface) shared libraries.
Used for WebAssembly modules that implement shared library functionality.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DyLibExt">
<short>Dynamic library file extension (macOS)</short>
<descr>
<p>Constant defining the file extension for dynamic libraries on macOS ('.dylib').
These libraries provide shared functionality on Apple platforms and are loaded at runtime.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DLLExt">
<short>Dynamic link library file extension</short>
<descr>
<p>Constant defining the file extension for Dynamic Link Libraries on Windows ('.dll').
DLLs contain code and resources that can be used by multiple programs simultaneously.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AIXSharedLibExt">
<short>AIX shared library file extension</short>
<descr>
<p>Constant defining the file extension for shared libraries on IBM AIX systems.
AIX uses specific conventions for shared library naming and loading.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ExeExt">
<short>Executable file extension</short>
<descr>
<p>Constant defining the platform-specific file extension for executable files.
On Windows this is '.exe', while Unix-like systems typically use no extension.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="WasiExeExt">
<short>WASI executable file extension</short>
<descr>
<p>Constant defining the file extension for WASI (WebAssembly System Interface) executable files.
Used for WebAssembly modules that can be executed as standalone applications.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DbgExt">
<short>Debug information file extension</short>
<descr>
<p>Constant defining the file extension for debug information files.
These files contain debugging symbols and information for debugger support.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ZipExt">
<short>ZIP archive file extension</short>
<descr>
<p>Constant defining the file extension for ZIP archive files ('.zip').
Used for creating and identifying package distribution archives in the fpmake system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="FpmkExt">
<short>FPMake script file extension</short>
<descr>
<p>Constant defining the file extension for FPMake build script files ('.fpmk').
These files contain build configuration and packaging instructions for Free Pascal projects.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="FPMakePPFile">
<short>FPMake Pascal program filename</short>
<descr>
<p>Constant defining the standard filename for FPMake Pascal program files ('fpmake.pp').
This is the default name for the main build script file in Free Pascal packages.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ManifestFile">
<short>Package manifest filename</short>
<descr>
<p>Constant defining the filename for package manifest files.
Manifest files contain metadata about package contents, dependencies, and installation requirements.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DocProjectFileExt">
<short>Documentation project file extension</short>
<descr>
<p>Constant defining the file extension for FPDoc documentation project files.
These files configure how documentation is generated from source code comments.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PkgListFileBase">
<short>Package list filename base</short>
<descr>
<p>Constant defining the base name for package list files used by the package management system.
Combined with extensions to create complete package list filenames.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="PkgListFileExt">
<short>Package list file extension</short>
<descr>
<p>Constant defining the file extension for package list files.
These files contain lists of available packages and their metadata.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DirNotFound">
<short>Directory not found error constant</short>
<descr>
<p>Constant representing the error code returned when a directory cannot be found.
Used for consistent error handling in directory operations throughout the build system.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="UnitTargets">
<short>Set of unit target types</short>
<descr>
<p>Constant set containing all target types that represent Pascal units.
Used to filter and identify unit targets in build operations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ProgramTargets">
<short>Set of program target types</short>
<descr>
<p>Constant set containing all target types that represent executable programs.
Used to filter and identify program targets in build operations.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="DefaultMessages">
<short>Default message verbosity levels</short>
<descr>
<p>Constant set defining the default verbosity levels for build system messages.
Includes error and warning messages that are typically displayed to users.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllMessages">
<short>All message verbosity levels</short>
<descr>
<p>Constant set containing all available message verbosity levels.
Includes debug, informational, warning, and error messages for complete logging.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TTargets">
<short>Collection class for managing build targets</short>
<descr>
<p><var>TTargets</var> is a collection class that manages multiple <link id="TTarget">TTarget</link> instances
within a package. It provides methods to add different types of targets such as units, programs,
libraries, and documentation targets.</p>
<p>The collection supports various convenience methods for adding specific target types
with optional CPU and OS restrictions, making it easy to create cross-platform build configurations.</p>
</descr>
<seealso>
<link id="TTarget">TTarget</link>
<link id="TTargetEnumerator">TTargetEnumerator</link>
<link id="TPackage">TPackage</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TBuildEngine">
<short>Main build engine for compiling and installing packages</short>
<descr>
<p><var>TBuildEngine</var> is the central component that orchestrates the entire build process for fpmake packages.
It manages compilation, dependency resolution, file operations, and installation procedures.</p>
<p>The build engine provides the following functionality:</p>
<ul>
<li>Package compilation with dependency resolution</li>
<li>Cross-platform build support</li>
<li>File operations (copy, move, delete, archive)</li>
<li>Installation and uninstallation procedures</li>
<li>Clean and archive operations</li>
<li>Multi-threaded compilation support</li>
<li>Command execution and logging</li>
</ul>
<p>The engine works with <link id="TPackage">TPackage</link> objects to compile targets,
resolve dependencies, and manage the entire build lifecycle from compilation through installation.</p>
</descr>
<seealso>
<link id="TPackage">TPackage</link>
<link id="TTarget">TTarget</link>
<link id="TCustomDefaults">TCustomDefaults</link>
<link id="TCustomInstaller">TCustomInstaller</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TNamedItem">
<short>Base class for items with a name property</short>
<descr>
<p>Abstract base class that provides a <var>Name</var> property for objects that need to be identified by name.
Serves as the foundation for many fpmake objects that require named identification.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNamedItem.Name">
<short>Name of the item</short>
<descr>
<p>String property that stores the unique name identifier for this item.
Used for lookups, references, and display purposes throughout the build system.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TNamedCollection">
<short>Collection class for managing named items</short>
<descr>
<p>Generic collection class that manages a list of <link id="TNamedItem">TNamedItem</link> objects.
Provides name-based lookup functionality and ensures unique naming within the collection.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TNamedCollection.IndexOfName">
<short>Find index of item by name</short>
<descr>
<p>Searches for an item with the specified name in the collection and returns
its zero-based index. Returns -1 if no item with the given name is found.</p>
<p>This provides efficient name-based lookup for finding specific items in
named collections.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNamedCollection.IndexOfName.Result">
<short>Index of found item or -1 if not found</short>
<descr>
<p><var>Result</var> returns the zero-based index of the item with the specified name,
or -1 if no item with that name is found in the collection.
Used to determine if an item exists and locate it within the collection.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNamedCollection.IndexOfName.AName">
<short>Name to search for</short>
<descr>
<p><var>AName</var> parameter specifies the name of the item to search for in the collection.
The search is typically case-sensitive and matches the exact name string
of items in the collection.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TNamedCollection.ItemByName">
<short>Get item by name</short>
<descr>
<p>Retrieves an item from the collection by its name.
Returns the <link id="TNamedItem">TNamedItem</link> object if found, or <var>nil</var> if no item with the specified name exists.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNamedCollection.ItemByName.Result">
<short>Found item or nil if not found</short>
<descr>
<p><var>Result</var> returns the item with the specified name, or <var>nil</var> if no item
with that name exists in the collection. Provides direct access to collection
items by name rather than by index.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNamedCollection.ItemByName.AName">
<short>Name of item to retrieve</short>
<descr>
<p><var>AName</var> parameter specifies the name of the item to retrieve from the collection.
The name should match exactly with an item's name property to successfully
locate and return the item.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNamedCollection.UniqueNames">
<short>Controls whether item names must be unique</short>
<descr>
<p>Boolean property that determines whether the collection enforces unique naming.
When <var>True</var>, attempting to add an item with a duplicate name will raise an exception.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNamedCollection.Items">
<short>Indexed access to collection items</short>
<descr>
<p>Indexed property providing direct access to collection items by their zero-based index.
Allows reading and writing of <link id="TNamedItem">TNamedItem</link> objects at specific positions.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TNamedCollection.Items.Index">
<short>Item index</short>
<descr>
<p><var>Index</var> parameter specifies the zero-based index of the item to access
in the collection. Must be within the valid range (0 to Count-1) to avoid
range check errors when accessing collection items.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TNamedItemList">
<short>List class for managing named items</short>
<descr>
<p>Specialized list class that extends basic list functionality with name-based lookup capabilities.
Provides efficient access to <link id="TNamedItem">TNamedItem</link> objects by both index and name.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TNamedItemList.IndexOfName">
<short>Find index of named item</short>
<descr>
<p>Searches for an item with the specified name and returns its zero-based index in the list.
Returns -1 if no item with the given name is found.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNamedItemList.IndexOfName.Result">
<short>Index of found item or -1 if not found</short>
<descr>
<p><var>Result</var> returns the zero-based index of the named item in the list,
or -1 if no item with the specified name is found. Enables location-based
operations on named items within the list.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNamedItemList.IndexOfName.AName">
<short>Name to search for</short>
<descr>
<p><var>AName</var> parameter specifies the name of the item to locate in the list.
The search is performed by comparing this name against the Name property
of each item in the list.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TNamedItemList.ItemByName">
<short>Get named item by name</short>
<descr>
<p>Retrieves an item from the list by its name.
Returns the <link id="TNamedItem">TNamedItem</link> object if found, or <var>nil</var> if no item with the specified name exists.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNamedItemList.ItemByName.Result">
<short>Found named item or nil if not found</short>
<descr>
<p><var>Result</var> returns the <link id="TNamedItem">TNamedItem</link> object with the specified name,
or <var>nil</var> if no matching item is found in the list.
Provides direct object access for named item retrieval.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNamedItemList.ItemByName.ANAme">
<short>Name of item to retrieve</short>
<descr>
<p><var>ANAme</var> parameter specifies the name of the item to retrieve from the list.
This name is used to search through the list items and locate the matching
named item object.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNamedItemList.NamedItems">
<short>Indexed access to named items</short>
<descr>
<p>Property providing indexed access to <link id="TNamedItem">TNamedItem</link> objects by their name.
Allows retrieving items using string names as array indices.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TNamedItemList.NamedItems.Index">
<short>Item index</short>
<descr>
<p><var>Index</var> parameter specifies the zero-based index or name of the item
to access in the named items list. Can be either an integer index
or a string name for flexible item access.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TCommand">
<short>Represents a command to be executed during build</short>
<descr>
<p>Class that encapsulates a command to be executed at specific points during the build process.
Stores command information including the executable, arguments, and execution timing.</p>
</descr>
</element>

<!-- destructor Visibility: public -->
<element name="TCommand.Destroy">
<short>Destructor that cleans up command resources</short>
<descr>
<p>Destructor that releases memory and resources allocated by the command object.
Ensures proper cleanup of internal data structures.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCommand.HaveOptions">
<short>Check if command has any options</short>
<descr>
<p>Function that returns <var>True</var> if the command has any command-line options or arguments configured.
Used to determine if additional formatting is needed when building the command line.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCommand.HaveOptions.Result">
<short>True if command has options</short>
<descr>
<p><var>Result</var> returns <var>True</var> if the command has any options, arguments,
or parameters configured, <var>False</var> if the command has no additional
options beyond the base command executable.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCommand.CmdLineOptions">
<short>Get formatted command line options</short>
<descr>
<p>Function that builds and returns a formatted string containing all command-line options and arguments.
Used when constructing the final command line for execution.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCommand.CmdLineOptions.Result">
<short>Formatted command line options string</short>
<descr>
<p><var>Result</var> returns a properly formatted string containing all command-line
options and arguments for the command. This string is ready to be appended
to the base command for execution.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCommand.ParseOptions">
<short>Parse options from a string</short>
<descr>
<p>Procedure that parses command-line options from a string and stores them internally.
Breaks down the options string into individual arguments for later use in command execution.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCommand.ParseOptions.S">
<short>Options string to parse</short>
<descr>
<p><var>S</var> parameter contains the raw options string to be parsed into individual
command-line arguments. The string is split and processed to extract
individual options and parameters.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.SourceFile">
<short>Source file for the command</short>
<descr>
<p>Property specifying the source file that the command operates on.
Used for commands that process or transform specific files during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.DestFile">
<short>Destination file for the command</short>
<descr>
<p>Property specifying the destination file that the command produces or writes to.
Used for commands that generate output files during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.Command">
<short>Command line to execute</short>
<descr>
<p>Property containing the base command or executable name to be executed.
Combined with options and arguments to form the complete command line.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.Options">
<short>Command line options</short>
<descr>
<p>String list property containing command-line options and arguments.
Each item represents a separate command-line parameter or option.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.At">
<short>When to execute the command</short>
<descr>
<p>Property of type <link id="TCommandAt">TCommandAt</link> that specifies when during the build process this command should be executed.
Determines the execution timing relative to compilation, installation, or other build phases.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.IgnoreResult">
<short>Whether to ignore command execution result</short>
<descr>
<p>Boolean property that determines whether command execution failures should be ignored.
When <var>True</var>, the build process continues even if the command returns an error code.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.BeforeCommand">
<short>Command to execute before this command</short>
<descr>
<p>Property specifying another command that should be executed immediately before this command.
Allows chaining of command execution for complex build operations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCommand.AfterCommand">
<short>Command to execute after this command</short>
<descr>
<p>Property specifying another command that should be executed immediately after this command.
Allows chaining of command execution for complex build operations.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TCommandEnumerator">
<short>Enumerator for iterating through commands</short>
<descr>
<p>Enumerator class that enables for..in loop iteration over command collections.
Provides standard iterator interface for traversing <link id="TCommand">TCommand</link> objects.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCommandEnumerator.GetCurrent">
<short>Get current command in enumeration</short>
<descr>
<p>Function that returns the current <link id="TCommand">TCommand</link> object at the enumerator position.
Called by the for..in loop mechanism to access the current item.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCommandEnumerator.GetCurrent.Result">
<short>Current command in enumeration</short>
</element>

<!-- property Visibility: public -->
<element name="TCommandEnumerator.Current">
<short>Current command in enumeration</short>
<descr>
<p><var>Current</var> returns the current <link id="TCommand">TCommand</link> object in the enumeration sequence.</p>
<p>This property is used in for-in loops to access each command as the enumerator iterates through the collection.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TCommands">
<short>Collection of commands to execute during build</short>
<descr>
<p><var>TCommands</var> is a specialized collection class that manages a list of <link id="TCommand">TCommand</link> objects.</p>
<p>This class provides methods to add, remove, and iterate through build commands that should be executed during the package compilation process.</p>
<p>Commands are typically shell commands, compiler invocations, or other external tools needed for building packages.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCommands.AddCommand">
<short>Add a new command to the collection</short>
<descr>
<p>Creates and adds a new <var>TCommand</var> object to the commands collection.
The command can be configured with executable path, options, source and destination files,
and execution timing.</p>
<p>Commands are executed during the build process at the specified timing (before or after
compilation, installation, etc.).</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCommands.AddCommand.Result">
<short>Newly created command object</short>
</element>

<!-- argument Visibility: default -->
<element name="TCommands.AddCommand.Cmd">
<short>Command line executable to run</short>
</element>

<!-- argument Visibility: default -->
<element name="TCommands.AddCommand.Options">
<short>Command line options string</short>
</element>

<!-- argument Visibility: default -->
<element name="TCommands.AddCommand.Dest">
<short>Destination file path for command operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TCommands.AddCommand.Source">
<short>Source file path for command operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TCommands.AddCommand.At">
<short>When to execute the command during build process</short>
</element>

<!-- function Visibility: public -->
<element name="TCommands.GetEnumerator">
<short>Get enumerator for iterating commands</short>
<descr>
<p>Function that returns a <link id="TCommandEnumerator">TCommandEnumerator</link> object for iterating through the commands collection.
Enables the use of for..in loops to iterate over all commands in the collection.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCommands.GetEnumerator.Result">
<short>Command collection enumerator for iteration</short>
</element>

<!-- property Visibility: public -->
<element name="TCommands.CommandItems">
<short>Indexed access to command items</short>
<descr>
<p>Indexed property providing direct access to <link id="TCommand">TCommand</link> objects by their zero-based index.
Allows reading and writing of command objects at specific positions in the collection.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TCommands.CommandItems.Index">
<short>Zero-based index of command item</short>
</element>

<!-- property Visibility: public -->
<element name="TCommands.Commands">
<short>Access to commands by destination</short>
<descr>
<p>Property providing access to commands based on their destination file or path.
Allows retrieving commands that operate on specific destination targets.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TCommands.Commands.Dest">
<short>Destination path for command execution</short>
</element>

<!-- property Visibility: public -->
<element name="TCommands.DefaultAt">
<short>Default execution timing for commands</short>
<descr>
<p>Property specifying the default <link id="TCommandAt">TCommandAt</link> timing for newly created commands.
Used when no explicit execution timing is specified for new commands.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPVersion">
<short>Represents a Free Pascal version number</short>
<descr>
<p>Class that encapsulates a Free Pascal version number with major, minor, micro, and build components.
Provides methods for version comparison, parsing from strings, and formatting to strings.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPVersion.Clear">
<short>Clear the version number to empty state</short>
<descr>
<p>Procedure that resets all version number components (major, minor, micro, build) to zero.
Returns the version object to an empty, uninitialized state.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPVersion.Assign">
<short>Assign version from another source</short>
<descr>
<p>Procedure that copies version information from another <link id="TFPVersion">TFPVersion</link> object or compatible source.
Allows cloning or copying version data between version objects.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPVersion.Assign.Source">
<short>Source version object to assign from</short>
</element>

<!-- function Visibility: public -->
<element name="TFPVersion.CompareVersion">
<short>Compare this version with another version</short>
<descr>
<p><var>CompareVersion</var> performs a numerical comparison between this version object and another version.</p>
<p>The comparison follows semantic versioning rules, comparing major, minor, micro, and build numbers in sequence.</p>
<p>Returns a negative value if this version is older, zero if versions are equal, or positive if this version is newer.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPVersion.CompareVersion.Result">
<short>Comparison result: negative, zero, or positive integer</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPVersion.CompareVersion.AVersion">
<short>Version object to compare against</short>
</element>

<!-- function Visibility: public -->
<element name="TFPVersion.SameVersion">
<short>Check if versions are identical</short>
<descr>
<p><var>SameVersion</var> returns <var>True</var> if this version is exactly identical to the specified version.</p>
<p>This method performs an exact comparison of all version components including major, minor, micro, and build numbers.</p>
<p>Unlike <link id="TFPVersion.CompareVersion">CompareVersion</link>, this method returns a boolean result rather than a comparison integer.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPVersion.SameVersion.Result">
<short><var>True</var> if versions are identical, <var>False</var> otherwise</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPVersion.SameVersion.AVersion">
<short>Version object to compare for equality</short>
</element>

<!-- property Visibility: public -->
<element name="TFPVersion.AsString">
<short>Version number as formatted string</short>
<descr>
<p><var>AsString</var> returns the version number formatted as a human-readable string in the format "major.minor.micro.build".</p>
<p>Empty version components are omitted from the string representation, so version 1.2.0.0 appears as "1.2".</p>
<p>This property is commonly used for display purposes and version comparison logging.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPVersion.Empty">
<short>Whether the version number is empty</short>
<descr>
<p><var>Empty</var> returns <var>True</var> if all version number components (major, minor, micro, build) are zero.</p>
<p>This property is useful for checking whether a version has been properly initialized or represents a valid version number.</p>
<p>An empty version typically indicates an unset or invalid version state.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPVersion.Major">
<short>Major version number</short>
<descr>
<p><var>Major</var> specifies the major version component, representing significant API changes or major releases.</p>
<p>In semantic versioning, major version increments indicate breaking changes or incompatible API modifications.</p>
<p>This value must be a non-negative integer and is the most significant component in version comparison.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPVersion.Minor">
<short>Minor version number</short>
<descr>
<p><var>Minor</var> represents the minor version component, indicating backwards-compatible functionality additions.</p>
<p>In semantic versioning, minor version increments signal new features that maintain API compatibility.</p>
<p>This value must be a non-negative integer and is compared after major version in version ordering.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPVersion.Micro">
<short>Micro version number</short>
<descr>
<p><var>Micro</var> represents the micro (or patch) version component for backwards-compatible bug fixes.</p>
<p>In semantic versioning, micro version increments indicate bug fixes and small improvements without API changes.</p>
<p>This value must be a non-negative integer and is the least significant component in standard version comparison.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPVersion.Build">
<short>Build version number</short>
<descr>
<p><var>Build</var> represents the build version component for distinguishing different builds of the same version.</p>
<p>Build numbers are typically used for internal tracking, nightly builds, or continuous integration systems.</p>
<p>This value must be a non-negative integer and is usually the least significant component in extended version comparison.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TConditionalString">
<short>String value with CPU and OS conditions</short>
<descr>
<p><var>TConditionalString</var> represents a string value that can be conditionally applied
based on target CPU architecture and operating system. This enables platform-specific
configuration in build scripts.</p>
<p>The class provides matching functionality to determine if the string applies to a specific
CPU/OS combination, making it the foundation for cross-platform build support.</p>
</descr>
<seealso>
<link id="TConditionalStrings">TConditionalStrings</link>
<link id="TCpu">TCpu</link>
<link id="TOS">TOS</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TConditionalString.Assign">
<short>Assign conditional string from another source</short>
<descr>
<p><var>Assign</var> copies all properties from another <link id="TConditionalString">TConditionalString</link> object to this instance.</p>
<p>This includes the string value, CPU conditions, OS conditions, and any other conditional criteria.</p>
<p>The method provides a complete deep copy of the conditional string configuration.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalString.Assign.aSource">
<short>Source conditional string to copy from</short>
</element>

<!-- function Visibility: public -->
<element name="TConditionalString.Match">
<short>Check if string matches given CPU and OS</short>
<descr>
<p><var>Match</var> evaluates whether this conditional string applies to the specified CPU architecture and operating system.</p>
<p>The method returns <var>True</var> if the string's conditions match the provided platform parameters.</p>
<p>This is the core functionality that enables platform-specific string selection in build configurations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TConditionalString.Match.Result">
<short><var>True</var> if string matches the platform criteria</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalString.Match.aCPU">
<short>CPU architecture to check against</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalString.Match.aOS">
<short>Operating system to check against</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalString.Match.aValue">
<short>Optional string value to match against</short>
</element>

<!-- property Visibility: public -->
<element name="TConditionalString.Value">
<short>String value for this condition</short>
<descr>
<p><var>Value</var> contains the actual string content that is used when the conditional criteria are met.</p>
<p>This property stores the string that will be returned or applied when the CPU and OS conditions match the target platform.</p>
<p>The value can contain any string content including file paths, compiler options, or configuration parameters.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TConditionalString.OSes">
<short>Operating systems for which this string applies</short>
<descr>
<p><var>OSes</var> specifies the set of operating systems for which this conditional string is applicable.</p>
<p>This property contains a list of <link id="TOS">TOS</link> values that define the target operating systems.</p>
<p>If empty, the string applies to all operating systems, otherwise it only applies to the specified OS platforms.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TConditionalString.CPUs">
<short>CPU architectures for which this string applies</short>
<descr>
<p><var>CPUs</var> specifies the set of CPU architectures for which this conditional string is applicable.</p>
<p>This property contains a list of <link id="TCpu">TCpu</link> values that define the target processor architectures.</p>
<p>If empty, the string applies to all CPU architectures, otherwise it only applies to the specified processor types.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TConditionalStringClass">
<short>Class reference type for conditional string classes</short>
<descr>
<p><var>TConditionalStringClass</var> is a class reference type that points to <link id="TConditionalString">TConditionalString</link> or its descendant classes.</p>
<p>This type is used in factory methods and class registration systems to create conditional string instances dynamically.</p>
<p>It enables polymorphic creation of different conditional string implementations at runtime.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TConditionalStrings">
<short>Collection of conditional string values</short>
<descr>
<p><var>TConditionalStrings</var> is a specialized collection that manages multiple <link id="TConditionalString">TConditionalString</link> objects.</p>
<p>This class provides methods for adding, searching, and retrieving conditional strings based on platform criteria.</p>
<p>It enables efficient management of platform-specific configuration values in build systems.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TConditionalStrings.AddList">
<short>Add multiple conditional strings from list</short>
<descr>
<p>Adds multiple conditional strings to the collection from the provided list.
Each string is added with default platform conditions (all CPUs and OSes).</p>
<p>This is a convenience method for bulk adding strings when individual platform
restrictions are not needed.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.AddList.aList">
<short>String list containing values to add</short>
</element>

<!-- function Visibility: public -->
<element name="TConditionalStrings.IndexOf">
<short>Find index of conditional string matching criteria</short>
<descr>
<p><var>IndexOf</var> searches the collection for a conditional string that matches the specified platform criteria.</p>
<p>Returns the zero-based index of the first matching conditional string, or -1 if no match is found.</p>
<p>The search compares CPU architecture, operating system, and optionally string value to find matching entries.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TConditionalStrings.IndexOf.Result">
<short>Index of found string or -1 if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.IndexOf.Value">
<short>String value to search for</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.IndexOf.aCPU">
<short>CPU architecture to match in search</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.IndexOf.aOS">
<short>Operating system to match in search</short>
</element>

<!-- function Visibility: public -->
<element name="TConditionalStrings.Find">
<short>Find conditional string matching criteria</short>
<descr>
<p>Searches for a conditional string that matches the specified value and platform
criteria (CPU and OS). Returns the index of the first matching item or -1 if
no match is found.</p>
<p>Platform matching considers the CPU and OS sets to determine if the conditional
string applies to the specified target platform.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TConditionalStrings.Find.Result">
<short>Index of matching conditional string or -1 if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Find.Value">
<short>String value to search for</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Find.aCPU">
<short>CPU architecture to match</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Find.aOS">
<short>Operating system to match</short>
</element>

<!-- function Visibility: public -->
<element name="TConditionalStrings.Add">
<short>Add a new conditional string</short>
<descr>
<p>Creates and adds a new conditional string with the specified value and platform
restrictions. The string will only be used when the current build targets match
the specified CPU architectures and operating systems.</p>
<p>Platform-specific strings enable configuration of different values for different
target platforms within the same package.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TConditionalStrings.Add.Result">
<short>Newly created conditional string item</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Add.Value">
<short>String value to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Add.OSes">
<short>Set of operating systems for this conditional string</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalStrings.Add.CPUs">
<short>Set of CPU architectures for this conditional string</short>
</element>

<!-- property Visibility: public -->
<element name="TConditionalStrings.ConditionalStrings">
<short>Indexed access to conditional string items</short>
<descr>
<p>Provides indexed access to individual conditional string items in the collection.</p>
<p>Each item contains a value and associated CPU/OS conditions.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TConditionalStrings.ConditionalStrings.Index">
<short>Index of the conditional string item</short>
</element>

<!-- class Visibility: default -->
<element name="TConditionalDestString">
<short>Conditional string with destination path</short>
<descr>
<p><var>TConditionalDestString</var> extends conditional strings to include destination path information.</p>
<p>Used for file operations that require both source values and target destinations
based on CPU and OS conditions.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TConditionalDestString.Assign">
<short>Assign conditional destination string from another source</short>
<descr>
<p><var>Assign</var> copies all properties from another <link id="TConditionalDestString">TConditionalDestString</link> object to this instance.</p>
<p>This includes the string value, destination path, CPU conditions, OS conditions, and any other conditional criteria.</p>
<p>The method provides a complete deep copy of the conditional destination string configuration.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestString.Assign.aSource">
<short>Source conditional destination string to copy from</short>
</element>

<!-- property Visibility: public -->
<element name="TConditionalDestString.DestPath">
<short>Destination path for the conditional string</short>
<descr>
<p>Destination file or directory path where the conditional string value should be placed.</p>
<p>This path is used during installation and file copy operations.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TConditionalDestStringClass">
<short>Class reference for conditional destination strings</short>
<descr>
<p><var>TConditionalDestStringClass</var> is a class reference type that points to <link id="TConditionalDestString">TConditionalDestString</link> or its descendant classes.</p>
<p>This type enables polymorphic creation of different conditional destination string implementations at runtime.</p>
<p>It is used in factory methods and class registration systems for dynamic object instantiation.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TConditionalDestStrings">
<short>Collection of conditional destination strings</short>
<descr>
<p><var>TConditionalDestStrings</var> is a specialized collection that manages multiple <link id="TConditionalDestString">TConditionalDestString</link> objects.</p>
<p>This class provides methods for adding, searching, and retrieving conditional destination strings based on platform criteria.</p>
<p>It enables efficient management of platform-specific file installation paths and destinations in build systems.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TConditionalDestStrings.Create">
<short>Creates conditional destination strings collection</short>
<descr>
<p><var>Create</var> initializes a new <link id="TConditionalDestStrings">TConditionalDestStrings</link> collection instance.</p>
<p>The constructor sets up an empty collection ready to accept conditional destination string items.</p>
<p>The collection inherits from the base collection classes and provides specialized functionality for destination string management.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestStrings.Create.AClass">
<short>Class type for conditional destination string items</short>
</element>

<!-- function Visibility: public -->
<element name="TConditionalDestStrings.Add">
<short>Adds conditional destination string with path mapping</short>
<descr>
<p><var>Add</var> creates and adds a new conditional destination string with the specified value, destination path, and platform restrictions.</p>
<p>The string will only be used when the current build targets match the specified CPU architectures and operating systems.</p>
<p>This method enables platform-specific file installation paths and destination mapping in build configurations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TConditionalDestStrings.Add.Result">
<short>Newly created conditional destination string item</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestStrings.Add.Value">
<short>String value to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestStrings.Add.ADestPath">
<short>Destination path for the string mapping</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestStrings.Add.OSes">
<short>Set of operating systems for this conditional string</short>
</element>

<!-- argument Visibility: default -->
<element name="TConditionalDestStrings.Add.CPUs">
<short>Set of CPU architectures for this conditional string</short>
</element>

<!-- property Visibility: public -->
<element name="TConditionalDestStrings.ConditionalStrings">
<short>Indexed access to conditional destination strings</short>
<descr>
<p><var>ConditionalStrings</var> provides indexed access to individual <link id="TConditionalDestString">TConditionalDestString</link> items in the collection.</p>
<p>This property enables array-style access to retrieve or modify specific conditional destination strings by their position.</p>
<p>The index must be within the valid range from 0 to Count-1 to avoid range check errors.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TConditionalDestStrings.ConditionalStrings.Index">
<short>Index of the conditional destination string item</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TNotifyEventAction">
<short>Enumeration of build process event trigger points</short>
<descr>
<p><var>TNotifyEventAction</var> defines the different stages in the build process where notification events can be triggered.</p>
<p>This enumeration enables attaching custom actions or handlers to specific points in the build pipeline.</p>
<p>Build systems use these action points to execute custom commands, perform validation, or provide progress feedback.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeCompile">
<short>Event triggered before compilation starts</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterCompile">
<short>Event triggered after compilation completes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeInstall">
<short>Event triggered before installation starts</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterInstall">
<short>Event triggered after installation completes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeClean">
<short>Event triggered before cleanup starts</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterClean">
<short>Event triggered after cleanup completes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeArchive">
<short>Event triggered before archiving starts</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterArchive">
<short>Event triggered after archiving completes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeManifest">
<short>Event triggered before manifest creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterManifest">
<short>Event triggered after manifest creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforePkgList">
<short>Event triggered before package list creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterPkgList">
<short>Event triggered after package list creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeUnInstall">
<short>Event triggered before uninstallation starts</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterUnInstall">
<short>Event triggered after uninstallation completes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeCreateBuildEngine">
<short>Event triggered before build engine creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterCreateBuildengine">
<short>Event triggered after build engine creation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaBeforeDocProject">
<short>Event triggered before documentation project processing</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNotifyEventAction.neaAfterDocProject">
<short>Event triggered after documentation project processing</short>
</element>

<!-- set type Visibility: default -->
<element name="TNotifyEventActionSet">
<short>Set of notification event actions</short>
<descr>
<p><var>TNotifyEventActionSet</var> is a set type that can contain multiple <link id="TNotifyEventAction">TNotifyEventAction</link> values.</p>
<p>This set enables efficient combination and testing of multiple event action types in a single variable.</p>
<p>Build systems use this set type to specify which events should trigger specific notification handlers.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TNotifyEventItem">
<short>Individual notification event item with callback handlers</short>
<descr>
<p><var>TNotifyEventItem</var> represents a single notification event configuration that associates callback handlers with specific build actions.</p>
<p>This class encapsulates the event trigger conditions and the corresponding callback procedures or functions.</p>
<p>Build systems use these items to implement custom behavior at defined points in the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNotifyEventItem.OnAction">
<short>Action type that triggers this notification event</short>
<descr>
<p><var>OnAction</var> specifies the <link id="TNotifyEventAction">TNotifyEventAction</link> that will trigger this notification event.</p>
<p>When the build process reaches the specified action point, the associated callback handlers will be executed.</p>
<p>This property determines at which stage of the build process the event will fire.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNotifyEventItem.OnEvent">
<short>Standard notify event callback procedure</short>
<descr>
<p><var>OnEvent</var> contains a standard notification event handler that follows the <var>TNotifyEvent</var> signature.</p>
<p>This property accepts method pointers that receive a sender object as parameter when the event fires.</p>
<p>Use this property for object-oriented event handling with standard notification event signatures.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TNotifyEventItem.OnProcEvent">
<short>Procedural notify event callback</short>
<descr>
<p><var>OnProcEvent</var> contains a procedural notification event handler for function pointer-based callbacks.</p>
<p>This property accepts procedure pointers that can be called when the specified build action occurs.</p>
<p>Use this property for procedural event handling without object context requirements.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TNotifyEventItem.CallEvent">
<short>Invokes the notification event callback</short>
<descr>
<p><var>CallEvent</var> executes the configured notification event callback with the provided sender object.</p>
<p>This method checks which callback type is assigned and calls the appropriate handler procedure or method.</p>
<p>The method is called internally by the build system when the associated action trigger occurs.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventItem.CallEvent.Sender">
<short>Object that initiated the event notification</short>
</element>

<!-- class Visibility: default -->
<element name="TNotifyEventEnumerator">
<short>Enumerator for iterating through notification events</short>
<descr>
<p><var>TNotifyEventEnumerator</var> provides iteration support for collections of notification events.</p>
<p>This class enables for-in loop syntax when working with notification event collections.</p>
<p>The enumerator maintains current position state and provides access to individual event items during iteration.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TNotifyEventEnumerator.GetCurrent">
<short>Gets current notify event in enumeration</short>
<descr>
<p><var>GetCurrent</var> returns the current notification event procedure at the enumerator's position.</p>
<p>This method provides access to the notification event handler currently pointed to by the enumerator.</p>
<p>The method is typically called internally during for-in loop iteration to retrieve the current item.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNotifyEventEnumerator.GetCurrent.Result">
<short>Current notify event procedure</short>
</element>

<!-- property Visibility: public -->
<element name="TNotifyEventEnumerator.Current">
<short>Current notification event in the enumeration</short>
<descr>
<p><var>Current</var> returns the current notification event procedure at the enumerator's position.</p>
<p>This property provides convenient access to the notification event handler currently pointed to during iteration.</p>
<p>The property is used in for-in loops to access each event handler as the enumeration progresses.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TNotifyEventCollection">
<short>Collection of notification event handlers</short>
<descr>
<p><var>TNotifyEventCollection</var> is a specialized collection that manages multiple notification event handlers.</p>
<p>This class provides methods for adding, removing, and invoking notification events at specific build process stages.</p>
<p>Build systems use this collection to maintain lists of callbacks that should be executed at defined trigger points.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TNotifyEventCollection.create">
<short>Creates a new notification event collection</short>
<descr>
<p><var>create</var> initializes a new <link id="TNotifyEventCollection">TNotifyEventCollection</link> instance.</p>
<p>The constructor sets up an empty collection ready to accept notification event items.</p>
<p>The collection is properly initialized with all necessary internal structures for event management.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.create.ASupportedActionSet">
<short>Set of notification actions supported by this collection</short>
</element>

<!-- function Visibility: public -->
<element name="TNotifyEventCollection.GetEnumerator">
<short>Gets enumerator for iterating notify events</short>
<descr>
<p><var>GetEnumerator</var> returns a <link id="TNotifyEventEnumerator">TNotifyEventEnumerator</link> for iterating through the collection.</p>
<p>This method enables for-in loop support for notification event collections.</p>
<p>The enumerator provides sequential access to each notification event handler in the collection.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TNotifyEventCollection.GetEnumerator.Result">
<short>Notify event collection enumerator</short>
</element>

<!-- procedure Visibility: public -->
<element name="TNotifyEventCollection.AppendEvent">
<short>Adds a notification event handler to the collection</short>
<descr>
<p><var>AppendEvent</var> adds a new notification event handler to the collection for a specific action type.</p>
<p>The event handler will be triggered when the specified build action occurs during package processing.</p>
<p>Multiple handlers can be associated with the same action type and will be executed in sequence.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.AppendEvent.AnAction">
<short>Action type that triggers the event</short>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.AppendEvent.AnEvent">
<short>Event handler procedure to add</short>
</element>

<!-- procedure Visibility: public -->
<element name="TNotifyEventCollection.AppendProcEvent">
<short>Adds a procedural notification event to the collection</short>
<descr>
<p><var>AppendProcEvent</var> adds a procedural notification event handler to the collection for a specific action type.</p>
<p>This method accepts function pointers rather than object method pointers, enabling procedural callback support.</p>
<p>The procedural event handler will be triggered when the specified build action occurs during package processing.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.AppendProcEvent.AnACtion">
<short>Action type that triggers the procedural event</short>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.AppendProcEvent.AnProcEvent">
<short>Procedural event handler to add</short>
</element>

<!-- procedure Visibility: public -->
<element name="TNotifyEventCollection.CallEvents">
<short>Invokes all event handlers for the specified action</short>
<descr>
<p><var>CallEvents</var> executes all registered notification event handlers that match the specified action type.</p>
<p>This method is called internally by the build system when specific build actions occur.</p>
<p>All matching event handlers are invoked in sequence with the provided sender object as parameter.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.CallEvents.AnAction">
<short>Action type for which to invoke event handlers</short>
</element>

<!-- argument Visibility: default -->
<element name="TNotifyEventCollection.CallEvents.Sender">
<short>Object that initiated the event notification</short>
</element>

<!-- function type Visibility: default -->
<element name="TReplaceFunction">
<short>Function type for dynamic string replacement callbacks</short>
<descr>
<p><var>TReplaceFunction</var> is a function pointer type for implementing dynamic string replacement callbacks.</p>
<p>Functions of this type are used in string substitution systems to provide custom replacement logic for variable expansion.</p>
<p>The function receives a name and arguments array, returning the replacement string value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TReplaceFunction.Result">
<short>Replacement string returned by the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TReplaceFunction.AName">
<short>Name of replacement function</short>
</element>

<!-- argument Visibility: default -->
<element name="TReplaceFunction.Args">
<short>Array of string arguments passed to the replacement function</short>
</element>

<!-- class Visibility: default -->
<element name="TDictionary">
<short>String substitution dictionary for variables and functions</short>
<descr>
<p><var>TDictionary</var> provides a string substitution system for variable and function expansion.</p>
<p>This class manages both static variable assignments and dynamic function callbacks for resolving configuration values.</p>
<p>The dictionary is used extensively throughout the build system to resolve paths, variables, and configuration parameters.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TDictionary.Create">
<short>Creates a new string substitution dictionary</short>
<descr>
<p>Creates a new <var>TDictionary</var> instance that can store variable name-value pairs
and function callbacks for dynamic string substitution.</p>
<p>The dictionary is used throughout the build system to resolve configuration
variables, paths, and dynamic values during compilation and installation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.Create.AOwner">
<short>Owner component for the dictionary</short>
</element>

<!-- destructor Visibility: public -->
<element name="TDictionary.Destroy">
<short>Destroys the dictionary and releases resources</short>
<descr>
<p><var>Destroy</var> frees all memory used by the dictionary including variable storage and function callback lists.</p>
<p>This destructor ensures proper cleanup of all internal data structures and registered callbacks.</p>
<p>The destructor is called automatically when the dictionary object is destroyed or goes out of scope.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TDictionary.AddVariable">
<short>Adds a variable name-value pair to the dictionary</short>
<descr>
<p>Adds or updates a variable with the specified name and value in the dictionary.
If a variable with the same name already exists, its value is replaced.</p>
<p>Variables are used for static string substitution in configuration files,
command line arguments, and file paths.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.AddVariable.AName">
<short>Variable name for substitution</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.AddVariable.Value">
<short>Variable value for substitution</short>
</element>

<!-- procedure Visibility: public -->
<element name="TDictionary.AddFunction">
<short>Adds a function replacement callback to the dictionary</short>
<descr>
<p>Adds a function callback with the specified name that provides dynamic value
generation during string substitution. Functions can accept arguments and return
computed values based on runtime conditions.</p>
<p>This enables advanced templating where values are calculated dynamically
based on build parameters, system configuration, or package state.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.AddFunction.AName">
<short>Function name for substitution</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.AddFunction.FReplacement">
<short>Function callback for dynamic value substitution</short>
</element>

<!-- procedure Visibility: public -->
<element name="TDictionary.RemoveItem">
<short>Removes a variable or function from the dictionary</short>
<descr>
<p><var>RemoveItem</var> removes the specified variable or function callback from the dictionary.</p>
<p>After removal, attempts to resolve the removed item name will fail with an exception.</p>
<p>This method is useful for dynamically modifying the available substitution variables during build processes.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.RemoveItem.AName">
<short>Name of dictionary item to remove</short>
</element>

<!-- function Visibility: public -->
<element name="TDictionary.GetValue">
<short>Retrieves substituted value for dictionary entry</short>
<descr>
<p>Retrieves the value for the specified dictionary entry name. For variables,
returns the stored string value. For functions, executes the callback with
the provided arguments and returns the computed result.</p>
<p>Raises an exception if the requested entry name is not found in the dictionary.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDictionary.GetValue.Result">
<short>Substituted string value from dictionary</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.GetValue.AName">
<short>Name of dictionary entry to retrieve</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.GetValue.Args">
<short>Arguments string for function replacements</short>
</element>

<!-- function Visibility: public -->
<element name="TDictionary.ReplaceStrings">
<short>Performs string substitution using dictionary variables</short>
<descr>
<p><var>ReplaceStrings</var> processes a source string and replaces all variable and function references with their resolved values.</p>
<p>The method supports nested substitutions up to the specified maximum depth to prevent infinite recursion.</p>
<p>Variable references use $(name) syntax, and function calls use $(name:arg1:arg2) format for parameter passing.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDictionary.ReplaceStrings.Result">
<short>String with all substitutions applied</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.ReplaceStrings.ASource">
<short>Source string containing substitution patterns</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.ReplaceStrings.MaxDepth">
<short>Maximum recursion depth for nested substitutions</short>
</element>

<!-- function Visibility: public -->
<element name="TDictionary.Substitute">
<short>Substitutes macros in a string using the dictionary</short>
<descr>
<p><var>Substitute</var> performs macro expansion and variable substitution on the input string using dictionary entries.</p>
<p>This method processes macro syntax patterns and replaces them with corresponding values from variables and function callbacks.</p>
<p>The substitution supports both simple variable expansion and complex function calls with parameter passing.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDictionary.Substitute.Result">
<short>String with all macro substitutions performed</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.Substitute.Source">
<short>Source string containing macro patterns</short>
</element>

<!-- argument Visibility: default -->
<element name="TDictionary.Substitute.Macros">
<short>Additional macros for substitution</short>
</element>

<!-- class Visibility: default -->
<element name="TPackageDictionary">
<short>Package-specific dictionary with master dictionary support</short>
<descr>
<p><var>TPackageDictionary</var> extends the basic dictionary functionality with package-specific variable support.</p>
<p>This class maintains its own variable namespace while also providing access to a master dictionary for fallback lookups.</p>
<p>Package dictionaries enable isolated variable scoping per package while maintaining global configuration access.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TPackageDictionary.GetValue">
<short>Retrieves package-specific substituted value</short>
<descr>
<p><var>GetValue</var> retrieves a substituted value first from the package dictionary, then from the master dictionary if not found locally.</p>
<p>This method implements cascading lookup behavior for package-specific variable resolution.</p>
<p>The method supports both variable expansion and function callbacks with argument passing.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackageDictionary.GetValue.Result">
<short>Package-specific substituted string value</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackageDictionary.GetValue.AName">
<short>Name of dictionary entry to retrieve</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackageDictionary.GetValue.Args">
<short>Arguments string for function replacements</short>
</element>

<!-- property Visibility: public -->
<element name="TPackageDictionary.MasterDictionary">
<short>Reference to the master dictionary for fallback lookups</short>
<descr>
<p><var>MasterDictionary</var> provides access to the global dictionary that serves as fallback for variable lookups.</p>
<p>When a variable is not found in the package-specific dictionary, the lookup falls back to this master dictionary.</p>
<p>This property enables hierarchical variable resolution from package-specific to global scope.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TDependency">
<short>Represents a build dependency in the fpmake system</short>
<descr>
<p><var>TDependency</var> represents a dependency relationship between build targets or packages.
Dependencies can be on other packages, individual units, include files, or specific targets.</p>
<p>The dependency system ensures that required components are built before dependent targets,
manages version requirements, and handles conditional dependencies based on CPU and OS targets.</p>
<p>Dependencies support version checking through the <var>Version</var> property and can be conditional
on specific CPU architectures and operating systems inherited from <link id="TConditionalString">TConditionalString</link>.</p>
</descr>
<seealso>
<link id="TDependencies">TDependencies</link>
<link id="TDependencyType">TDependencyType</link>
<link id="TConditionalString">TConditionalString</link>
<link id="TPackage">TPackage</link>
<link id="TTarget">TTarget</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TDependency.Create">
<short>Creates a new package dependency instance</short>
<descr>
<p><var>Create</var> initializes a new <link id="TDependency">TDependency</link> object with the specified collection owner.</p>
<p>The constructor establishes the dependency relationship and registers it with the provided collection.</p>
<p>Dependencies are used to define build order requirements and package relationship constraints.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDependency.Create.aCollection">
<short>Collection that will contain this dependency</short>
</element>

<!-- procedure Visibility: public -->
<element name="TDependency.Assign">
<short>Assigns properties from another dependency object</short>
<descr>
<p><var>Assign</var> copies all properties from another <link id="TDependency">TDependency</link> object to this instance.</p>
<p>This includes dependency type, version requirements, conditional CPU/OS settings, and target specifications.</p>
<p>The method provides a complete deep copy of dependency configuration for cloning or template application.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDependency.Assign.aSource">
<short>Source dependency object to copy properties from</short>
</element>

<!-- destructor Visibility: public -->
<element name="TDependency.Destroy">
<short>Destroys the dependency object and releases resources</short>
<descr>
<p><var>Destroy</var> cleans up the dependency object and removes it from its containing collection.</p>
<p>The destructor ensures proper cleanup of version objects and conditional string resources.</p>
<p>The dependency is automatically unregistered from the build system when destroyed.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TDependency.Target">
<short>Target name that this dependency references</short>
<descr>
<p>Name of the target, unit, package, or include file that this dependency requires.</p>
<p>The target must be available for the dependent target to compile successfully.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TDependency.DependencyType">
<short>Type of dependency relationship</short>
<descr>
<p>Specifies the type of dependency: package, implicit package, unit, or include file.</p>
<p>The dependency type determines how the dependency is resolved and linked.</p>
<p>This read-only property is set when the dependency is added to the dependencies collection.</p>
</descr>
<seealso>
<link id="TDependencies.Add"/>
<link id="TDependencies.AddUnit"/>
<link id="TDependencies.AddInclude"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TDependency.TargetFileName">
<short>Specific filename for the dependency target</short>
<descr>
<p>Optional specific filename for the dependency target.</p>
<p>When specified, this overrides the default filename derived from the target name.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TDependency.Version">
<short>Version requirement for the dependency</short>
<descr>
<p>Version specification for the required dependency.</p>
<p>Used to ensure compatibility when multiple versions of a dependency are available.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TDependency.RequireChecksum">
<short>Controls checksum verification for the dependency</short>
<descr>
<p>When <var>True</var>, requires checksum verification of the dependency file.</p>
<p>Ensures integrity and prevents use of corrupted or modified dependencies.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TResourceFile">
<short>Represents a resource file in the build system</short>
<descr>
<p><var>TResourceFile</var> represents a resource file that needs to be processed and included during package compilation.</p>
<p>Resource files contain binary data, icons, bitmaps, strings, or other assets that are embedded into the compiled executable.</p>
<p>The build system processes resource files according to platform-specific resource compilation requirements.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TPackage">
<short>Central class for package management and building</short>
<descr>
<p><var>TPackage</var> is the central class in the fpmake build system that represents a complete package.
A package contains build targets, dependencies, installation files, and all configuration needed for
compilation and deployment.</p>
<p>Each package can contain multiple targets such as units, programs, and libraries.
The package manages compilation options, search paths, dependencies on other packages,
and installation procedures. It supports cross-platform compilation with CPU and OS-specific settings.</p>
<p>It handles the following aspects:</p>
<ul>
<li>Management of <link id="TTarget">TTarget</link> build targets</li>
<li>Dependency tracking through <link id="TDependency">TDependency</link> objects</li>
<li>Cross-platform compilation support</li>
<li>Package variants for different build configurations</li>
<li>Custom installation and archiving procedures</li>
</ul>
</descr>
<seealso>
<link id="TTarget">TTarget</link>
<link id="TTargets">TTargets</link>
<link id="TDependency">TDependency</link>
<link id="TPackageVariants">TPackageVariants</link>
<link id="TBuildEngine">TBuildEngine</link>
<link id="TCustomInstaller">TCustomInstaller</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TPackageVariant">
<short>Package variant with specific build options</short>
<descr>
<p><var>TPackageVariant</var> represents a specific configuration variant of a package with custom build options and settings.
This class allows packages to define multiple build configurations with different compiler options, target platforms,
or conditional compilation settings.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TPackageVariant.Create">
<short>Creates a new package variant configuration</short>
<descr>
<p>Creates a new <var>TPackageVariant</var> instance and adds it to the specified collection.
The variant is initialized with default settings and ready for configuration with specific build options.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackageVariant.Create.ACollection">
<short>Collection that will contain this variant</short>
</element>

<!-- destructor Visibility: public -->
<element name="TPackageVariant.Destroy">
<short>Destroys package variant and frees resources</short>
<descr>
<p>Destroys the <var>TPackageVariant</var> instance and releases all associated resources including option collections
and configuration data. This method is called automatically when the variant is no longer needed.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TPackageVariant.AddOption">
<short>Adds a compiler option to the package variant</short>
<descr>
<p>Adds a compiler option string to this package variant. The option will be passed to the compiler
when building the package with this specific variant configuration.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackageVariant.AddOption.aValue">
<short>Compiler option string to add</short>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariant.Options">
<short>Compiler options for this variant</short>
<descr>
<p><var>Options</var> contains the collection of compiler command-line options specific to this package variant.
These options are passed to the compiler when building the package with this variant configuration.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariant.IncludePath">
<short>Include file search paths for this variant</short>
<descr>
<p><var>IncludePath</var> specifies the search paths for include files when compiling with this variant.
These paths are added to the compiler's include search directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariant.SourcePath">
<short>Source file search paths for this variant</short>
<descr>
<p><var>SourcePath</var> specifies the search paths for source unit files when compiling with this variant.
These paths are added to the compiler's unit search directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariant.Targets">
<short>Build targets associated with this variant</short>
<descr>
<p><var>Targets</var> contains the collection of build targets that are built when using this package variant.
Each target in this collection will be compiled with the variant's specific options and settings.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TPackageVariantEnumerator">
<short>Enumerator for iterating through package variants</short>
<descr>
<p><var>TPackageVariantEnumerator</var> provides enumeration support for iterating through collections of package variants
using for-in loop syntax. This enumerator implements the standard enumeration pattern for Pascal collections.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TPackageVariantEnumerator.GetCurrent">
<short>Gets current package variant in enumeration</short>
<descr>
<p>Returns the current <var>TPackageVariant</var> object in the enumeration sequence.
This method is called internally by the for-in loop mechanism to access the current variant.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackageVariantEnumerator.GetCurrent.Result">
<short>Current package variant in enumeration</short>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariantEnumerator.Current">
<short>Current package variant being enumerated</short>
<descr>
<p><var>Current</var> property provides read-only access to the current <var>TPackageVariant</var> in the enumeration.
This property is used by for-in loops to access the variant object during iteration.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TPackageVariants">
<short>Collection of package variants</short>
<descr>
<p><var>TPackageVariants</var> is a collection class that manages multiple <var>TPackageVariant</var> objects.
This class provides methods for adding, accessing, and enumerating package variants within a package configuration.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TPackageVariants.Add">
<short>Adds a new package variant to the collection</short>
<descr>
<p>Creates and adds a new <var>TPackageVariant</var> to the collection. The new variant is initialized with default settings
and can then be configured with specific build options and targets.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackageVariants.Add.Result">
<short>Newly created package variant</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackageVariants.Add.AName">
<short>Name for the new package variant</short>
</element>

<!-- function Visibility: public -->
<element name="TPackageVariants.GetEnumerator">
<short>Gets enumerator for iterating package variants</short>
<descr>
<p>Returns a <var>TPackageVariantEnumerator</var> that can be used to iterate through all package variants
in the collection using for-in loop syntax.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackageVariants.GetEnumerator.Result">
<short>Package variant collection enumerator</short>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.Name">
<short>Name of the package variants collection</short>
<descr>
<p><var>Name</var> property contains the identifier for this package variants collection.
This name is used to reference the collection within the package configuration.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.MasterPackage">
<short>Reference to the master package owning the variants</short>
<descr>
<p><var>MasterPackage</var> provides access to the <var>TPackage</var> instance that owns this variants collection.
This reference allows variants to access package-level settings and configuration.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.DefaultPackageVariant">
<short>Default package variant used when none specified</short>
<descr>
<p><var>DefaultPackageVariant</var> specifies the package variant to use when no specific variant is requested
during the build process. This ensures consistent build behavior when variants are not explicitly selected.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.ActivePackageVariant">
<short>Currently active package variant for building</short>
<descr>
<p><var>ActivePackageVariant</var> represents the package variant currently selected for building.
This property determines which variant's settings and options are applied during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.DefaultPackageVariantName">
<short>Name of the default package variant</short>
<descr>
<p><var>DefaultPackageVariantName</var> contains the string name of the default package variant.
This name is used to identify which variant should be used when no specific variant is selected.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.ActivePackageVariantName">
<short>Name of the currently active package variant</short>
<descr>
<p><var>ActivePackageVariantName</var> contains the string name of the currently active package variant.
This property reflects which variant is selected for the current build operation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.IsInheritable">
<short>Whether package variants can be inherited by child packages</short>
<descr>
<p><var>IsInheritable</var> determines whether the package variants in this collection can be inherited
by dependent child packages, allowing for consistent variant propagation through package hierarchies.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackageVariants.AutoAddToPackage">
<short>Whether variants are automatically added to the package</short>
<descr>
<p><var>AutoAddToPackage</var> controls whether new variants created in this collection are automatically
registered with the parent package. When <var>True</var>, variants are immediately available for building.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TDependencyEnumerator">
<short>Enumerator for iterating through dependency collections</short>
<descr>
<p><var>TDependencyEnumerator</var> provides enumeration support for iterating through collections of dependencies
using for-in loop syntax. This enumerator implements the standard enumeration pattern for Pascal collections.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TDependencyEnumerator.GetCurrent">
<short>Gets current dependency in enumeration</short>
<descr>
<p>Returns the current <var>TDependency</var> object in the enumeration sequence.
This method is called internally by the for-in loop mechanism to access the current dependency.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDependencyEnumerator.GetCurrent.Result">
<short>Current dependency object</short>
</element>

<!-- property Visibility: public -->
<element name="TDependencyEnumerator.Current">
<short>Current dependency being enumerated</short>
<descr>
<p><var>Current</var> property provides read-only access to the current <var>TDependency</var> in the enumeration.
This property is used by for-in loops to access the dependency object during iteration.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TDependencies">
<short>Collection of build dependencies</short>
<descr>
<p><var>TDependencies</var> is a collection class that manages build dependencies for Free Pascal packages.</p>
<p>This collection stores and organizes dependency objects, providing indexed access and management
functionality.</p>
</descr>
</element>

<!-- function Visibility: default -->
<element name="TDependencies.GetDependency">
<short>Gets dependency at specified index</short>
<descr>
<p>Retrieves the <link id="TDependency">TDependency</link> object at the specified index position
within the dependencies collection.</p>
<p>Returns the dependency object for accessing its properties and configuration settings.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDependencies.GetDependency.Result">
<short>Dependency object at the specified index</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.GetDependency.Index">
<short>Zero-based index of dependency to retrieve</short>
</element>

<!-- procedure Visibility: default -->
<element name="TDependencies.SetDependency">
<short>Sets dependency at specified index</short>
<descr>
<p>Assigns a <link id="TDependency">TDependency</link> object at the specified index position
within the dependencies collection.</p>
<p>Updates the dependency entry with new configuration and settings for package build requirements.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.SetDependency.Index">
<short>Zero-based index where to set dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.SetDependency.AValue">
<short>Dependency object to set at index</short>
</element>

<!-- function Visibility: public -->
<element name="TDependencies.Add">
<short>Adds a new package dependency to the collection</short>
<descr>
<p>Creates and adds a new dependency with the specified package name to the collection.
The dependency can be made platform-specific by providing CPU and OS restrictions.</p>
<p>Dependencies ensure that the required package is available
before compilation of the dependent target begins.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDependencies.Add.Result">
<short>Newly created dependency object</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.Add.Value">
<short>Target name for the dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.Add.OSes">
<short>Set of operating systems for this dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.Add.CPUs">
<short>Set of CPU architectures for this dependency</short>
</element>

<!-- function Visibility: public -->
<element name="TDependencies.AddUnit">
<short>Adds a unit dependency to the collection</short>
<descr>
<p>Creates and adds a new dependency on a specific unit within the same package,
so that the installer can decide to compile the dependency first when determining the order of compilation.
The dependency can be made conditional by specifying CPU architectures and operating systems where this dependency applies.</p>
</descr>
<seealso>
<link id="TDependencies.Add">Add</link>
<link id="TDependencies.AddInclude">AddInclude</link>
<link id="TDependencyType.depUnit">depUnit</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TDependencies.AddUnit.Result">
<short>Newly created unit dependency object</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddUnit.Value">
<short>Unit name for the dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddUnit.OSes">
<short>Set of operating systems for this unit dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddUnit.CPUs">
<short>Set of CPU architectures for this unit dependency</short>
</element>

<!-- function Visibility: public -->
<element name="TDependencies.AddInclude">
<short>Adds an include file dependency to the collection</short>
<descr>
<p>Creates and adds a new dependency on an include file. The dependency can be made conditional
by specifying CPU architectures and operating systems where this dependency applies.</p>
</descr>
<seealso>
<link id="TDependencies.Add">Add</link>
<link id="TDependencies.AddUnit">AddUnit</link>
<link id="TDependencyType.depInclude">depInclude</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TDependencies.AddInclude.Result">
<short>Newly created include file dependency object</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddInclude.Value">
<short>Include filename for the dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddInclude.OSes">
<short>Set of operating systems for this include dependency</short>
</element>

<!-- argument Visibility: default -->
<element name="TDependencies.AddInclude.CPUs">
<short>Set of CPU architectures for this include dependency</short>
</element>

<!-- function Visibility: public -->
<element name="TDependencies.GetEnumerator">
<short>Gets enumerator for iterating dependencies</short>
<descr>
<p>Returns an enumerator object that allows iteration through all dependencies
in the collection using for-in loops or manual iteration.</p>
<p>This provides a convenient way to process all dependencies when resolving
build order or checking dependency requirements.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TDependencies.GetEnumerator.Result">
<short>Dependency collection enumerator for iteration</short>
</element>

<!-- property Visibility: public -->
<element name="TDependencies.Dependencies">
<short>Indexed access to dependency objects in the collection</short>
<descr>
<p>Provides indexed read and write access to <link id="TDependency">TDependency</link> objects
stored in the collection.</p>
<p>This default property enables array-style access to individual dependency entries for
configuration and management.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TDependencies.Dependencies.Index">
<short>Index of the dependency to retrieve</short>
</element>

<!-- class Visibility: default -->
<element name="TResourceFiles">
<short>Collection of resource files for the build system</short>
<descr>
<p><var>TResourceFiles</var> is a specialized collection class that manages resource files
included in Free Pascal package builds.</p>
<p>This collection handles resource file tracking, installation paths, and deployment configuration
for binary resources, documentation files, and other assets.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TResourceFiles.GetInstallFiles">
<short>Gets list of resource files for installation</short>
<descr>
<p>Populates the provided list with resource files that should be installed
as part of this resource collection's deployment process.</p>
<p>This method collects all resources associated with this collection that require
installation or distribution with the package.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TResourceFiles.GetInstallFiles.AList">
<short>List to store the installation files</short>
</element>

<!-- argument Visibility: default -->
<element name="TResourceFiles.GetInstallFiles.APrefixU">
<short>Unit prefix for file installation paths</short>
</element>

<!-- argument Visibility: default -->
<element name="TResourceFiles.GetInstallFiles.APrefixB">
<short>Binary prefix for file installation paths</short>
</element>

<!-- argument Visibility: default -->
<element name="TResourceFiles.GetInstallFiles.ACPU">
<short>Target CPU architecture for file selection</short>
</element>

<!-- argument Visibility: default -->
<element name="TResourceFiles.GetInstallFiles.AOS">
<short>Target operating system for file selection</short>
</element>

<!-- class Visibility: default -->
<element name="TTarget">
<short>Build target representation in the fpmake system</short>
<descr>
<p><var>TTarget</var> represents a single build target within a package, such as a unit, program, or library.
Each target defines what needs to be compiled, how it should be compiled, and where the resulting files
should be installed.</p>
<p>Build targets can be units, programs, libraries, or documentation files.
They contain information about source files, compilation options, dependencies, CPU and OS requirements,
and installation settings.</p>
<p>Targets are managed through the <link id="TTargets">TTargets</link> collection and are owned by
<link id="TPackage">TPackage</link> instances.</p>
</descr>
<seealso>
<link id="TPackage">TPackage</link>
<link id="TTargets">TTargets</link>
<link id="TTargetType">TTargetType</link>
<link id="TFileType">TFileType</link>
<link id="TDependency">TDependency</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TTarget.Create">
<short>Creates a new build target instance</short>
<descr>
<p>Creates a new <var>TTarget</var> instance within the specified collection.</p>
<p>The target is initialized with default settings and can be configured for compilation,
installation, and dependency management.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.Create.ACollection">
<short>Collection that will contain this target</short>
</element>

<!-- destructor Visibility: public -->
<element name="TTarget.Destroy">
<short>Destroys the target instance and frees resources</short>
<descr>
<p>Destroys the <var>TTarget</var> instance and frees all associated resources including
dependencies, resource files, commands, and path collections.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.AssignTo">
<short>Assigns target properties to another object</short>
<descr>
<p>Assigns the properties of this target to another persistent object.</p>
<p>This method is used for copying target configuration during build operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.AssignTo.Dest">
<short>Destination object to receive target properties</short>
</element>

<!-- function Visibility: public -->
<element name="TTarget.GetOutputFileName">
<short>Returns the target's output filename for the specified OS</short>
<descr>
<p>Returns the complete output filename that will be generated for this target on the specified
operating system.</p>
<p>The filename includes appropriate extensions and paths based on the target type and OS conventions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTarget.GetOutputFileName.Result">
<short>Complete output filename for the target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetOutputFileName.AOs">
<short>Target operating system for filename generation</short>
</element>

<!-- function Visibility: public -->
<element name="TTarget.HaveOptions">
<short>Checks if target has compilation options</short>
<descr>
<p>Returns <var>True</var> if the target has compiler options defined, <var>False</var> otherwise.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTarget.HaveOptions.Result">
<short><var>True</var> if target has options, <var>False</var> otherwise</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.AddOption">
<short>Adds a compilation option to the target</short>
<descr>
<p>Adds a compiler option string to the target's option list.</p>
<p>These options are passed to the Free Pascal Compiler when compiling this target.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.AddOption.aValue">
<short>Compiler option string to add</short>
</element>

<!-- function Visibility: public -->
<element name="TTarget.SubTargetAllowed">
<short>Checks if a subtarget is allowed for this target</short>
<descr>
<p>Returns <var>True</var> if the specified subtarget name is allowed for this target type.</p>
<p>Different target types support different subtargets (e.g., units vs programs).</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTarget.SubTargetAllowed.Result">
<short><var>True</var> if subtarget is allowed, <var>False</var> otherwise</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.SubTargetAllowed.aSubTarget">
<short>Subtarget name to check</short>
</element>

<!-- function Visibility: public -->
<element name="TTarget.SubTargetsAsString">
<short>Returns all subtargets as a comma-separated string</short>
<descr>
<p>Returns a string containing all subtargets for this target, separated by commas.</p>
<p>Used for display and configuration purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTarget.SubTargetsAsString.Result">
<short>Comma-separated string of subtarget names</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.SetName">
<short>Sets the name of the target</short>
<descr>
<p>Sets the name of the target, which is used for identification and display purposes.</p>
<p>The name must be unique within the containing package.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.SetName.AValue">
<short>New name for the target</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.SetExeName">
<short>Sets the executable name for the target</short>
<descr>
<p>Sets the executable filename that will be generated for program targets.</p>
<p>This overrides the default naming based on the target name.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.SetExeName.AValue">
<short>Executable filename to use</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.SetXML">
<short>Sets XML configuration data for the target</short>
<descr>
<p>Sets XML configuration data associated with the target.</p>
<p>This XML data can contain target-specific build configuration and metadata.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.SetXML.AValue">
<short>XML configuration string to set</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.GetCleanFiles">
<short>Gets list of files to be cleaned for this target</short>
<descr>
<p>Populates the provided string list with filenames that should be deleted
during clean operations for this target. This includes compiled object files,
executables, and other generated artifacts.</p>
<p>The file paths are adjusted according to the CPU, OS, and subtarget parameters
to match the actual build output locations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.List">
<short>String list to populate with filenames</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.APrefixU">
<short>Unit file path prefix</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.APrefixB">
<short>Binary file path prefix</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.aSubTarget">
<short>Subtarget name for clean operation</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.GetArchiveFiles">
<short>Gets list of files to be archived for this target</short>
<descr>
<p>Populates the provided string list with filenames that should be included
in distribution archives for this target. This typically includes compiled
binaries, documentation, and required resource files.</p>
<p>Files are filtered based on the target CPU and OS to ensure only relevant
files are included in platform-specific archives.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetArchiveFiles.List">
<short>String list to populate with archive filenames</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetArchiveFiles.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetArchiveFiles.AOS">
<short>Target operating system</short>
</element>

<!-- procedure Visibility: public -->
<element name="TTarget.GetInstallFiles">
<short>Gets list of files to be installed for this target</short>
<descr>
<p>Populates the provided string list with filenames that should be copied
during installation operations for this target. This includes compiled units,
binaries, documentation, and resource files.</p>
<p>Installation paths are calculated based on the target type, CPU, OS, and
the configured installation directories for units, binaries, and documentation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.List">
<short>String list to populate with install filenames</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.APrefixU">
<short>Unit file path prefix</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.APrefixB">
<short>Binary file path prefix</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.aSubTarget">
<short>Subtarget name for install operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetCleanFiles.aTarget">
<short>Target object for clean operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetInstallFiles.aTarget">
<short>Target object for install operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TTarget.GetArchiveFiles.aTarget">
<short>Target object for archive operation</short>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Dependencies">
<short>Collection of target dependencies</short>
<descr>
<p>Collection containing all dependencies required by this target.</p>
<p>Dependencies include units, packages, and include files that must be available
for successful compilation of this target.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.ResourceFiles">
<short>Collection of resource files for the target</short>
<descr>
<p>Collection containing resource files that will be linked into this target.</p>
<p>Resource files can include icons, bitmaps, version information, and other embedded resources.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Commands">
<short>Collection of custom commands for the target</short>
<descr>
<p>Collection containing custom commands that will be executed during build phases.</p>
<p>Commands can be configured to run before or after compilation, installation, cleaning, or archiving.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.State">
<short>Current build state of the target</short>
<descr>
<p>Current state of the target in the build process.</p>
<p>States include neutral, considering, no compile, compiled, installed, and not found.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.TargetType">
<short>Type of the build target</short>
<descr>
<p>Specifies the type of target: program, unit, implicit unit, clean-only unit,
example unit, example program, fpdoc documentation, or shared library.</p>
<p>The target type determines compilation options and output file handling.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.OSes">
<short>Set of operating systems this target supports</short>
<descr>
<p>Set of operating systems for which this target should be compiled.</p>
<p>If empty, the target is compiled for all operating systems. Used for conditional compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.CPUs">
<short>Set of CPU architectures this target supports</short>
<descr>
<p>Set of CPU architectures for which this target should be compiled.</p>
<p>If empty, the target is compiled for all CPU architectures. Used for conditional compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.SubTargets">
<short>Array of subtarget names for this target</short>
<descr>
<p>Array containing names of subtargets that can be built for this target.</p>
<p>Subtargets allow building different variants of the same target with different configurations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Mode">
<short>Compiler mode for the target</short>
<descr>
<p>Compiler mode used when compiling this target.</p>
<p>Modes include FPC, Turbo Pascal, Object Pascal, Delphi, Mac Pascal, and Delphi Unicode.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Options">
<short>Compiler options for the target</short>
<descr>
<p>String list containing compiler options that will be passed to the Free Pascal Compiler
when compiling this target.</p>
<p>Options include optimization settings, debugging flags, and compiler directives.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.SourceFileName">
<short>Resolved source file name for the target</short>
<descr>
<p>Full path to the main source file for this target after path resolution.</p>
<p>This is the primary Pascal source file that will be compiled for this target.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.UnitFileName">
<short>Resolved unit file name for the target</short>
<descr>
<p>Full path to the compiled unit file (.ppu) that will be generated for this target.</p>
<p>This file contains the compiled unit interface and implementation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.ObjectFileName">
<short>Resolved object file name for the target</short>
<descr>
<p>Full path to the object file (.o) that will be generated for this target.</p>
<p>This file contains the compiled machine code for the target.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.LTOFileName">
<short>Link-time optimization file name for the target</short>
<descr>
<p>Full path to the link-time optimization file generated for this target.</p>
<p>This file is used for advanced optimization during the linking phase.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.RSTFileName">
<short>Resource string table filename for the target</short>
<descr>
<p><var>RSTFileName</var> contains the full path to the resource string table file (.rst) for this target.
This file contains string resources and translation information used by the application.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.RSJFileName">
<short>Resource string JSON filename for the target</short>
<descr>
<p><var>RSJFileName</var> contains the full path to the resource string JSON file (.rsj) for this target.
This file contains string resources in JSON format for internationalization support.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.FPCTarget">
<short>FPC compiler target specification</short>
<descr>
<p><var>FPCTarget</var> specifies the target platform and architecture for the Free Pascal Compiler.
This setting determines the output format and platform-specific code generation for the target.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Extension">
<short>File extension for the compiled target</short>
<descr>
<p><var>Extension</var> contains the file extension (without the dot) for the compiled output file.
This extension varies based on the target type, such as 'exe' for programs or 'dll' for libraries.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.FileType">
<short>Type of file this target generates</short>
<descr>
<p><var>FileType</var> indicates the category of file this target produces, such as executable program,
dynamic library, static library, or unit. This determines compilation and linking behavior.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Directory">
<short>Directory where the target source files are located</short>
<descr>
<p><var>Directory</var> specifies the directory path containing the source files for this target.
This path is used to resolve relative file references during compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.ResourceStrings">
<short>Whether to generate resource string support for the target</short>
<descr>
<p><var>ResourceStrings</var> determines whether the compiler generates resource string support files
for this target. When <var>True</var>, .rst and .rsj files are created for internationalization.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.Install">
<short>Whether this target should be installed</short>
<descr>
<p><var>Install</var> controls whether this target is included in the installation process.
When <var>True</var>, the compiled target file is copied to the installation directory.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.TargetSourceFileName">
<short>Source filename for the build target</short>
<descr>
<p><var>TargetSourceFileName</var> contains the name of the main source file for this target.
This is the primary Pascal source file that serves as the entry point for compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.ObjectPath">
<short>Path for object files generated during compilation</short>
<descr>
<p><var>ObjectPath</var> specifies the directory path where object files (.o) are stored during compilation.
This allows separation of intermediate compilation files from source code directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.UnitPath">
<short>Search path for unit files during compilation</short>
<descr>
<p><var>UnitPath</var> contains the search directories for compiled unit files (.ppu) during compilation.
The compiler searches these paths to locate required units referenced by this target.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.IncludePath">
<short>Search path for include files during compilation</short>
<descr>
<p><var>IncludePath</var> contains the search directories for include files during compilation.
The compiler searches these paths to locate files referenced by {$INCLUDE} directives.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.XML">
<short>Whether to generate XML documentation for the target</short>
<descr>
<p><var>XML</var> determines whether the compiler generates XML documentation output for this target.
When <var>True</var>, structured documentation is extracted from source code comments.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.IsFPMakePlugin">
<short>Whether this target is an FPMake plugin</short>
<descr>
<p><var>IsFPMakePlugin</var> indicates whether this target is a plugin for the FPMake build system.
Plugin targets provide extended functionality and are loaded dynamically during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.BeforeCompile">
<short>Event handler executed before target compilation</short>
<descr>
<p><var>BeforeCompile</var> is an event handler called immediately before this target is compiled.
This allows custom preprocessing or validation logic to be executed before compilation begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.AfterCompile">
<short>Event handler executed after target compilation</short>
<descr>
<p><var>AfterCompile</var> is an event handler called immediately after this target is successfully compiled.
This allows custom post-processing or validation logic to be executed after compilation completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.BeforeClean">
<short>Event handler executed before target cleanup</short>
<descr>
<p><var>BeforeClean</var> is an event handler called before this target's generated files are cleaned.
This allows custom cleanup preparation or backup operations before file removal.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTarget.AfterClean">
<short>Event handler executed after target cleanup</short>
<descr>
<p><var>AfterClean</var> is an event handler called immediately after this target's generated files
have been cleaned and removed.</p>
<p>This allows custom post-cleanup operations, logging, or verification that cleanup completed successfully.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TTargetEnumerator">
<short>Enumerator for iterating through build targets</short>
<descr>
<p><var>TTargetEnumerator</var> provides enumeration support for iterating through collections
of build targets in a for-in loop construct.</p>
<p>This enumerator enables convenient iteration over target collections with automatic
position tracking and bounds checking.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TTargetEnumerator.GetCurrent">
<short>Gets current build target in enumeration</short>
<descr>
<p>Returns the <link id="TTarget">TTarget</link> object at the current enumeration position.</p>
<p>This method provides access to the target's properties and methods during iteration
through the target collection.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargetEnumerator.GetCurrent.Result">
<short>Current build target object</short>
</element>

<!-- property Visibility: public -->
<element name="TTargetEnumerator.Current">
<short>Current build target being enumerated</short>
<descr>
<p>Property providing read-only access to the <link id="TTarget">TTarget</link> object
at the current enumeration position.</p>
<p>This property returns the target object that can be processed during for-in loop iteration.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddFPDoc">
<short>Adds a documentation target to the collection</short>
<descr>
<p>Creates and adds a new FPDoc documentation target that generates HTML or other
documentation formats from Pascal source code and XML documentation files.</p>
<p>The documentation target processes the specified unit file and corresponding
XML documentation file to produce formatted documentation output.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddFPDoc.Result">
<short>Newly created FPDoc documentation target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddFPDoc.AUnitName">
<short>Unit name for documentation generation</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddFPDoc.AXMLName">
<short>XML documentation file name</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddUnit">
<short>Adds a unit target to the collection</short>
<descr>
<p>Creates and adds a new unit target with the specified name to the target collection.
The unit will be compiled as a regular Pascal unit and can optionally be restricted to specific
CPU architectures and operating systems.</p>
</descr>
<seealso>
<link id="TTargets.AddProgram">AddProgram</link>
<link id="TTargets.AddLibrary">AddLibrary</link>
<link id="TTargets.AddImplicitUnit">AddImplicitUnit</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddUnit.Result">
<short>Newly created unit target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddUnit.AUnitName">
<short>Name of the unit to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddUnit.OSes">
<short>Set of operating systems for which this unit should be compiled</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddUnit.CPUs">
<short>Set of CPU architectures for which this unit should be compiled</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddImplicitUnit">
<short>Adds an implicit unit target to the collection</short>
<descr>
<p>Creates and adds a new implicit unit target that is compiled automatically
as a dependency without explicit reference in the build script.</p>
<p>Implicit units are typically used for helper modules and internal dependencies
that do not need separate installation or distribution.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddImplicitUnit.Result">
<short>Newly created implicit unit target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddImplicitUnit.AUnitName">
<short>Unit name for the implicit unit</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddImplicitUnit.InstallUnit">
<short>Whether to install this implicit unit</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddImplicitUnit.OSes">
<short>Set of operating systems for this implicit unit</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddImplicitUnit.CPUs">
<short>Set of CPU architectures for this implicit unit</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddProgram">
<short>Adds a program target to the collection</short>
<descr>
<p>Creates and adds a new program target with the specified name to the target collection.
The program will be compiled as an executable and can optionally be restricted to specific
CPU architectures and operating systems.</p>
</descr>
<seealso>
<link id="TTargets.AddUnit">AddUnit</link>
<link id="TTargets.AddLibrary">AddLibrary</link>
<link id="TTargetType.ttProgram">ttProgram</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddProgram.Result">
<short>Newly created program target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddProgram.AProgramName">
<short>Name of the program to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddProgram.OSes">
<short>Set of operating systems for this program</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddProgram.CPUs">
<short>Set of CPU architectures for this program</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddLibrary">
<short>Adds a library target to the collection</short>
<descr>
<p>Creates and adds a new library target with the specified name to the target collection.
The library will be compiled as a shared library and can optionally be restricted to specific
CPU architectures and operating systems.</p>
</descr>
<seealso>
<link id="TTargets.AddUnit">AddUnit</link>
<link id="TTargets.AddProgram">AddProgram</link>
<link id="TTargetType.ttSharedLibrary">ttSharedLibrary</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddLibrary.Result">
<short>Newly created library target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddLibrary.ALibraryName">
<short>Name of the library to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddLibrary.OSes">
<short>Set of operating systems for this library</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddLibrary.CPUs">
<short>Set of CPU architectures for this library</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddExampleUnit">
<short>Adds an example unit target to the collection</short>
<descr>
<p>Creates and adds a new example unit target that demonstrates usage patterns
and serves as sample code for package functionality.</p>
<p>Example units are typically installed separately from main package units and provide
documentation through working code examples.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddExampleUnit.Result">
<short>Newly created example unit target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleUnit.AUnitName">
<short>Unit name for the example</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleUnit.OSes">
<short>Target operating systems for example unit</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleUnit.CPUs">
<short>Target CPU architectures for example unit</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.AddExampleProgram">
<short>Adds an example program target to the collection</short>
<descr>
<p>Creates and adds a new example program target that demonstrates package functionality
through executable sample applications.</p>
<p>Example programs provide working demonstrations of package features and serve as
practical documentation for developers.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.AddExampleProgram.Result">
<short>Newly created example program target</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleProgram.AProgramName">
<short>Name of the example program to create</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleProgram.OSes">
<short>Target operating systems for example program</short>
</element>

<!-- argument Visibility: default -->
<element name="TTargets.AddExampleProgram.CPUs">
<short>Target CPU architectures for example program</short>
</element>

<!-- function Visibility: public -->
<element name="TTargets.GetEnumerator">
<short>Gets enumerator for iterating build targets</short>
<descr>
<p>Returns a <link id="TTargetEnumerator">TTargetEnumerator</link> object that enables
for-in loop iteration through the build targets collection.</p>
<p>This method enables convenient enumeration of all build targets using modern Pascal
iteration syntax.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TTargets.GetEnumerator.Result">
<short>Build target collection enumerator</short>
</element>

<!-- property Visibility: public -->
<element name="TTargets.Targets">
<short>Access to build target by name</short>
<descr>
<p>Provides named access to <link id="TTarget">TTarget</link> objects within the collection
using the target's name as the key.</p>
<p>This property enables lookup and retrieval of specific build targets by their
configured names.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TTargets.Targets.AName">
<short>Name of the build target to retrieve</short>
</element>

<!-- property Visibility: public -->
<element name="TTargets.TargetItems">
<short>Indexed access to build targets in the collection</short>
<descr>
<p>Provides indexed read-only access to <link id="TTarget">TTarget</link> objects within
the collection using zero-based array indexing.</p>
<p>This default property enables array-style access to build targets for iteration
and processing.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TTargets.TargetItems.Index">
<short>Index of the build target to retrieve</short>
</element>

<!-- class Visibility: default -->
<element name="TSource">
<short>Represents a source file in the build system</short>
<descr>
<p><var>TSource</var> represents a single source code file within the Free Pascal build system,
tracking file paths, names, and build-related properties.</p>
<p>This class manages individual source files that are compiled as part of build targets,
including dependency tracking and compilation settings.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TSource.Create">
<short>Creates a new source file entry</short>
<descr>
<p>Initializes a new <var>TSource</var> instance within the specified collection,
setting up the source file entry for build processing.</p>
<p>The source entry is configured with default settings and linked to its parent collection
for management during the build process.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSource.Create.ACollection">
<short>Collection that owns this source file</short>
</element>

<!-- destructor Visibility: public -->
<element name="TSource.Destroy">
<short>Destroys the source file entry and releases resources</short>
<descr>
<p>Releases all resources associated with the source file entry and performs cleanup
of any allocated memory or references.</p>
<p>This destructor ensures proper cleanup when the source file entry is removed from
the build system.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TSource.GetInstallFiles">
<short>Gets list of files for installation from this source</short>
<descr>
<p>Populates the provided list with files that should be installed as part of this
source file's deployment process.</p>
<p>This method collects all files associated with this source entry that require
installation or distribution with the package.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSource.GetInstallFiles.List">
<short>List to store the source installation files</short>
</element>

<!-- property Visibility: public -->
<element name="TSource.SourceType">
<short>Type of source file (documentation, example, etc.)</short>
<descr>
<p>Specifies the category or purpose of this source file within the build system.</p>
<p>The source type determines how the file is processed, where it is installed,
and what build rules apply to it.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TSource.InstallSourcePath">
<short>Installation path for the source file</short>
<descr>
<p>Specifies the target directory path where this source file should be installed
during package deployment.</p>
<p>This path is relative to the installation base directory and determines the final
location of the source file after installation.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TSourceEnumerator">
<short>Enumerator for iterating through source collections</short>
<descr>
<p><var>TSourceEnumerator</var> provides enumeration support for iterating through
collections of source files using for-in loop constructs.</p>
<p>This enumerator enables convenient iteration over source file collections with
automatic position tracking and bounds checking.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TSourceEnumerator.GetCurrent">
<short>Gets current source file in enumeration</short>
<descr>
<p>Returns the <link id="TSource">TSource</link> object at the current enumeration position.</p>
<p>This method provides access to the source file's properties and methods during
iteration through the source collection.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSourceEnumerator.GetCurrent.Result">
<short>Current source file object</short>
</element>

<!-- property Visibility: public -->
<element name="TSourceEnumerator.Current">
<short>Current source file being enumerated</short>
<descr>
<p>Property providing read-only access to the <link id="TSource">TSource</link> object
at the current enumeration position.</p>
<p>This property returns the source file object that can be processed during
for-in loop iteration.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TSources">
<short>Collection of source files</short>
<descr>
<p><var>TSources</var> is a collection class that manages multiple source file entries
for a Free Pascal package.</p>
<p>This collection provides methods for adding different types of sources (documentation,
examples, tests) and manages their properties for building and installation.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TSources.AddDoc">
<short>Adds documentation sources to the collection</short>
<descr>
<p>Creates and adds a new documentation source entry that specifies files to be
installed in the documentation directory. The files are copied during installation
to the configured documentation installation path.</p>
<p>Documentation sources typically include readme files, manuals, API documentation,
and other informational content for the package.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSources.AddDoc.Result">
<short>Newly created documentation source item</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDoc.AFiles">
<short>List of documentation files to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDoc.AInstallSourcePath">
<short>Installation path for documentation sources</short>
</element>

<!-- function Visibility: public -->
<element name="TSources.AddSrc">
<short>Adds source files to the collection</short>
<descr>
<p>Creates and adds a new source entry that specifies Pascal source files (.pp, .pas)
to be distributed with the package. These files are typically installed for
developers who want to examine or modify the package source code.</p>
<p>Source files are separate from compiled units and provide transparency and
modification capabilities for package users.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSources.AddSrc.Result">
<short>Newly created source item</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddSrc.AFiles">
<short>List of source files to add</short>
</element>

<!-- function Visibility: public -->
<element name="TSources.AddExample">
<short>Adds example sources to the collection</short>
<descr>
<p>Creates and adds a new example source entry that specifies example program files
to be installed in the examples directory. Examples demonstrate usage of the
package functionality and serve as learning resources.</p>
<p>Example files help users understand how to properly use the package APIs
and provide working code samples for common use cases.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSources.AddExample.Result">
<short>Newly created example source item</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExample.AFiles">
<short>List of example files to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExample.AInstallSourcePath">
<short>Installation path for example sources</short>
</element>

<!-- function Visibility: public -->
<element name="TSources.AddTest">
<short>Adds test sources to the collection</short>
<descr>
<p>Creates and adds a new test source entry that specifies test program files
used for package validation and quality assurance. Test files verify that
the package functionality works correctly.</p>
<p>Test sources are typically run during development and before package
releases to ensure code quality and prevent regressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSources.AddTest.Result">
<short>Newly created test source item</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddTest.AFiles">
<short>List of test files to add</short>
</element>

<!-- function Visibility: public -->
<element name="TSources.GetEnumerator">
<short>Gets enumerator for iterating sources</short>
<descr>
<p>Returns a <link id="TSourceEnumerator">TSourceEnumerator</link> object that enables
for-in loop iteration through the source files collection.</p>
<p>This method enables convenient enumeration of all source files using modern Pascal
iteration syntax.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TSources.GetEnumerator.Result">
<short>Source collection enumerator for iteration</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSources.AddDocFiles">
<short>Adds documentation files matching file mask pattern</short>
<descr>
<p>Searches for and adds documentation files that match the specified file mask pattern
to the source collection.</p>
<p>This method provides a convenient way to add multiple documentation files at once
using wildcard patterns for file selection.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDocFiles.AFileMask">
<short>File mask pattern for matching documentation files</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDocFiles.ASearchPathPrefix">
<short>Path prefix for file search operations</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDocFiles.Recursive">
<short>Whether to search subdirectories recursively</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddDocFiles.AInstallSourcePath">
<short>Installation path for matched documentation files</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSources.AddSrcFiles">
<short>Adds source files matching file mask pattern</short>
<descr>
<p>Searches for and adds source files that match the specified file mask pattern
to the source collection.</p>
<p>This method provides a convenient way to add multiple source files at once
using wildcard patterns for file selection.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddSrcFiles.AFileMask">
<short>File mask pattern for matching source files</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddSrcFiles.ASearchPathPrefix">
<short>Path prefix for source file search operations</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddSrcFiles.Recursive">
<short>Whether to search subdirectories recursively</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSources.AddExampleFiles">
<short>Adds example files matching file mask pattern</short>
<descr>
<p><var>AddExampleFiles</var> adds example files to the source collection that match the specified file mask pattern.
The method scans for files matching <var>AFileMask</var> and adds them to be included with the package as example code.</p>
<p>Example files are typically demonstration code showing how to use the package functionality.
They are installed to the specified installation path for reference by package users.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExampleFiles.AFileMask">
<short>File mask pattern for matching example files</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExampleFiles.ASearchPathPrefix">
<short>Path prefix for example file search operations</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExampleFiles.Recursive">
<short>Whether to search subdirectories recursively</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddExampleFiles.AInstallSourcePath">
<short>Installation path for example source files</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSources.AddTestFiles">
<short>Adds test files to the source collection</short>
<descr>
<p><var>AddTestFiles</var> adds test files matching the specified file mask pattern to the source collection.
Test files contain unit tests and validation code for verifying package functionality.</p>
<p>The method searches for files matching <var>AFileMask</var> and includes them in the package for testing purposes.
Test files are used during package validation and quality assurance.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddTestFiles.AFileMask">
<short>File pattern mask for selecting test files</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddTestFiles.ASearchPathPrefix">
<short>Search path prefix for locating test files</short>
</element>

<!-- argument Visibility: default -->
<element name="TSources.AddTestFiles.Recursive">
<short>Whether to search subdirectories recursively</short>
</element>

<!-- property Visibility: public -->
<element name="TSources.SourceItems">
<short>Indexed access to source files in the collection</short>
<descr>
<p><var>SourceItems</var> provides indexed access to individual source files in the <var>TSources</var> collection.
This property allows retrieving <link id="TSourceItem">TSourceItem</link> objects by their numerical index.</p>
<p>The index is zero-based and must be within the range 0 to <var>Count</var>-1.
Each source item contains information about a single source file including its name, path, and installation settings.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TSources.SourceItems.Index">
<short>Index of the source file to retrieve</short>
</element>

<!-- constructor Visibility: public -->
<element name="TPackage.Create">
<short>Creates a new package instance</short>
<descr>
<p>Creates a new <var>TPackage</var> instance and initializes all internal collections and properties.
The constructor sets up default values and creates collections for targets, dependencies,
and other package components.</p>
</descr>
<seealso>
<link id="TPackage.destroy">destroy</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.Create.ACollection">
<short>Collection that will contain this package</short>
</element>

<!-- destructor Visibility: public -->
<element name="TPackage.destroy">
<short>Destroys the package instance and frees resources</short>
<descr>
<p>Destroys the <var>TPackage</var> instance and frees all associated resources including
target collections, dependency lists, and internal data structures.</p>
</descr>
<seealso>
<link id="TPackage.Create">Create</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TPackage.HaveOptions">
<short>Checks if package has global compilation options</short>
<descr>
<p>Returns <var>True</var> if the package has global compiler options defined, <var>False</var> otherwise.</p>
<p>These options apply to all targets in the package unless overridden.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.HaveOptions.Result">
<short><var>True</var> if package has options, <var>False</var> otherwise</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.GetUnitsOutputDir">
<short>Returns the output directory for compiled units</short>
<descr>
<p>Returns the directory where compiled unit files (.ppu) will be placed for the specified
CPU, OS, and subtarget combination.</p>
<p>The directory path is constructed based on package configuration and platform settings.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.GetUnitsOutputDir.Result">
<short>Path to units output directory</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitsOutputDir.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitsOutputDir.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitsOutputDir.aSubTarget">
<short>Subtarget name for output directory</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.GetUnitConfigOutputFilename">
<short>Gets output filename for unit configuration file</short>
<descr>
<p>Returns the filename for the unit configuration file (.fpc) that contains build settings and unit paths
for the specified CPU, OS, and subtarget combination. This file is used by the compiler to locate units and configure compilation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.GetUnitConfigOutputFilename.Result">
<short>Unit configuration output filename</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitConfigOutputFilename.ACPU">
<short>Target CPU architecture for configuration</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitConfigOutputFilename.AOS">
<short>Target operating system for configuration</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitConfigOutputFilename.aSubTarget">
<short>Subtarget for unit configuration</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.GetBinOutputDir">
<short>Returns the output directory for binary files</short>
<descr>
<p>Returns the directory where binary files (executables, libraries) will be placed for
the specified CPU, OS, and subtarget combination.</p>
<p>Binary files include programs and shared libraries generated by the build process.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.GetBinOutputDir.Result">
<short>Path to binary output directory</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetBinOutputDir.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetBinOutputDir.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetBinOutputDir.aSubTarget">
<short>Subtarget name for output directory</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetCleanFiles">
<short>Gets list of files to be cleaned for the package</short>
<descr>
<p>Populates the provided list with filenames of all generated files that should be removed during package cleanup.
This includes compiled units, object files, executables, and other build artifacts for the specified target platform.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetCleanFiles.List">
<short>List to store files for cleanup</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetCleanFiles.ACPU">
<short>Target CPU architecture for cleanup</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetCleanFiles.AOS">
<short>Target operating system for cleanup</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetCleanFiles.aSubTarget">
<short>Subtarget for file cleanup</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetArchiveFiles">
<short>Gets list of files to include in package archive</short>
<descr>
<p>Populates the provided list with filenames of all files that should be included when creating a package archive.
This includes source files, documentation, examples, and other distributable content for the specified target platform.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetArchiveFiles.List">
<short>List to store files for archiving</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetArchiveFiles.ACPU">
<short>Target CPU architecture for archive</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetArchiveFiles.AOS">
<short>Target operating system for archive</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitsOutputDir.aTarget">
<short>Build target for unit output directory</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetUnitConfigOutputFilename.aTarget">
<short>Build target for unit configuration filename</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.InheritPackageVariantsFromDependency">
<short>Inherits package variants from a dependency package</short>
<descr>
<p>Copies package variants from a dependency package into this package, allowing build configurations
to be inherited through the dependency chain. This ensures consistent variant settings across dependent packages.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.InheritPackageVariantsFromDependency.ADependencyPackage">
<short>Dependency package from which to inherit variants</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.GetPackageVariantsByName">
<short>Gets package variants collection by name</short>
<descr>
<p>Searches for and returns a package variants collection with the specified name.
Returns <var>nil</var> if no variants collection with the given name is found.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.GetPackageVariantsByName.Result">
<short>Package variants collection with the specified name</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetPackageVariantsByName.AName">
<short>Name of the package variants collection to retrieve</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.SetUnitsOutputDir">
<short>Sets the output directory for compiled units</short>
<descr>
<p>Sets the base directory where compiled unit files (.ppu) will be stored for this package.
The actual output location may include subdirectories based on CPU and OS target settings.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SetUnitsOutputDir.AValue">
<short>Directory path for unit output files</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.GetPackageUnitInstallDir">
<short>Gets installation directory for package units</short>
<descr>
<p>Returns the directory path where compiled unit files for this package will be installed
for the specified CPU and OS combination. This is where other packages will look for this package's units.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.GetPackageUnitInstallDir.Result">
<short>Package unit installation directory path</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetPackageUnitInstallDir.ACPU">
<short>Target CPU architecture for unit installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetPackageUnitInstallDir.AOS">
<short>Target operating system for unit installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetPackageUnitInstallDir.aSubTarget">
<short>Subtarget for unit installation directory</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.SetPackageUnitInstallDir">
<short>Sets installation directory for package units</short>
<descr>
<p>Sets the directory where compiled unit files for this package will be installed.
This directory is where other packages will search for this package's compiled units during their own build process.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SetPackageUnitInstallDir.AValue">
<short>Directory path for unit installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetBinOutputDir.aTarget">
<short>Build target for binary output directory</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetCleanFiles.aTarget">
<short>Build target for file cleanup</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetInstallFiles">
<short>Gets list of files to be installed for the package</short>
<descr>
<p>Populates the provided list with files that should be installed when deploying this package.
The file types parameter controls which categories of files are included in the installation list.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallFiles.List">
<short>List to store installation files</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallFiles.Types">
<short>File types to include in installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallFiles.aTarget">
<short>Build target for installation files</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetInstallSourceFiles">
<short>Gets list of source files to be installed</short>
<descr>
<p>Populates the provided list with source files (.pp, .pas, .inc) that should be installed
for developer access. This allows users to examine and modify the package source code.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallSourceFiles.List">
<short>List to store source installation files</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallSourceFiles.SourceTypes">
<short>Source file types to include in installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetInstallSourceFiles.TargetTypes">
<short>Target types for source file installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetArchiveFiles.aTarget">
<short>Build target for archive files</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetArchiveSourceFiles">
<short>Gets list of source files for package archive</short>
<descr>
<p>Populates the provided list with source files that should be included when creating a distributable package archive.
This includes Pascal source files, include files, and other source-related content for the specified target platform.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetArchiveSourceFiles.List">
<short>List to store source files for archiving</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.GetManifest">
<short>Gets package manifest information</short>
<descr>
<p><var>GetManifest</var> populates the provided manifest object with information about the package.
This includes package metadata, version details, dependencies, targets, and other package configuration data.</p>
<p>The manifest contains structured information that can be used for package registration, dependency resolution,
and package management operations within the fpmake system.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.GetManifest.Manifest">
<short>Manifest object to store package information</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.ListPackage">
<short>Lists package information to a string list</short>
<descr>
<p>Populates the provided string list with detailed information about this package including name, version,
description, targets, dependencies, and other configuration details for diagnostic or reporting purposes.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.ListPackage.PkgList">
<short>String list to store package information</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.AddPackageVariant">
<short>Adds a package variant to the package</short>
<descr>
<p>Adds an existing package variant object to this package, making it available for use during builds.
The variant provides alternative build configurations with different compiler options and settings.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.AddPackageVariant.APackageVariant">
<short>Package variant to add to the package</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.ApplyPackageVariantToCompilerOptions">
<short>Applies package variant settings to compiler options</short>
<descr>
<p><var>ApplyPackageVariantToCompilerOptions</var> modifies the provided compiler options by applying settings
from the package variant configuration. Package variants allow customizing compilation parameters
for different build scenarios or target configurations.</p>
<p>This method ensures that variant-specific compiler flags, include paths, and other compilation settings
are properly applied to the build process.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.ApplyPackageVariantToCompilerOptions.ACompilerOptions">
<short>Compiler options to modify with variant settings</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.SetDefaultPackageVariant">
<short>Sets the default package variant for the package</short>
<descr>
<p>Sets the package variant that will be used when no specific variant is requested during the build process.
This ensures consistent default behavior for package compilation and installation.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.LoadUnitConfigFromFile">
<short>Loads unit configuration from a file</short>
<descr>
<p>Loads unit search paths and configuration settings from an existing unit configuration file (.fpc).
This allows restoration of previously saved compiler configuration for consistent builds.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.LoadUnitConfigFromFile.AFileName">
<short>Filename of the unit configuration file to load</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.SaveUnitConfigToFile">
<short>Saves unit configuration to a file</short>
<descr>
<p>Saves current unit search paths and configuration settings to a unit configuration file (.fpc) for the specified
CPU and OS combination. This file can later be used by the compiler for consistent build settings.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SaveUnitConfigToFile.AFileName">
<short>Filename to save unit configuration to</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SaveUnitConfigToFile.ACPU">
<short>Target CPU architecture for configuration</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SaveUnitConfigToFile.AOS">
<short>Target operating system for configuration</short>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.EnterResolveDirsCS">
<short>Enters critical section for directory resolution</short>
<descr>
<p>Enters a critical section to ensure thread-safe access during directory path resolution operations.
This prevents race conditions when multiple threads are resolving directory paths simultaneously.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.LeaveResolveDirsCS">
<short>Leaves critical section for directory resolution</short>
<descr>
<p>Exits the critical section for directory path resolution operations, allowing other threads to access
directory resolution functions. Must be called after every call to <var>EnterResolveDirsCS</var>.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TPackage.ApplyNameSpaces">
<short>Applies namespace settings to a filename</short>
<descr>
<p>Applies package namespace prefixes and transformations to a filename based on the current namespace
settings and the specified build target. This supports namespaced unit organization and naming.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.ApplyNameSpaces.aEngine">
<short>Build engine for namespace processing</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.ApplyNameSpaces.aFileName">
<short>Filename to apply namespace settings to</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.ApplyNameSpaces.aTarget">
<short>Build target for namespace processing</short>
</element>

<!-- function Visibility: public -->
<element name="TPackage.SubTargetAllowed">
<short>Checks if a subtarget is allowed for the package</short>
<descr>
<p>Returns <var>True</var> if the specified subtarget is allowed for this package based on current configuration
and constraints. This is used to validate subtarget availability before attempting to build.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackage.SubTargetAllowed.Result">
<short>Whether the subtarget is allowed</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackage.SubTargetAllowed.aSubTarget">
<short>Subtarget to check for availability</short>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Version">
<short>Version string of the package</short>
<descr>
<p>The <var>Version</var> property contains the version string of the package.
This version is used for dependency checking and package identification.</p>
</descr>
<seealso>
<link id="TFPVersion">TFPVersion</link>
<link id="TPackage.PackageVersion">PackageVersion</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPackage.FileName">
<short>Filename of the package definition file</short>
<descr>
<p><var>FileName</var> contains the full path to the package definition file (typically fpmake.pp)
that describes this package's configuration, targets, and dependencies.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.ShortName">
<short>Short name identifier for the package</short>
<descr>
<p><var>ShortName</var> provides a concise identifier for the package, typically used in package listings
and references. This is usually a brief version of the full package name.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.HomepageURL">
<short>URL of the package homepage</short>
<descr>
<p><var>HomepageURL</var> contains the web address of the package's official homepage or project site.
This provides users with access to documentation, news, and additional information about the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.DownloadURL">
<short>URL for downloading the package</short>
<descr>
<p><var>DownloadURL</var> specifies the web address where the package can be downloaded.
This is used by package management systems to retrieve the package source code or binaries.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Email">
<short>Contact email address for the package</short>
<descr>
<p><var>Email</var> contains the contact email address for the package maintainer or author.
This provides a way for users to report issues, ask questions, or contribute to the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Author">
<short>Author or maintainer of the package</short>
<descr>
<p><var>Author</var> contains the name of the person or organization responsible for creating and maintaining
the package. This provides attribution and contact information for the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.License">
<short>License terms for the package</short>
<descr>
<p><var>License</var> specifies the legal license terms under which the package is distributed.
This information helps users understand their rights and obligations when using the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Directory">
<short>Base directory path of the package</short>
<descr>
<p>The <var>Directory</var> property specifies the base directory where the package files are located.
All relative paths within the package are resolved relative to this directory.</p>
</descr>
<seealso>
<link id="TPackage.FileName">FileName</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Description">
<short>Descriptive text about the package</short>
<descr>
<p>The <var>Description</var> property contains a human-readable description of the package.
This description can be loaded from a file specified in <link id="TPackage.DescriptionFile">DescriptionFile</link>
or set directly.</p>
</descr>
<seealso>
<link id="TPackage.DescriptionFile">DescriptionFile</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPackage.DescriptionFile">
<short>File containing package description text</short>
<descr>
<p><var>DescriptionFile</var> specifies the path to a text file containing a detailed description of the package.
When set, the file contents are loaded into the <var>Description</var> property.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.InstalledChecksum">
<short>Checksum of installed package files</short>
<descr>
<p><var>InstalledChecksum</var> contains a checksum value of the installed package files.
This is used to verify package integrity and detect modifications after installation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.IsFPMakeAddIn">
<short>Whether this package is an FPMake add-in</short>
<descr>
<p><var>IsFPMakeAddIn</var> indicates whether this package provides additional functionality for the FPMake
build system itself. Add-in packages extend FPMake with custom build commands and capabilities.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.SupportBuildModes">
<short>Whether package supports different build modes</short>
<descr>
<p><var>SupportBuildModes</var> determines which build modes the installer can use when compiling this package: using a build unit or one by one, or both.</p>
</descr>
<seealso>
<link id="TPackage.BuildMode">BuildMode</link>
<link id="TCustomDefaults.BuildMode"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BuildMode">
<short>Default build mode configuration for the package</short>
<descr>
<p><var>BuildMode</var> specifies the default build mode configuration for the package, determining
whether the installer will compile using a build unit or one by one.
Note that the build mode should be in the set of suppored modes <link id="TPackage.SupportBuildModes">SupportBuildModes</link>.
</p>
</descr>
<seealso>
<link id="TPackage.SupportBuildModes">SupportBuildModes</link>
<link id="TCustomDefaults.BuildMode"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Flags">
<short>Package flags and behavior settings</short>
<descr>
<p><var>Flags</var> contains a set of flags that control various aspects of package behavior including
installation options, build preferences, and compatibility settings.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.PackageVersion">
<short>Version information for the package</short>
<descr>
<p><var>PackageVersion</var> contains detailed version information for the package including major, minor,
micro, and build numbers. This structured version data is used for precise dependency checking.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.TransmitOptions">
<short>Options transmitted to dependent packages</short>
<descr>
<p><var>TransmitOptions</var> contains compiler options that are automatically passed to packages
that depend on this package. This ensures consistent compilation settings across package hierarchies.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.OSes">
<short>Supported operating systems for the package</short>
<descr>
<p><var>OSes</var> specifies the set of operating systems on which this package can be built and used.
This includes platforms like Windows, Linux, macOS, FreeBSD, and others supported by Free Pascal.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.CPUs">
<short>Supported CPU architectures for the package</short>
<descr>
<p><var>CPUs</var> specifies the set of CPU architectures supported by this package.
This includes architectures like x86_64, i386, ARM, PowerPC, and others supported by Free Pascal.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.SubTargets">
<short>Subtarget configurations for the package</short>
<descr>
<p><var>SubTargets</var> contains the collection of subtarget configurations available for this package.
Subtargets provide specialized build configurations for different use cases or environments.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.NeedLibC">
<short>Whether package requires C library linkage</short>
<descr>
<p><var>NeedLibC</var> indicates whether this package requires linking with the C runtime library.
When <var>True</var>, the appropriate C library is automatically linked during compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Options">
<short>Compiler options for the package</short>
<descr>
<p><var>Options</var> contains the collection of compiler command-line options that are applied
when building any target within this package. These options affect all compilation within the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.UnitPath">
<short>Search paths for unit files</short>
<descr>
<p><var>UnitPath</var> contains the search paths where the compiler looks for compiled unit files (.ppu)
when building targets in this package. These paths are added to the compiler's unit search directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.ObjectPath">
<short>Search paths for object files</short>
<descr>
<p><var>ObjectPath</var> contains the search paths where the compiler and linker look for object files (.o)
when building targets in this package. These paths are added to the linker's object search directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.IncludePath">
<short>Search paths for include files</short>
<descr>
<p><var>IncludePath</var> contains the search paths where the compiler looks for include files
referenced by {$INCLUDE} directives. These paths are added to the compiler's include search directories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.SourcePath">
<short>Search paths for source files</short>
<descr>
<p>Specifies the search paths where the build system will look for Pascal source files (.pas, .pp)
required for package compilation.</p>
<p>Multiple paths can be specified, and they are searched in order when resolving unit dependencies.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.ExamplePath">
<short>Search paths for example files</short>
<descr>
<p>Specifies the search paths where example programs and units are located for this package.</p>
<p>These paths are used when building example targets and determining installation locations
for demonstration code.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.TestPath">
<short>Search paths for test files</short>
<descr>
<p>Specifies the search paths where test programs and units are located for this package.</p>
<p>These paths are used when building test targets and organizing the package's
test suite structure.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.FPDocFormat">
<short>Output format for FPDoc documentation</short>
<descr>
<p>Specifies the output format for FPDoc-generated documentation (HTML, LaTeX, XML, etc.).</p>
<p>This property controls how the package's reference documentation is formatted
when generated from source code comments and XML documentation files.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.InstallFiles">
<short>Collection of files to be installed</short>
<descr>
<p>Collection of <link id="TInstallFiles">TInstallFiles</link> objects that define which
files should be installed and their target locations.</p>
<p>This collection manages deployment of compiled units, documentation, examples,
and other package assets during installation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.CleanFiles">
<short>Collection of files to be cleaned</short>
<descr>
<p>Collection of <link id="TCleanFiles">TCleanFiles</link> objects that specify which
files and directories should be removed during cleanup operations.</p>
<p>This collection manages removal of temporary files, compiled objects,
and generated outputs during clean builds.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Dependencies">
<short>Collection of package dependencies</short>
<descr>
<p>Collection of <link id="TDependencies">TDependencies</link> objects that define
other packages required for this package to build and function correctly.</p>
<p>Dependencies are checked during build initialization to ensure all required
packages are available and properly configured.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Commands">
<short>Collection of custom build commands</short>
<descr>
<p>Collection of <link id="TCommands">TCommands</link> objects that define custom
build operations and external tool invocations.</p>
<p>Commands enable integration of external tools, pre/post-build scripts,
and specialized build operations within the package build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.State">
<short>Current build state of the package</short>
<descr>
<p>Indicates the current build state of the package (e.g., building, compiled, installed).</p>
<p>This property tracks the package's progress through the build pipeline
and is used for state-dependent operations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Targets">
<short>Collection of build targets</short>
<descr>
<p>Collection of <link id="TTargets">TTargets</link> objects that define the buildable
components of this package (units, programs, libraries).</p>
<p>Each target represents a specific compilation unit with its own build settings,
dependencies, and output configuration.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.Sources">
<short>Collection of source files</short>
<descr>
<p>Collection of <link id="TSources">TSources</link> objects that manage individual
source files associated with this package.</p>
<p>Sources include Pascal files, documentation files, examples, and other assets
required for package building and distribution.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.UnitDir">
<short>Directory for compiled unit files</short>
<descr>
<p>Specifies the directory where compiled unit files (.ppu, .o) are generated
during package compilation.</p>
<p>This directory contains the output of successful compilation and serves as input
for linking and installation operations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.UnitConfigFileName">
<short>Filename for unit configuration file</short>
<descr>
<p>Specifies the filename for the configuration file that contains unit search paths
and compilation settings for this package.</p>
<p>This file is generated during build and used by the compiler to locate
unit dependencies and apply package-specific settings.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.NamespaceMap">
<short>Mapping of unit names to namespaces</short>
<descr>
<p>String-to-string mapping that associates unit names with their corresponding
namespace prefixes for namespace-aware compilation.</p>
<p>This mapping enables proper unit resolution and prevents naming conflicts
when using namespaced units in the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeCompile">
<short>Event handler executed before package compilation</short>
<descr>
<p>Event handler called immediately before this package begins compilation.</p>
<p>This event allows custom pre-compilation setup, validation, or file preparation
to be performed before the build process starts.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeCompileProc">
<short>Procedural event handler before compilation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforeCompile">BeforeCompile</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
package compilation begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterCompile">
<short>Event handler executed after package compilation</short>
<descr>
<p>Event handler called immediately after this package completes compilation successfully.</p>
<p>This event allows custom post-compilation processing, validation, or file operations
to be performed after the build process completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterCompileProc">
<short>Procedural event handler after compilation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterCompile">AfterCompile</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
package compilation completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeInstall">
<short>Event handler executed before package installation</short>
<descr>
<p>Event handler called immediately before this package begins installation.</p>
<p>This event allows custom pre-installation setup, directory preparation,
or validation to be performed before the installation process starts.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeInstallProc">
<short>Procedural event handler before installation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforeInstall">BeforeInstall</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
package installation begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterInstall">
<short>Event handler executed after package installation</short>
<descr>
<p>Event handler called immediately after this package completes installation successfully.</p>
<p>This event allows custom post-installation processing, configuration,
or verification to be performed after installation completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterInstallProc">
<short>Procedural event handler after installation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterInstall">AfterInstall</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
package installation completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeClean">
<short>Event handler executed before package cleanup</short>
<descr>
<p>Event handler called immediately before this package begins cleanup operations.</p>
<p>This event allows custom pre-cleanup preparation or backup operations
to be performed before generated files are removed.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeCleanProc">
<short>Procedural event handler before cleanup</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforeClean">BeforeClean</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
package cleanup begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterClean">
<short>Event handler executed after package cleanup</short>
<descr>
<p>Event handler called immediately after this package completes cleanup operations.</p>
<p>This event allows custom post-cleanup verification or additional cleanup
operations to be performed after generated files are removed.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterCleanProc">
<short>Procedural event handler after cleanup</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterClean">AfterClean</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
package cleanup completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeArchive">
<short>Event handler executed before package archiving</short>
<descr>
<p>Event handler called immediately before this package begins archive creation.</p>
<p>This event allows custom pre-archiving operations, file preparation,
or validation to be performed before archive generation starts.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeArchiveProc">
<short>Procedural event handler before archiving</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforeArchive">BeforeArchive</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
package archiving begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterArchive">
<short>Event handler executed after package archiving</short>
<descr>
<p>Event handler called immediately after this package completes archive creation.</p>
<p>This event allows custom post-archiving operations, validation, or distribution
to be performed after the archive is successfully generated.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterArchiveProc">
<short>Procedural event handler after archiving</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterArchive">AfterArchive</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
package archiving completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeManifest">
<short>Event handler executed before manifest creation</short>
<descr>
<p>Event handler called immediately before this package begins manifest file generation.</p>
<p>This event allows custom pre-manifest operations, content preparation,
or validation to be performed before manifest creation starts.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforeManifestProc">
<short>Procedural event handler before manifest creation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforeManifest">BeforeManifest</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
manifest creation begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterManifest">
<short>Event handler executed after manifest creation</short>
<descr>
<p>Event handler called immediately after this package completes manifest file generation.</p>
<p>This event allows custom post-manifest operations, validation, or processing
to be performed after the manifest is successfully created.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterManifestProc">
<short>Procedural event handler after manifest creation</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterManifest">AfterManifest</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
manifest creation completes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforePkgList">
<short>Event handler executed before package listing</short>
<descr>
<p>Event handler called immediately before this package generates its file listing.</p>
<p>This event allows custom pre-listing operations, file preparation, or validation
to be performed before the package list is created.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.BeforePkgListProc">
<short>Procedural event handler before package listing</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.BeforePkgList">BeforePkgList</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed before
package listing begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterPkgList">
<short>Event handler executed after package listing</short>
<descr>
<p>Event handler called immediately after this package completes its file listing generation.</p>
<p>This event allows custom post-listing operations, validation, or processing
to be performed after the package list is created.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TPackage.AfterPkgListProc">
<short>Procedural event handler after package listing</short>
<descr>
<p>Procedural event handler version of <link id="TPackage.AfterPkgList">AfterPkgList</link>
that provides a simpler callback interface.</p>
<p>This event enables procedural callback functions to be executed after
package listing completes.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TPackageEnumerator">
<short>Enumerator for iterating through package collections</short>
<descr>
<p><var>TPackageEnumerator</var> provides iteration support for <var>TPackages</var> collections using the for-in syntax.
This class implements the enumerator pattern allowing convenient iteration through package collections.</p>
<p>The enumerator maintains the current position and provides access to the current <link id="TPackage">TPackage</link> object
during iteration loops.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TPackageEnumerator.GetCurrent">
<short>Gets current package in enumeration</short>
<descr>
<p><var>GetCurrent</var> returns the <link id="TPackage">TPackage</link> object at the current position in the enumeration.
This method is used internally by the enumerator to provide the current package during for-in loops.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackageEnumerator.GetCurrent.Result">
<short>Current package object</short>
</element>

<!-- property Visibility: public -->
<element name="TPackageEnumerator.Current">
<short>Current package being enumerated</short>
<descr>
<p><var>Current</var> property provides read-only access to the <link id="TPackage">TPackage</link> object
at the current position during enumeration. This property is used by for-in loops to access the current package.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TPackages">
<short>Collection of packages</short>
<descr>
<p><var>TPackages</var> is a managed collection class that stores and provides access to multiple <link id="TPackage">TPackage</link> objects.
This class supports enumeration, indexed access, and package lookup by name.</p>
<p>The collection manages package objects and provides various methods for adding, accessing, and iterating through packages
in the fpmake build system.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TPackages.AddPackage">
<short>Adds a new package to the collection</short>
<descr>
<p><var>AddPackage</var> creates and adds a new <link id="TPackage">TPackage</link> object to the collection with the specified name.
The method returns the newly created package object for further configuration.</p>
<p>Each package in the collection must have a unique name. The created package can then be configured
with targets, dependencies, and other package-specific settings.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackages.AddPackage.Result">
<short>Newly created package object</short>
</element>

<!-- argument Visibility: default -->
<element name="TPackages.AddPackage.AName">
<short>Name for the new package</short>
</element>

<!-- function Visibility: public -->
<element name="TPackages.GetEnumerator">
<short>Gets enumerator for iterating packages</short>
<descr>
<p><var>GetEnumerator</var> returns a <link id="TPackageEnumerator">TPackageEnumerator</link> object that enables
for-in loop iteration through all packages in the collection.</p>
<p>This method is called automatically by the compiler when using for-in syntax with package collections.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TPackages.GetEnumerator.Result">
<short>Package collection enumerator</short>
</element>

<!-- property Visibility: public -->
<element name="TPackages.Packages">
<short>Access to packages by name</short>
<descr>
<p><var>Packages</var> property provides name-based access to <link id="TPackage">TPackage</link> objects in the collection.
This allows retrieving packages by their string name identifier.</p>
<p>If a package with the specified name does not exist, the property returns <var>nil</var>.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TPackages.Packages.AName">
<short>Name of the package to retrieve</short>
</element>

<!-- property Visibility: public -->
<element name="TPackages.PackageItems">
<short>Indexed access to packages in the collection</short>
<descr>
<p><var>PackageItems</var> provides zero-based indexed access to <link id="TPackage">TPackage</link> objects in the collection.
The index must be within the range 0 to <var>Count</var>-1.</p>
<p>This property enables accessing packages by their position in the collection rather than by name.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TPackages.PackageItems.AIndex">
<short>Index of the package to retrieve</short>
</element>

<!-- class Visibility: default -->
<element name="TCustomDefaults">
<short>Base class for build system default configurations</short>
<descr>
<p><var>TCustomDefaults</var> serves as the base class for managing default configuration settings in the fpmake build system.
This abstract class provides a foundation for storing and accessing system-wide defaults and build preferences.</p>
<p>Derived classes extend this base to provide specific configuration management for different aspects
of the build system such as compiler settings, paths, and installation options.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TCustomDefaults.Create">
<short>Creates a new defaults configuration object</short>
<descr>
<p><var>Create</var> initializes a new <var>TCustomDefaults</var> instance with default configuration values.
This constructor sets up the basic configuration structure for the fpmake build system.</p>
<p>The created object serves as a container for various build system defaults including paths,
compiler options, and installation preferences.</p>
</descr>
</element>

<!-- destructor Visibility: public -->
<element name="TCustomDefaults.Destroy">
<short>Destroys the defaults object and releases resources</short>
<descr>
<p>Destroys the <var>TCustomDefaults</var> instance and releases all associated resources including
configuration collections and internal data structures.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.InitDefaults">
<short>Initializes default configuration values</short>
<descr>
<p>Sets up the default configuration values for this defaults object. This method is called during
initialization to establish baseline configuration settings that can be overridden by specific values.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCustomDefaults.HaveOptions">
<short>Checks if configuration options are available</short>
<descr>
<p>Returns <var>True</var> if this defaults object contains configuration options that can be applied.
This is used to determine whether additional configuration processing is needed.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCustomDefaults.HaveOptions.Result">
<short>Whether configuration options are available</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.AddOption">
<short>Adds a configuration option to the defaults</short>
<descr>
<p>Adds a configuration option string to this defaults object. The option becomes part of the default
configuration that is applied to targets and builds using these defaults.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.AddOption.aValue">
<short>Option value to add to configuration</short>
</element>

<!-- function Visibility: public -->
<element name="TCustomDefaults.IsBuildDifferentFromTarget">
<short>Checks if build configuration differs from target</short>
<descr>
<p>Returns <var>True</var> if the current build configuration differs from the target's default configuration.
This is used to determine whether custom build settings need to be applied.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCustomDefaults.IsBuildDifferentFromTarget.Result">
<short>Whether build differs from target configuration</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.CompilerDefaults">
<short>Sets up compiler default configuration</short>
<descr>
<p>Initializes the default compiler configuration settings including standard options, search paths,
and compilation flags that are applied by default to all builds using these defaults.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.LocalInit">
<short>Initializes configuration from local file</short>
<descr>
<p>Loads configuration settings from a local initialization file. This allows customization of
default settings based on local environment or user preferences.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.LocalInit.AFileName">
<short>Local configuration filename to load</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.LoadFromFile">
<short>Loads configuration settings from a file</short>
<descr>
<p>Loads configuration settings from the specified file, replacing the current default configuration.
The file should contain configuration options in a format compatible with the defaults system.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.LoadFromFile.AFileName">
<short>Configuration filename to load from</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.SaveToFile">
<short>Saves configuration settings to a file</short>
<descr>
<p>Saves the current default configuration settings to the specified file. This allows preservation
of customized default settings for future use or distribution.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.SaveToFile.AFileName">
<short>Configuration filename to save to</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.SaveToStream">
<short>Saves configuration settings to a stream</short>
<descr>
<p>Saves the current default configuration settings to the provided stream. This allows flexible
output of configuration data to various stream-based destinations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.SaveToStream.S">
<short>Stream to write configuration to</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCustomDefaults.LoadFromStream">
<short>Loads configuration settings from a stream</short>
<descr>
<p>Loads default configuration settings from the provided stream. This enables flexible
input of configuration data from various stream-based sources.</p>
<p>The loaded settings become the new defaults for subsequent build operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCustomDefaults.LoadFromStream.S">
<short>Stream to read configuration from</short>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.CompileTarget">
<short>Target configuration for compilation</short>
<descr>
<p>Specifies the target configuration used for compilation operations.</p>
<p>This property defines the build settings and parameters that are applied
to targets during the compilation process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Target">
<short>Build target specification</short>
<descr>
<p>Specifies the build target name or identifier for default configuration.</p>
<p>This property is used to identify which target-specific settings should be
applied during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.OS">
<short>Target operating system</short>
<descr>
<p>Specifies the target operating system for compilation (Windows, Linux, Darwin, etc.).</p>
<p>This property determines OS-specific compiler settings and conditional compilation
directives that are applied during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.CPU">
<short>Target CPU architecture</short>
<descr>
<p>Specifies the target CPU architecture for compilation (i386, x86_64, ARM, etc.).</p>
<p>This property determines CPU-specific compiler settings and optimizations
that are applied during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SubTarget">
<short>Subtarget configuration name</short>
<descr>
<p>Specifies the subtarget configuration identifier for specialized build variants.</p>
<p>Subtargets enable fine-grained control over compilation settings for specific
use cases or deployment scenarios.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SourceOS">
<short>Source operating system for cross-compilation</short>
<descr>
<p>Specifies the source operating system when performing cross-compilation operations.</p>
<p>This property is used to configure the build environment when compiling
for a different OS than the build host.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SourceCPU">
<short>Source CPU architecture for cross-compilation</short>
<descr>
<p>Specifies the source CPU architecture when performing cross-compilation operations.</p>
<p>This property is used to configure the build environment when compiling
for a different CPU architecture than the build host.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.CompilerVersion">
<short>Version of the compiler being used</short>
<descr>
<p>Contains the version string of the Free Pascal compiler being used for builds.</p>
<p>This property provides version information for compatibility checking and
build environment reporting.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.CompilerDate">
<short>Build date of the compiler</short>
<descr>
<p>Contains the build date of the Free Pascal compiler being used for builds.</p>
<p>This property provides date information for build tracking and environment
verification purposes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.FullCompilerVersion">
<short>Full version string of the compiler</short>
<descr>
<p>Contains the complete version identification string of the Free Pascal compiler.</p>
<p>This includes version number, build date, target platform information,
and other detailed compiler identification data.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.ExplicitOSNone">
<short>Whether to explicitly specify no target OS</short>
<descr>
<p>Boolean flag that controls whether to explicitly specify no target operating system.</p>
<p>When <var>True</var>, the build system will not set any OS-specific compilation flags,
resulting in generic or OS-independent compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BuildString">
<short>Build configuration string</short>
<descr>
<p>String representation of the current build configuration settings.</p>
<p>This property provides a human-readable summary of the target platform,
compiler options, and build parameters.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BuildTarget">
<short>Build target specification</short>
<descr>
<p>Specifies the complete build target configuration including OS, CPU, and options.</p>
<p>This property encompasses all target-related settings that determine
how the package is compiled and linked.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BuildOS">
<short>Operating system for the build environment</short>
<descr>
<p>Specifies the operating system of the build environment (the system performing the compilation).</p>
<p>This property is used for cross-compilation scenarios where the build OS
differs from the target OS.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BuildCPU">
<short>CPU architecture for the build environment</short>
<descr>
<p>Specifies the CPU architecture of the build environment (the system performing the compilation).</p>
<p>This property is used for cross-compilation scenarios where the build CPU
differs from the target CPU architecture.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Mode">
<short>Build mode configuration</short>
<descr>
<p>Specifies the build mode that controls optimization, debugging, and code generation settings.</p>
<p>Common modes include debug (with symbols and checks) and release (optimized for performance).</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.UnixPaths">
<short>Whether to use Unix-style path conventions</short>
<descr>
<p>Boolean flag that controls whether to use Unix-style path separators and conventions.</p>
<p>When <var>True</var>, forward slashes are used for paths instead of platform-specific
separators, enabling cross-platform path consistency.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Options">
<short>Configuration options for the build</short>
<descr>
<p>Collection of configuration options that are applied to all builds using these defaults.</p>
<p>Options include compiler flags, preprocessor definitions, optimization settings,
and other build-specific parameters.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.NoFPCCfg">
<short>Whether to ignore FPC configuration files</short>
<descr>
<p>Boolean flag that controls whether to ignore system-wide Free Pascal configuration files.</p>
<p>When <var>True</var>, the build system bypasses automatic loading of fpc.cfg
and similar configuration files.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.ThreadsAmount">
<short>Number of threads to use during compilation</short>
<descr>
<p>Specifies the number of parallel threads to use during multi-threaded compilation.</p>
<p>Higher thread counts can improve build performance on multi-core systems,
while lower counts reduce resource usage.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.LocalUnitDir">
<short>Local directory for compiled units</short>
<descr>
<p>Specifies the local directory where compiled unit files (.ppu, .o) are stored.</p>
<p>This directory is used for unit output during compilation and serves as a search
path for unit dependencies in the same package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.GlobalUnitDir">
<short>Global directory for compiled units</short>
<descr>
<p>Specifies the global directory where system-wide compiled unit files are located.</p>
<p>This directory is searched for unit dependencies that are not part of the
current package, such as RTL and FCL units.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SearchPath">
<short>Search paths for finding files</short>
<descr>
<p>Specifies the search paths used for locating source files, units, and other resources.</p>
<p>Multiple paths can be specified and are searched in order when resolving
file dependencies during compilation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Prefix">
<short>Installation prefix directory</short>
<descr>
<p>Specifies the base installation prefix directory for all package installations.</p>
<p>All installation paths are relative to this prefix, enabling flexible
deployment to different base locations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.ZipPrefix">
<short>Prefix for archive file operations</short>
<descr>
<p>Specifies the directory prefix used when creating or extracting archive files.</p>
<p>This prefix is applied to file paths within archives to ensure proper
relative path structure during archive operations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BaseInstallDir">
<short>Base directory for installations</short>
<descr>
<p>Specifies the base directory where all package components are installed.</p>
<p>This directory serves as the root for all installation operations and
contains subdirectories for units, documentation, and examples.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.UnitInstallDir">
<short>Directory for installing unit files</short>
<descr>
<p>Specifies the target directory where compiled unit files are installed.</p>
<p>This directory contains the final .ppu and .o files that are installed
for use by other packages and applications.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.UnitConfigFilesInstallDir">
<short>Directory for installing unit configuration files</short>
<descr>
<p>Specifies the target directory where unit configuration files are installed.</p>
<p>These configuration files contain search paths and settings that help
the compiler locate and use the installed units.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BinInstallDir">
<short>Directory for installing binary files</short>
<descr>
<p>Specifies the target directory where executable binary files are installed.</p>
<p>This directory contains compiled programs, utilities, and tools that are
part of the package distribution.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.LibInstallDir">
<short>Directory for installing library files</short>
<descr>
<p>Specifies the target directory where library files are installed.</p>
<p>This directory contains shared libraries, static libraries, and other
linkable library components provided by the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.DocInstallDir">
<short>Directory for installing documentation files</short>
<descr>
<p>Specifies the target directory where documentation files are installed.</p>
<p>This directory contains user manuals, API documentation, readme files,
and other informational content for the package.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.ExamplesInstallDir">
<short>Directory for installing example files</short>
<descr>
<p>Specifies the target directory where example files are installed.</p>
<p>This directory contains sample programs, demonstration code, and tutorials
that show how to use the package functionality.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.FPDocOutputDir">
<short>Output directory for FPDoc documentation</short>
<descr>
<p>Specifies the output directory where FPDoc-generated documentation is created.</p>
<p>This directory receives the HTML, XML, or other formatted documentation
files generated by the FPDoc documentation system.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.FPDocOptions">
<short>Command line options for FPDoc</short>
<descr>
<p>Specifies command line options and parameters passed to the FPDoc documentation generator.</p>
<p>These options control documentation format, output settings, processing modes,
and other FPDoc-specific configuration parameters.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.FPUnitSourcePath">
<short>Source path for FPUnit testing framework</short>
<descr>
<p>Specifies the path to the FPUnit testing framework source files.</p>
<p>This path is used to locate FPUnit units and resources when building
test programs and test suites for package validation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Compiler">
<short>Compiler executable path and options</short>
<descr>
<p>Specifies the Free Pascal compiler executable path and default compilation options.</p>
<p>This property configures the compiler command, version, and global settings
used for all compilation operations in the build system.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Copy">
<short>File copy command and options</short>
<descr>
<p>Specifies the system command and options used for file copy operations.</p>
<p>This property configures the file copying mechanism used during installation,
archive creation, and other file management tasks.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Move">
<short>File move command and options</short>
<descr>
<p>Specifies the system command and options used for file move operations.</p>
<p>This property configures the file moving mechanism used for reorganizing files
during build and installation processes.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Remove">
<short>File removal command and options</short>
<descr>
<p>Specifies the system command and options used for file removal operations.</p>
<p>This property configures the file deletion mechanism used during cleanup,
uninstallation, and other file management tasks.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.RemoveDir">
<short>Directory removal command and options</short>
<descr>
<p>Specifies the system command and options used for empty directory removal.</p>
<p>This property configures the directory deletion mechanism used when removing
empty directories during cleanup operations.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.RemoveTree">
<short>Directory tree removal command and options</short>
<descr>
<p>Specifies the system command and options used for recursive directory tree removal.</p>
<p>This property configures the mechanism for deleting entire directory structures
with all contained files and subdirectories.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.MkDir">
<short>Directory creation command and options</short>
<descr>
<p>Specifies the system command and options used for directory creation operations.</p>
<p>This property configures the directory creation mechanism used during installation
and build processes to ensure required directories exist.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Archive">
<short>Archive creation command and options</short>
<descr>
<p>Specifies the system command and options used for archive file creation.</p>
<p>This property configures the archiving mechanism used to create TAR, ZIP,
or other compressed archive files for package distribution.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.UseEnvironment">
<short>Whether to use environment variables</short>
<descr>
<p>Boolean flag that controls whether to use environment variables in configuration.</p>
<p>When <var>True</var>, environment variables are expanded in paths and options,
enabling dynamic configuration based on the system environment.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.IgnoreInvalidOptions">
<short>Whether to ignore invalid configuration options</short>
<descr>
<p>Boolean flag that controls whether invalid or unrecognized options are ignored.</p>
<p>When <var>True</var>, unknown configuration options do not cause build failures
but are silently ignored with optional warning messages.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.BuildMode">
<short>Build mode configuration setting</short>
<descr>
<p><var>BuildMode</var> specifies the current build mode configuration for the package compilation process.
This setting influences compiler optimization levels, debug information inclusion, and other build parameters.</p>
<p>Common build modes include debug, release, and custom configurations tailored for specific build requirements.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SingleFPDocFile">
<short>Whether to generate single FPDoc output file</short>
<descr>
<p><var>SingleFPDocFile</var> controls whether fpdoc generates documentation as a single combined file
or as separate files for each unit. When <var>True</var>, all documentation is merged into one output file.</p>
<p>Single file output is useful for creating documentation packages or when distributing
documentation as a single downloadable file.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.Namespaces">
<short>Whether to use unit namespaces</short>
<descr>
<p><var>Namespaces</var> enables or disables the use of unit namespaces in the compilation process.
When <var>True</var>, the compiler supports dotted unit names and namespace resolution.</p>
<p>Namespace support allows organizing units into logical groups and avoiding naming conflicts
between units from different packages or libraries.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.InstallExamples">
<short>Whether to install example files</short>
<descr>
<p><var>InstallExamples</var> controls whether example files are installed along with the package.
When <var>True</var>, example source code and demonstration files are copied to the installation directory.</p>
<p>Installing examples provides users with ready-to-use code samples that demonstrate package functionality
and serve as a learning resource.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SkipCrossPrograms">
<short>Whether to skip cross-compilation programs</short>
<descr>
<p><var>SkipCrossPrograms</var> determines whether program targets are skipped during cross-compilation builds.
When <var>True</var>, only libraries and units are compiled when building for different target architectures.</p>
<p>This setting is useful when the target platform cannot execute the compiled programs or when
only library components are needed for cross-platform deployment.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomDefaults.SkipAllPrograms">
<short>Whether to skip building all programs</short>
<descr>
<p><var>SkipAllPrograms</var> controls whether all program targets are excluded from the build process.
When <var>True</var>, only library units are compiled, skipping executable programs entirely.</p>
<p>This option is useful for library-only distributions or when building packages that provide
only reusable components without standalone executables.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TBasicDefaults">
<short>Basic default configuration class</short>
<descr>
<p><var>TBasicDefaults</var> provides a concrete implementation of <link id="TCustomDefaults">TCustomDefaults</link>
with basic configuration management for the fpmake build system.</p>
<p>This class manages fundamental build settings including compiler paths, installation directories,
archiving options, and other essential configuration parameters for package building and installation.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPCDefaults">
<short>FPC-specific default configuration class</short>
<descr>
<p><var>TFPCDefaults</var> extends <link id="TCustomDefaults">TCustomDefaults</link> with Free Pascal Compiler
specific configuration settings and defaults. This class provides FPC-tailored build configuration management.</p>
<p>The class includes FPC-specific compiler paths, option handling, and build system integration
optimized for Free Pascal development environments.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPCDefaults.CompilerDefaults">
<short>Sets up FPC compiler default configuration</short>
<descr>
<p><var>CompilerDefaults</var> initializes the FPC compiler with standard default settings and options.
This method configures the compiler environment with appropriate paths, compilation modes, and target settings.</p>
<p>The setup includes standard FPC installation paths, library directories, and default compiler options
suitable for typical Free Pascal development scenarios.</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TCopyFileProc">
<short>Procedural type for file copying operations</short>
<descr>
<p><var>TCopyFileProc</var> defines the signature for callback procedures that handle file copying operations
during package installation. This procedural type enables custom file copying implementations.</p>
<p>The procedure receives source and destination file paths and handles the actual file copying process
with appropriate error handling and progress reporting.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCopyFileProc.APackage">
<short>Package context for the file copy operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TCopyFileProc.ASourceFileName">
<short>Source filename for the copy operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TCopyFileProc.ADestFileName">
<short>Destination filename for the copy operation</short>
</element>

<!-- constructor Visibility: public -->
<element name="TBuildEngine.Create">
<short>Creates a new build engine instance</short>
<descr>
<p>Creates a new <var>TBuildEngine</var> instance and initializes all internal components needed for
package compilation, installation, and management.</p>
<p>The build engine handles compilation processes, dependency resolution, file operations,
and package installation coordination.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Create.AOwner">
<short>Component owner for the build engine instance</short>
</element>

<!-- destructor Visibility: public -->
<element name="TBuildEngine.Destroy">
<short>Destroys the build engine and frees resources</short>
<descr>
<p>Destroys the <var>TBuildEngine</var> instance and frees all associated resources including
critical sections, archive handlers, and temporary files.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.AddPathPrefix">
<short>Adds package-specific path prefix to a path</short>
<descr>
<p>Adds a package-specific path prefix to the given path string.</p>
<p>This ensures paths are correctly resolved relative to the package's base directory
and build configuration.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.AddPathPrefix.Result">
<short>Path with package prefix added</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.AddPathPrefix.APackage">
<short>Package instance for path prefix context</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.AddPathPrefix.APath">
<short>Original path to add prefix to</short>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.Verbose">
<short>Controls verbose output during build operations</short>
<descr>
<p>When <var>True</var>, the build engine produces detailed output about compilation processes,
file operations, and build steps.</p>
<p>When <var>False</var>, only essential messages and errors are displayed.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.Interactive">
<short>Whether the build engine runs in interactive mode</short>
<descr>
<p><var>Interactive</var> controls whether the build engine prompts for user input during build operations.
When <var>True</var>, the engine may ask for confirmations, choices, or input during the build process.</p>
<p>Interactive mode is useful during development and testing, while non-interactive mode is preferred
for automated builds and continuous integration scenarios.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.ResolveFileNames">
<short>Resolves and validates file paths for package targets</short>
<descr>
<p>Resolves all file paths used by targets in the package, ensuring source files exist
and creating proper search paths for the specified CPU and OS.</p>
<p>This critical preprocessing step validates that all required files are available
before compilation begins and sets up directory context for build operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ResolveFileNames.APackage">
<short>Package containing targets to resolve</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ResolveFileNames.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ResolveFileNames.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ResolveFileNames.DoChangeDir">
<short><var>True</var> to change to package directory during resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ResolveFileNames.WarnIfNotFound">
<short><var>True</var> to warn about missing files</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.ClearResolvedFileNames">
<short>Clears resolved file name cache for a package</short>
<descr>
<p>Clears all cached resolved file names and paths for the specified package.</p>
<p>This is typically called after compilation or when package configuration changes
to ensure fresh file resolution on subsequent operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ClearResolvedFileNames.APackage">
<short>Package to clear resolved filenames for</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.ExecuteCommand">
<short>Executes a command with arguments and environment variables</short>
<descr>
<p>Executes an external command with the specified arguments and environment variables.
The command execution can optionally ignore errors based on the <var>IgnoreError</var> parameter.</p>
<p>This is used by the build system to invoke external tools like compilers, linkers,
archive utilities, and other build tools during the compilation and installation process.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommand.Cmd">
<short>Command executable to run</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommand.Args">
<short>Command line arguments list</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommand.Env">
<short>Environment variables for command execution</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommand.IgnoreError">
<short>Whether to ignore command execution errors</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.GetExecuteCommandOutput">
<short>Executes command and captures output text</short>
<descr>
<p>Executes an external command and captures its standard output as a string.
This is useful for retrieving information from external tools like version queries
or configuration detection commands.</p>
<p>The command execution behavior follows the same pattern as <link id="TBuildEngine.ExecuteCommand">ExecuteCommand</link>
but additionally captures and returns the output text.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.GetExecuteCommandOutput.Result">
<short>Command output as string</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetExecuteCommandOutput.Cmd">
<short>Command executable to run</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetExecuteCommandOutput.Args">
<short>Command line arguments list</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetExecuteCommandOutput.Env">
<short>Environment variables for command execution</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetExecuteCommandOutput.IgnoreError">
<short>Whether to ignore command execution errors</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdCopyFiles">
<short>Copies files to destination directory</short>
<descr>
<p>Copies a list of files to the specified destination directory using either
the configured copy command or the system's native copy functionality.</p>
<p>The destination directory is created if it doesn't exist. File paths can be
absolute or relative to the current working directory.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdCopyFiles.List">
<short>List of files to copy</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdCopyFiles.DestDir">
<short>Destination directory for file copying</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdCopyFiles.APackage">
<short>Package context for file copying</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdCreateDir">
<short>Creates a directory with necessary parent directories</short>
<descr>
<p>Creates a directory and all necessary parent directories in the path.
If the directory already exists, no error is generated.</p>
<p>This is used to ensure output directories exist before files are written
during the build and installation process.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdCreateDir.DestDir">
<short>Destination directory to create</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdMoveFiles">
<short>Moves files to destination directory</short>
<descr>
<p>Moves a list of files to the specified destination directory using either
the configured move command or the system's native move functionality.</p>
<p>Files are relocated from their current location to the destination directory.
The destination directory is created if it doesn't exist.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdMoveFiles.List">
<short>List of files to move</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdMoveFiles.DestDir">
<short>Destination directory for file movement</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdDeleteFiles">
<short>Deletes files from filesystem</short>
<descr>
<p>Deletes a list of files from the filesystem using either the configured
remove command or the system's native delete functionality.</p>
<p>This is typically used during clean operations to remove compiled object files,
executables, and other generated files.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdDeleteFiles.List">
<short>List of files to delete</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdDeleteDestFiles">
<short>Deletes files from destination directory</short>
<descr>
<p>Deletes a list of files from the specified destination directory.</p>
<p>This method combines the file list with the destination directory path
and removes the specified files as part of cleanup operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdDeleteDestFiles.List">
<short>List of files to delete</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdDeleteDestFiles.DestDir">
<short>Destination directory for file deletion</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdArchiveFiles">
<short>Creates archive file containing specified files</short>
<descr>
<p>Creates an archive file containing the specified list of files using either
the configured archive command or the system's native archiving functionality.</p>
<p>This is used during the archive phase to create distribution packages
containing compiled binaries and resource files.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdArchiveFiles.List">
<short>List of files to include in archive</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdArchiveFiles.ArchiveFile">
<short>Filename for the created archive</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdRenameFile">
<short>Renames or moves a file to new location</short>
<descr>
<p>Renames a file from the source location to the destination location.
This can be used for both simple renaming within the same directory
or moving files between different directories.</p>
<p>Used during build processes when files need to be relocated or renamed
according to the package configuration.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdRenameFile.SourceName">
<short>Source filename to rename</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdRenameFile.DestName">
<short>Destination filename after rename</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdRemoveDirs">
<short>Removes directories from the filesystem</short>
<descr>
<p>Removes a list of empty directories from the filesystem using the configured
directory removal command.</p>
<p>This method is typically used during cleanup operations to remove temporary
and generated directories that are no longer needed.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdRemoveDirs.List">
<short>List of directories to remove</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CmdRemoveTrees">
<short>Removes directory trees from the filesystem</short>
<descr>
<p>Recursively removes entire directory trees including all subdirectories and files within them.
This is used during clean operations to remove generated directory structures.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CmdRemoveTrees.List">
<short>List of directory trees to remove</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.ExecuteCommands">
<short>Executes a collection of build commands</short>
<descr>
<p>Executes all commands in the specified collection at the given timing point during the build process.
This allows custom commands to be run at specific phases of package building or installation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommands.Commands">
<short>Collection of commands to execute</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommands.At">
<short>Execution context or timing</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ExecuteCommands.APackage">
<short>Package for which to execute commands</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.DependencyOK">
<short>Checks if dependency is satisfied</short>
<descr>
<p><var>DependencyOK</var> verifies whether a specified package dependency is satisfied and available for the build process.
This function checks dependency resolution, version requirements, and availability of the required package.</p>
<p>The method returns <var>True</var> if the dependency is properly resolved and can be used during compilation,
or <var>False</var> if the dependency is missing, has version conflicts, or cannot be satisfied.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.DependencyOK.Result">
<short>True if dependency is satisfied</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DependencyOK.ADependency">
<short>Dependency to check</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.GetCompilerCommand">
<short>Gets compiler command for target</short>
<descr>
<p>Constructs the complete compiler command line for compiling the specified target.</p>
<p>The command includes the compiler executable, all necessary options, paths,
and parameters required to compile the target successfully.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.GetCompilerCommand.Result">
<short>Compiler command string</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetCompilerCommand.APackage">
<short>Package to compile</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetCompilerCommand.ATarget">
<short>Target to compile</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetCompilerCommand.Env">
<short>Environment variables</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.TargetOK">
<short>Checks if target is valid for platform</short>
<descr>
<p>Determines whether the specified target is valid for the current platform configuration.</p>
<p>This check considers the target's CPU and OS restrictions to determine if it should
be built on the current system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.TargetOK.Result">
<short>True if target is valid</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetOK.ATarget">
<short>Target to check</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetOK.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetOK.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetOK.aSubTarget">
<short>Subtarget to check</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.TargetInstallOK">
<short>Checks if target can be installed on platform</short>
<descr>
<p><var>TargetInstallOK</var> determines whether a build target can be installed on the current platform and configuration.
This function evaluates platform compatibility, dependency availability, and installation requirements.</p>
<p>The method returns <var>True</var> if the target is suitable for installation on the current system,
or <var>False</var> if platform restrictions or missing dependencies prevent installation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.Result">
<short>True if target can be installed</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.ATarget">
<short>Target to check for installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.ACPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.AOS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.aSubTarget">
<short>Subtarget to check for installation</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.GetCompilerCommand.Args">
<short>Command line arguments for compiler</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetOK.aCompileTarget">
<short>Compile target to check</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.TargetInstallOK.aCompileTarget">
<short>Compile target to check for installation</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.NeedsCompile">
<short>Checks if target needs compilation</short>
<descr>
<p>Determines whether the specified target needs to be compiled by checking timestamps,
dependencies, and build requirements.</p>
<p>Returns <var>True</var> if the target's output files are missing, out of date,
or if dependencies have changed.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.NeedsCompile.Result">
<short>True if target needs compilation</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.NeedsCompile.APackage">
<short>Package containing the target</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.NeedsCompile.ATarget">
<short>Target to check for compilation need</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Compile">
<short>Compiles a specific target within a package</short>
<descr>
<p>Compiles the specified target within the given package. This method handles the actual
compilation process, including dependency resolution, command-line generation,
and execution of the Free Pascal Compiler.</p>
</descr>
<seealso>
<link id="TBuildEngine.MaybeCompile">MaybeCompile</link>
<link id="TBuildEngine.CompileDependencies">CompileDependencies</link>
<link id="TTarget">TTarget</link>
<link id="TPackage">TPackage</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Compile.APackage">
<short>Package containing the target to compile</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Compile.ATarget">
<short>Target to compile within the package</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.MaybeCompile">
<short>Compiles target if compilation is needed</short>
<descr>
<p>Conditionally compiles the target only if compilation is required based on
dependency analysis and timestamp checks.</p>
<p>This method first calls <link id="TBuildEngine.NeedsCompile">NeedsCompile</link>
and only performs compilation if necessary.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.MaybeCompile.APackage">
<short>Package containing the target</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.MaybeCompile.ATarget">
<short>Target to potentially compile</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CompileDependencies">
<short>Compiles all dependencies for a target</short>
<descr>
<p>Ensures that all dependencies for the specified target are compiled before compiling
the target itself. This method recursively processes the dependency chain to maintain
proper build order.</p>
</descr>
<seealso>
<link id="TBuildEngine.Compile">Compile</link>
<link id="TDependency">TDependency</link>
<link id="TTarget">TTarget</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CompileDependencies.APackage">
<short>Package containing the target with dependencies</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CompileDependencies.ATarget">
<short>Target whose dependencies to compile</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.PackageOK">
<short>Checks if package is valid for compilation</short>
<descr>
<p><var>PackageOK</var> validates whether a package is properly configured and ready for compilation.
This function examines package structure, dependencies, target definitions, and configuration validity.</p>
<p>The method returns <var>True</var> if the package can be compiled successfully, or <var>False</var> if there are
configuration errors, missing dependencies, or other issues preventing compilation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.PackageOK.Result">
<short>True if package is valid</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.PackageOK.APackage">
<short>Package to check for validity</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoBeforeCompile">
<short>Executes actions before package compilation</short>
<descr>
<p><var>DoBeforeCompile</var> performs pre-compilation setup and initialization tasks for the package.
This method prepares the build environment, resolves dependencies, and executes any custom pre-build commands.</p>
<p>The procedure ensures that all necessary conditions are met before the actual compilation process begins,
including directory creation, file preparation, and environment configuration.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoBeforeCompile.APackage">
<short>Package about to be compiled</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoAfterCompile">
<short>Executes actions after package compilation</short>
<descr>
<p><var>DoAfterCompile</var> performs post-compilation cleanup and finalization tasks for the package.
This method executes custom post-build commands and performs any necessary housekeeping after compilation completes.</p>
<p>The procedure handles result validation, temporary file cleanup, and any additional processing
required after the compilation phase has finished successfully.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoAfterCompile.APackage">
<short>Package that was compiled</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoBeforeInstall">
<short>Executes actions before package installation</short>
<descr>
<p><var>DoBeforeInstall</var> prepares the system and package for installation by executing pre-installation tasks.
This method ensures installation directories exist, validates installation requirements, and runs custom pre-install commands.</p>
<p>The procedure verifies installation permissions, creates necessary directories, and performs any setup
required before the actual file installation begins.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoBeforeInstall.APackage">
<short>Package about to be installed</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoAfterInstall">
<short>Executes actions after package installation</short>
<descr>
<p><var>DoAfterInstall</var> completes the installation process by executing post-installation tasks.
This method runs custom post-install scripts, registers the package, and performs final installation verification.</p>
<p>The procedure handles package registration, configuration updates, and any cleanup or finalization
steps required after successful package installation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoAfterInstall.APackage">
<short>Package that was installed</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoBeforeArchive">
<short>Executes actions before package archiving</short>
<descr>
<p><var>DoBeforeArchive</var> prepares files and directories for package archive creation.
This method organizes files, validates archive contents, and executes pre-archiving customization commands.</p>
<p>The procedure ensures all necessary files are included, applies any transformations,
and sets up the archive structure before the compression process begins.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoBeforeArchive.APackage">
<short>Package about to be archived</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoAfterArchive">
<short>Executes actions after package archiving</short>
<descr>
<p><var>DoAfterArchive</var> completes the archiving process by executing post-archive tasks.
This method validates the created archive, runs post-archiving scripts, and performs cleanup operations.</p>
<p>The procedure verifies archive integrity, moves files to final locations, and handles any additional
processing required after successful archive creation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoAfterArchive.APackage">
<short>Package that was archived</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoBeforeClean">
<short>Executes actions before package cleaning</short>
<descr>
<p><var>DoBeforeClean</var> prepares for package cleaning by executing pre-cleanup tasks.
This method backs up important files, runs custom pre-clean scripts, and identifies files to be removed.</p>
<p>The procedure ensures that critical files are preserved and performs any necessary preparation
before the cleaning process removes temporary and generated files.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoBeforeClean.APackage">
<short>Package about to be cleaned</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.DoAfterClean">
<short>Executes actions after package cleaning</short>
<descr>
<p><var>DoAfterClean</var> completes the cleaning process by executing post-cleanup tasks.
This method validates that unwanted files were removed, runs post-clean verification, and performs final cleanup steps.</p>
<p>The procedure ensures the cleaning was successful and handles any additional housekeeping
required after the package cleanup operation completes.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.DoAfterClean.APackage">
<short>Package that was cleaned</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.ReadyToCompile">
<short>Checks if package is ready for compilation</short>
<descr>
<p><var>ReadyToCompile</var> verifies that all prerequisites are met for package compilation.
This function checks dependency availability, compiler settings, source file presence, and build configuration validity.</p>
<p>The method returns <var>True</var> if the package can be compiled successfully, or <var>False</var>
if missing dependencies, configuration errors, or other issues prevent compilation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.ReadyToCompile.Result">
<short>True if package is ready to compile</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ReadyToCompile.APackage">
<short>Package to check for compilation readiness</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Install">
<short>Installs package files to target location</short>
<descr>
<p><var>Install</var> performs the complete package installation process by copying compiled files
and resources to their target installation directories. This method handles library files, executables,
documentation, and other package components.</p>
<p>The installation process includes directory creation, file copying with proper permissions,
and optional archive creation for backup and distribution purposes.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Install.APackage">
<short>Package to install</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Install.AnArchiveFiles">
<short>Files to archive during installation</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.UnInstall">
<short>Uninstalls package files from target location</short>
<descr>
<p><var>UnInstall</var> removes package files from their installation directories and performs cleanup.
This method reverses the installation process by deleting installed files, libraries, and associated resources.</p>
<p>The uninstallation includes removing executable files, libraries, documentation, and configuration files
while preserving user data and custom configurations where appropriate.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.UnInstall.APackage">
<short>Package to uninstall</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Archive">
<short>Creates archive of package files</short>
<descr>
<p><var>Archive</var> creates compressed archive files containing package sources, binaries, and documentation.
This method generates distributable archive files in formats such as ZIP, TAR, or other compression formats.</p>
<p>The archiving process includes source files, compiled binaries, documentation, examples, and other
package components organized for distribution and installation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Archive.APackage">
<short>Package to archive</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.PkgList">
<short>Lists package contents and information</short>
<descr>
<p><var>PkgList</var> displays detailed information about package contents, dependencies, targets, and configuration.
This method provides a listing of package components for review and verification.</p>
<p>The listing includes source files, dependencies, build targets, installation paths, and other
package metadata useful for package management and debugging.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.PkgList.PkgList">
<short>List of packages to process</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.PkgList.APackage">
<short>Specific package to list</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Clean">
<short>Cleans compiled files and outputs</short>
<descr>
<p><var>Clean</var> removes compiled object files, executables, and other generated outputs from the build process.
This method cleans up temporary files, object files, and build artifacts to prepare for a fresh compilation.</p>
<p>The cleaning process can target specific packages or all targets, removing compiled units, executables,
and temporary files while preserving source code and configuration files.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Clean.APackage">
<short>Package to clean</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Clean.AllTargets">
<short>Whether to clean all targets</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Clean.aTarget">
<short>Specific target to clean</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.CheckDependencies">
<short>Checks package dependencies are satisfied</short>
<descr>
<p><var>CheckDependencies</var> validates that all required dependencies for a package are available and properly configured.
This function verifies dependency versions, availability, and compatibility with the current build configuration.</p>
<p>The method returns <var>True</var> if all dependencies are satisfied, or <var>False</var> if missing dependencies
or version conflicts prevent successful compilation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.CheckDependencies.Result">
<short>True if all dependencies are satisfied</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CheckDependencies.APackage">
<short>Package whose dependencies to check</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CheckDependencies.ErrorOnFailure">
<short>Whether to raise error on dependency failure</short>
</element>

<!-- function Visibility: public -->
<element name="TBuildEngine.CheckExternalPackage">
<short>Checks if external package is available</short>
<descr>
<p><var>CheckExternalPackage</var> verifies the availability and accessibility of external packages required by the build.
This function checks for system packages, third-party libraries, and external dependencies not managed by fpmake.</p>
<p>The method returns <var>True</var> if the external package is found and accessible, enabling the build to proceed
with confidence that external dependencies are satisfied.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TBuildEngine.CheckExternalPackage.Result">
<short>True if external package is available</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CheckExternalPackage.APackageName">
<short>Name of external package to check</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CheckExternalPackage.ForPackageName">
<short>Name of requesting package</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CheckExternalPackage.ErrorOnFailure">
<short>Whether to raise error if package not found</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.CreateOutputDir">
<short>Creates output directory for package</short>
<descr>
<p><var>CreateOutputDir</var> creates the necessary output directory structure for package compilation and installation.
This method ensures that target directories exist with proper permissions for storing compiled files and outputs.</p>
<p>The procedure creates unit output directories, executable paths, and library directories
as required by the package configuration and target platform.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.CreateOutputDir.APackage">
<short>Package for which to create output directory</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Compile.Packages">
<short>List of packages to compile</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Install.Packages">
<short>List of packages to install</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.UnInstall.Packages">
<short>List of packages to uninstall</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.ZipInstall">
<short>Creates ZIP archive during installation</short>
<descr>
<p><var>ZipInstall</var> combines package installation with ZIP archive creation for convenient distribution.
This method installs package files to their target locations while simultaneously creating a compressed ZIP archive.</p>
<p>The ZIP installation process enables easy package distribution and backup by creating both
installed files and a portable archive containing all package components.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.ZipInstall.Packages">
<short>List of packages to ZIP install</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Archive.Packages">
<short>List of packages to archive</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Manifest">
<short>Creates manifest of package contents</short>
<descr>
<p><var>Manifest</var> generates manifest files containing detailed package information and contents.
This method creates structured documentation of package files, dependencies, versions, and configuration.</p>
<p>The manifest includes file listings, checksums, dependency information, and metadata useful for
package management, verification, and deployment processes.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Manifest.Packages">
<short>List of packages for manifest</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Manifest.Package">
<short>Specific package for manifest</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.PkgList.Packages">
<short>List of packages to list</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.FPDocProject">
<short>Generates FPDoc documentation project</short>
<descr>
<p><var>FPDocProject</var> creates FPDoc documentation projects for generating API documentation.
This method processes package source files and generates structured documentation using the FPDoc tool.</p>
<p>The documentation project includes unit descriptions, class hierarchies, method signatures, and code examples
organized for web-based or printed documentation distribution.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.FPDocProject.Packages">
<short>List of packages for documentation</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.FPDocProject.SingleDocFile">
<short>Whether to generate single documentation file</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Clean.Packages">
<short>List of packages to clean</short>
</element>

<!-- procedure Visibility: public -->
<element name="TBuildEngine.Log">
<short>Logs message with specified level and formatting</short>
<descr>
<p><var>Log</var> outputs formatted log messages with specified verbosity levels during build operations.
This method provides structured logging with level-based filtering and message formatting capabilities.</p>
<p>The logging system supports various levels including debug, info, warning, and error messages,
with optional format string processing for detailed diagnostic output.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Log.Level">
<short>Log level for the message</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Log.Msg">
<short>Message text to log</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Log.Fmt">
<short>Format string for message</short>
</element>

<!-- argument Visibility: default -->
<element name="TBuildEngine.Log.Args">
<short>Arguments for format string</short>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.ListMode">
<short>Mode for listing package information</short>
<descr>
<p><var>ListMode</var> controls the format and detail level when listing package information and contents.
This property determines how package listing output is formatted and what information is displayed.</p>
<p>Different list modes provide varying levels of detail from simple package names to 
information including dependencies, targets, and configuration details.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.ForceCompile">
<short>Whether to force recompilation of all targets</short>
<descr>
<p><var>ForceCompile</var> enables complete recompilation of all targets regardless of file modification times.
When <var>True</var>, all source files are recompiled even if outputs appear up-to-date.</p>
<p>Forced compilation ensures clean builds and is useful when dependency tracking may be unreliable
or when build system changes require complete regeneration of all outputs.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.ExternalPackages">
<short>Collection of external package dependencies</short>
<descr>
<p><var>ExternalPackages</var> contains the collection of external package dependencies required by the build process.
This property manages packages that are not built by the current build system but are required for compilation.</p>
<p>External packages include system libraries, third-party components, and pre-compiled packages
that must be available for successful compilation and linking.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.StartDir">
<short>Starting directory for build operations</short>
<descr>
<p><var>StartDir</var> specifies the base directory from which all build operations are initiated.
This property establishes the root path for resolving relative file paths and organizing build outputs.</p>
<p>The starting directory serves as the reference point for source file locations, output directories,
and configuration file paths during the build process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.NotifyEventCollection">
<short>Collection of notification event handlers</short>
<descr>
<p><var>NotifyEventCollection</var> manages the collection of event handlers that receive notifications
during build operations. This property enables registration of multiple event listeners for build progress monitoring.</p>
<p>Event handlers can monitor compilation progress, installation status, and other build events
for logging, user interface updates, and custom processing requirements.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TBuildEngine.OnLog">
<short>Event handler for logging messages</short>
<descr>
<p><var>OnLog</var> is the event handler called when the build engine generates log messages.
This event enables custom logging implementations and integration with external logging systems.</p>
<p>The event handler receives log level, message text, and formatting parameters,
allowing custom processing, filtering, and routing of build system messages.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TCustomInstaller">
<short>Base class for package installers</short>
<descr>
<p><var>TCustomInstaller</var> is the base class for implementing package installation systems.
It provides the framework for managing packages, coordinating with the build engine,
and handling different installation modes.</p>
<p>The installer manages a collection of packages, provides access to the build engine,
and supports different run modes including compilation, installation, cleaning, and archiving.
It serves as the bridge between the command-line interface and the build system.</p>
</descr>
<seealso>
<link id="TBuildEngine">TBuildEngine</link>
<link id="TPackage">TPackage</link>
<link id="TPackages">TPackages</link>
<link id="TRunMode">TRunMode</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TCustomInstaller.Create">
<short>Creates a new installer instance</short>
<descr>
<p><var>Create</var> initializes a new <var>TCustomInstaller</var> instance with default configuration.
This constructor sets up the installer framework including the build engine, package collection, and default settings.</p>
<p>It also analyzes the command-line to determine what the <link id="TCustomInstaller.RunMode">RunMode</link> is.</p>
<p>The created instance is then ready to have packages added and can be configured for different run modes
such as compilation, installation, cleaning, or archiving that will be executed during the <link id="TCustomInstaller.Run">Run</link> procedure.</p>
</descr>
<seealso>
<link id="TCustomInstaller.RunMode">RunMode</link>
<link id="TCustomInstaller.Run">Run</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TCustomInstaller.Create.AOwner">
<short>Owner component for the installer</short>
</element>

<!-- destructor Visibility: public -->
<element name="TCustomInstaller.destroy">
<short>Destroys installer instance and frees resources</short>
<descr>
<p><var>destroy</var> frees all resources allocated by the installer including the build engine and package collection.
This destructor ensures proper cleanup of all installer components and allocated memory.</p>
<p>The destructor handles cleanup of temporary files, releases system resources, and properly terminates
any ongoing build operations before freeing the installer instance.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCustomInstaller.AddPackage">
<short>Adds package to installer collection</short>
<descr>
<p><var>AddPackage</var> creates and adds a new <link id="TPackage">TPackage</link> instance to the installer's package collection.
The method returns the newly created package which can then be configured with targets, dependencies, and settings.</p>
<p>Each package added to the installer will be processed during the run operation according to the current run mode,
whether for compilation, installation, or other operations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCustomInstaller.AddPackage.Result">
<short>Added package instance</short>
</element>

<!-- argument Visibility: default -->
<element name="TCustomInstaller.AddPackage.AName">
<short>Name of package to add</short>
</element>

<!-- function Visibility: public -->
<element name="TCustomInstaller.AddPackageVariant">
<short>Adds package variant to installer</short>
<descr>
<p><var>AddPackageVariant</var> creates and adds a package variant that provides alternative build configurations.
Package variants enable different compilation options, target platforms, or feature sets within the same package.</p>
<p>Variants can be inheritable, allowing derived packages to inherit variant settings, and can be automatically
added to packages for convenient configuration management.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCustomInstaller.AddPackageVariant.Result">
<short>Added package variant instance</short>
</element>

<!-- argument Visibility: default -->
<element name="TCustomInstaller.AddPackageVariant.AName">
<short>Name of package variant to add</short>
</element>

<!-- argument Visibility: default -->
<element name="TCustomInstaller.AddPackageVariant.AIsInheritable">
<short>Whether package variant can be inherited</short>
</element>

<!-- argument Visibility: default -->
<element name="TCustomInstaller.AddPackageVariant.AutoAddToPackage">
<short>Whether to automatically add to package</short>
</element>

<!-- function Visibility: public -->
<element name="TCustomInstaller.Run">
<short>Executes the installer with the current configuration</short>
<descr>
<p>Runs the installer according to the current <link id="TCustomInstaller.RunMode">RunMode</link> setting.
This method coordinates the entire build process, from compilation through installation,
depending on the specified run mode.</p>
</descr>
<seealso>
<link id="TCustomInstaller.RunMode">RunMode</link>
<link id="TBuildEngine">TBuildEngine</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TCustomInstaller.Run.Result">
<short>Exit code from installer run</short>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.FPMakeOptionsString">
<short>String representation of FPMake options</short>
<descr>
<p><var>FPMakeOptionsString</var> provides a string representation of the current FPMake configuration options.
This property formats the installer's settings into a readable string for logging and diagnostic purposes.</p>
<p>The string includes information about run mode, package configuration, build options,
and other settings that affect the installer's operation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.BuildEngine">
<short>Build engine instance used for compilation and installation</short>
<descr>
<p>The <var>BuildEngine</var> property provides access to the <link id="TBuildEngine">TBuildEngine</link>
instance that handles the actual compilation, dependency resolution, and file operations.</p>
</descr>
<seealso>
<link id="TBuildEngine">TBuildEngine</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.Packages">
<short>Collection of packages managed by this installer</short>
<descr>
<p>The <var>Packages</var> property contains the collection of <link id="TPackage">TPackage</link>
instances that will be processed by this installer.</p>
</descr>
<seealso>
<link id="TPackages">TPackages</link>
<link id="TPackage">TPackage</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.RunMode">
<short>Current operation mode of the installer</short>
<descr>
<p><var>RunMode</var> determines the type of operation the installer will perform when <var>Run</var> is called.
Possible modes include compilation, installation, cleaning, archiving, and other package management operations.</p>
<p>The run mode controls which build engine methods are invoked and how packages are processed
during the installer execution cycle.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.ListMode">
<short>Mode for listing package information</short>
<descr>
<p>When <var>ListMode</var> is <var>True</var> then the installer will simply list the various commands it would normally execute to execute the action.</p>
<p>It is similar to <var>--dry-run</var> found in other utilities.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TCustomInstaller.NotifyEventCollection">
<short>Collection of notification event handlers</short>
<descr>
<p><var>NotifyEventCollection</var> manages the collection of event handlers that receive notifications
during installer operations. This property enables registration of multiple event listeners for progress monitoring.</p>
<p>Event handlers can monitor build progress, installation status, and other installer events
for logging, user interface updates, and custom processing requirements.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPCInstaller">
<short>Free Pascal Compiler specific installer implementation</short>
<descr>
<p><var>TFPCInstaller</var> extends <link id="TCustomInstaller">TCustomInstaller</link> with Free Pascal Compiler
specific functionality and configuration. This class provides FPC-tailored installation and build management.</p>
<p>The FPC installer includes specific knowledge of FPC compiler behavior, standard library paths,
and Free Pascal ecosystem conventions for  package building and installation.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TFPCInstaller.Create">
<short>Creates FPC installer instance</short>
<descr>
<p><var>Create</var> initializes a new <var>TFPCInstaller</var> instance with FPC-specific configuration and defaults.
This constructor sets up the installer with Free Pascal Compiler specific build engine and settings.</p>
<p>The created installer is preconfigured for Free Pascal development with appropriate compiler paths,
library directories, and build system integration.</p>
<p>
This is the installer created when no installer class is passed to the <link id="Installer"/> function.
</p>
</descr>
<seealso>
<link id="Installer"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TFPCInstaller.Create.AOwner">
<short>Owner component for FPC installer</short>
</element>

<!-- class Visibility: default -->
<element name="TBasicInstaller">
<short>Basic installer implementation</short>
<descr>
<p><var>TBasicInstaller</var> provides a basic implementation of <link id="TCustomInstaller">TCustomInstaller</link>
with standard functionality for package building and installation. This class offers a complete installer
without compiler-specific optimizations.</p>
<p>The basic installer provides general-purpose package management suitable for the FPC compiler.</p>
</descr>
</element>

<!-- constructor Visibility: default -->
<element name="TBasicInstaller.Create">
<short>Creates basic installer instance</short>
<descr>
<p><var>Create</var> initializes a new <var>TBasicInstaller</var> instance with standard configuration and defaults.
This constructor sets up the installer with general-purpose build engine and basic package management capabilities.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TBasicInstaller.Create.AOwner">
<short>Owner component for basic installer</short>
</element>

<!-- class Visibility: default -->
<element name="TValueItem">
<short>Dictionary item containing a value</short>
<descr>
<p><var>TValueItem</var> represents a dictionary entry that stores a string value with an associated key.
This class is used in template processing and variable substitution systems within the fpmake build system.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TValueItem.FValue">
<short>Internal value storage field</short>
<descr>
<p><var>FValue</var> is the internal field that stores the string value associated with this dictionary item.
This field holds the actual data that can be retrieved and used for variable substitution.</p>
</descr>
</element>

<!-- property Visibility: default -->
<element name="TValueItem.Value">
<short>Value storage field</short>
<descr>
<p><var>Value</var> is the property with the value of the  field that stores the string value associated with this dictionary item.
This property holds the actual data that can be retrieved and used for variable substitution.</p>
</descr>
</element>


<!-- constructor Visibility: default -->
<element name="TValueItem.Create">
<short>Creates value item with specified value</short>
<descr>
<p><var>Create</var> initializes a new <var>TValueItem</var> instance with the specified string value.
This constructor stores the provided value for later retrieval and use in template substitution.</p>
<p>The created value item can be added to dictionaries or collections for dynamic configuration management.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TValueItem.Create.AValue">
<short>Value to store in the item</short>
</element>

<!-- class Visibility: default -->
<element name="TFunctionItem">
<short>Dictionary item containing a function callback</short>
<descr>
<p><var>TFunctionItem</var> represents a dictionary entry that stores a function callback with an associated key.</p>
<p>Function items provide extensibility by allowing custom functions to be registered and called
during template processing and build configuration evaluation.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TFunctionItem.FFunc">
<short>Internal function callback storage field</short>
<descr>
<p><var>FFunc</var> is the internal field that stores the function callback associated with this dictionary item.
This field holds the function reference that can be invoked during template processing.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TFunctionItem.Func">
<short>Function callback storage field</short>
<descr>
<p><var>Func</var> is the property that returns the function callback associated with this dictionary item.
This property holds the function reference that can be invoked during template processing.</p>
</descr>
</element>


<!-- constructor Visibility: default -->
<element name="TFunctionItem.Create">
<short>Creates function item with specified callback</short>
<descr>
<p><var>Create</var> initializes a new <var>TFunctionItem</var> instance with the specified function callback.
This constructor stores the provided function reference for later invocation during template evaluation.</p>

</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFunctionItem.Create.AFunc">
<short>Function callback to store in the item</short>
</element>

<!-- class Visibility: default -->
<element name="TCompileWorkerThread">
<short>Worker thread for compilation operations</short>
<descr>
<p><var>TCompileWorkerThread</var> implements a worker thread for executing compilation operations in parallel.
This class enables concurrent compilation of multiple targets to improve build performance on multi-core systems.</p>
<p>The worker thread manages compilation tasks, handles thread synchronization, and reports progress
back to the main thread for coordinated parallel build processing.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TCompileWorkerThread.Create">
<short>Creates compilation worker thread</short>
<descr>
<p><var>Create</var> initializes a new compilation worker thread with the specified build engine and notification callback.
This constructor prepares the thread for parallel compilation operations.</p>
<p>The worker thread is configured to communicate with the main thread through the provided notification event.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCompileWorkerThread.Create.ABuildEngine">
<short>Build engine instance for compilation</short>
</element>

<!-- argument Visibility: default -->
<element name="TCompileWorkerThread.Create.NotifyMainThreadEvent">
<short>Event to notify main thread of completion</short>
</element>

<!-- destructor Visibility: public -->
<element name="TCompileWorkerThread.Destroy">
<short>Destroys worker thread and cleans up resources</short>
<descr>
<p><var>Destroy</var> terminates the worker thread and frees all allocated resources including build engine references
and thread synchronization objects. This destructor ensures proper cleanup of the compilation thread.</p>
<p>The destructor waits for pending operations to complete before freeing resources.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TfpmPlugin">
<short>Base class for FPMake plugins</short>
<descr>
<p><var>TfpmPlugin</var> provides the foundation for implementing FPMake plugins that extend build system functionality.
Plugins enable custom processing during various phases of the package building and installation process.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TfpmPlugin.Name">
<short>Name of the plugin</short>
<descr>
<p><var>Name</var> property holds the unique identifier for the plugin instance.
This name is used for plugin registration, lookup, and identification within the build system.</p>
<p>Plugin names should be unique within the build environment.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPlugin.BeforeResolvePackagePath">
<short>Called before resolving package path</short>
<descr>
<p><var>BeforeResolvePackagePath</var> is called by the build engine before resolving package paths during build operations.
This method enables plugins to intercept and modify package path resolution logic.</p>
<p>Plugins can use this callback to implement custom package location strategies, add search paths,
or modify the package discovery process according to specific requirements.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.BeforeResolvePackagePath.ABuildEngine">
<short>Build engine performing the resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.BeforeResolvePackagePath.APackage">
<short>Package whose path is being resolved</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.BeforeResolvePackagePath.AContinue">
<short>Whether to continue path resolution</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPlugin.ResolvePackagePath">
<short>Resolves package path location</short>
<descr>
<p><var>ResolvePackagePath</var> performs the actual package path resolution logic within the plugin.
This method implements custom package discovery algorithms and location strategies.</p>
<p>The plugin can search in custom directories, apply naming conventions, or use alternative
package discovery mechanisms to locate package files and directories.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.ResolvePackagePath.ABuildEngine">
<short>Build engine performing resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.ResolvePackagePath.APackage">
<short>Package to resolve path for</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.ResolvePackagePath.SearchDirectory">
<short>Directory to search in</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.ResolvePackagePath.AContinue">
<short>Whether to continue searching</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPlugin.AfterResolvePackagePath">
<short>Called after resolving package path</short>
<descr>
<p><var>AfterResolvePackagePath</var> is called by the build engine after package path resolution completes.
This method enables plugins to perform post-resolution processing or cleanup operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.AfterResolvePackagePath.ABuildEngine">
<short>Build engine that performed resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.AfterResolvePackagePath.APackage">
<short>Package whose path was resolved</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPlugin.AfterResolvePackagePath.AContinue">
<short>Whether to continue processing</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TfpmPluginClass">
<short>Class reference type for FPMake plugins</short>
<descr>
<p><var>TfpmPluginClass</var> is a class reference type used for registering and instantiating plugin classes.
This type enables dynamic plugin creation and management within the plugin system.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TfpmPluginManager">
<short>Manager for FPMake plugin system</short>
<descr>
<p><var>TfpmPluginManager</var> manages the registration, instantiation, and lifecycle of FPMake plugins.
This class provides centralized plugin management and coordinates plugin interactions with the build system.</p>
<p>The plugin manager handles plugin registration, maintains plugin collections, and provides
the interface between the build engine and individual plugin instances.</p>
</descr>
</element>

<!-- destructor Visibility: public -->
<element name="TfpmPluginManager.Destroy">
<short>Destroys plugin manager and registered plugins</short>
<descr>
<p><var>Destroy</var> destroys the plugin manager and frees all registered plugin instances.
This destructor ensures proper cleanup of all plugin resources and memory allocations.</p>
<p>The destructor unregisters all plugins, frees plugin instances, and releases any
system resources held by the plugin management system.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPluginManager.RegisterPlugin">
<short>Registers plugin with the manager</short>
<descr>
<p><var>RegisterPlugin</var> adds a plugin instance to the manager's collection of active plugins.
This method enables the plugin to participate in build system events and callbacks.</p>
<p>Registered plugins receive notifications during package resolution, compilation, and other
build operations, allowing them to extend or customize build system behavior.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.RegisterPlugin.APlugin">
<short>Plugin instance to register</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPluginManager.BeforeResolvePackagePath">
<short>Notifies all plugins before path resolution</short>
<descr>
<p><var>BeforeResolvePackagePath</var> notifies all registered plugins before package path resolution begins.
This method allows plugins to prepare for or modify the upcoming path resolution process.</p>
<p>The manager iterates through all registered plugins, calling their <var>BeforeResolvePackagePath</var> methods
to enable coordinated plugin processing during package discovery operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.BeforeResolvePackagePath.ABuildEngine">
<short>Build engine performing resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.BeforeResolvePackagePath.APackage">
<short>Package whose path is being resolved</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.BeforeResolvePackagePath.AContinue">
<short>Whether to continue resolution process</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPluginManager.ResolvePackagePath">
<short>Delegates package path resolution to plugins</short>
<descr>
<p><var>ResolvePackagePath</var> coordinates package path resolution by delegating to registered plugins.
This method manages the plugin chain and handles resolution results from multiple plugin sources.</p>
<p>The manager calls each plugin's resolution method until a package is found or all plugins
have been exhausted, enabling flexible and extensible package discovery mechanisms.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.ResolvePackagePath.ABuildEngine">
<short>Build engine performing resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.ResolvePackagePath.APackage">
<short>Package to resolve path for</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.ResolvePackagePath.SearchPath">
<short>Search path for package resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.ResolvePackagePath.AContinue">
<short>Whether to continue searching</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmPluginManager.AfterResolvePackagePath">
<short>Notifies all plugins after path resolution</short>
<descr>
<p><var>AfterResolvePackagePath</var> notifies all registered plugins after package path resolution completes.
This method enables plugins to perform post-resolution processing or cleanup operations.</p>
<p>The manager provides resolution results to all plugins, allowing them to cache information,
validate results, or trigger additional processing based on the resolved package paths.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.AfterResolvePackagePath.ABuildEngine">
<short>Build engine that performed resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.AfterResolvePackagePath.APackage">
<short>Package whose path was resolved</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmPluginManager.AfterResolvePackagePath.AContinue">
<short>Whether to continue processing</short>
</element>

<!-- class Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin">
<short>Plugin for resolving package file paths</short>
<descr>
<p><var>TfpmResolvePackagePathsPlugin</var> implements a specialized plugin for package file path resolution.
This plugin provides specific logic for locating package files and directories within the file system.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmResolvePackagePathsPlugin.BeforeResolvePackagePath">
<short>Called before path resolution by plugin</short>
<descr>
<p><var>BeforeResolvePackagePath</var> is called before the plugin performs package path resolution.
This method enables pre-processing and preparation for the package discovery operation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.BeforeResolvePackagePath.ABuildEngine">
<short>Build engine performing resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.BeforeResolvePackagePath.APackage">
<short>Package to resolve path for</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.BeforeResolvePackagePath.AContinue">
<short>Whether to continue resolution</short>
</element>

<!-- procedure Visibility: public -->
<element name="TfpmResolvePackagePathsPlugin.ResolvePackagePath">
<short>Resolves package path using plugin logic</short>
<descr>
<p><var>ResolvePackagePath</var> implements the core package path resolution logic for this plugin.
This method searches for package files using plugin-specific strategies and search algorithms.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.ResolvePackagePath.ABuildEngine">
<short>Build engine performing resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.ResolvePackagePath.APackage">
<short>Package to resolve path for</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.ResolvePackagePath.SearchPath">
<short>Search path for package resolution</short>
</element>

<!-- argument Visibility: default -->
<element name="TfpmResolvePackagePathsPlugin.ResolvePackagePath.AContinue">
<short>Whether to continue searching</short>
</element>

<!-- class Visibility: default -->
<element name="ECollectionError">
<short>Exception class for collection errors</short>
<descr>
<p><var>ECollectionError</var> is raised when errors occur during collection operations such as
invalid indices, missing items, or collection manipulation failures.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="EDictionaryError">
<short>Exception class for dictionary errors</short>
<descr>
<p><var>EDictionaryError</var> is raised when dictionary operations fail due to invalid keys,
missing entries, or other dictionary-specific error conditions.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="EInstallerError">
<short>Exception class for installer errors</short>
<descr>
<p><var>EInstallerError</var> is raised when installer operations encounter errors such as
installation failures, permission problems, or configuration issues during package installation.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TInstallerClass">
<short>Class reference type for installer classes</short>
<descr>
<p><var>TInstallerClass</var> is a class reference type used for dynamic installer creation and management.
This type enables runtime selection and instantiation of different installer implementations.</p>
<p>The class reference allows the system to create a custom installer instance.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TDictionaryClass">
<short>Class reference type for dictionary classes</short>
<descr>
<p><var>TDictionaryClass</var> is a class reference type used for creating dictionary instances dynamically.
This type enables runtime selection of different dictionary implementations and configurations.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TPackageDictionaryClass">
<short>Class reference type for package dictionary classes</short>
<descr>
<p><var>TPackageDictionaryClass</var> is a class reference type specifically for package-related dictionary implementations.
This type enables dynamic creation of dictionaries optimized for package configuration and metadata management.</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TArchiveEvent">
<short>Event type for archive operations</short>
<descr>
<p><var>TArchiveEvent</var> defines the signature for event handlers that process archive operations.
This event type enables custom archive processing and notification during package archiving.</p>
<p>Event handlers receive the archive filename and file list, allowing custom processing,
validation, or modification of archive operations within the build system.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TArchiveEvent.AFileName">
<short>Filename for archive operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TArchiveEvent.List">
<short>List of files to archive</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TArchiveProc">
<short>Procedure type for archive operations</short>
<descr>
<p><var>TArchiveProc</var> defines the signature for procedural archive handlers that process file archiving operations.
This procedure type enables pluggable archive implementations and custom archiving logic.</p>
<p>Archive procedures receive the target filename and file list, implementing the actual
compression and archive creation functionality for the build system.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TArchiveProc.AFileName">
<short>Filename for archive procedure</short>
</element>

<!-- argument Visibility: default -->
<element name="TArchiveProc.List">
<short>List of files to archive</short>
</element>

<!-- variable Visibility: default -->
<element name="DictionaryClass">
<short>Global dictionary class variable</short>
<descr>
<p><var>DictionaryClass</var> is a global variable that holds the class reference for the default dictionary implementation.
This variable enables runtime configuration of which dictionary class to use throughout the build system.</p>
<p>The dictionary class is used for creating dictionary instances for template processing,
variable substitution, and configuration management within fpmake operations.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="PackageDictionaryClass">
<short>Global package dictionary class variable</short>
<descr>
<p><var>PackageDictionaryClass</var> is a global variable that holds the class reference for the default
package dictionary implementation. This variable configures which dictionary class to use for package-specific operations.</p>
<p>The package dictionary class is used for creating specialized dictionaries that handle package metadata,
configuration variables, and package-specific template processing within the build system.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="OnArchiveFiles">
<short>Global archive event handler</short>
<descr>
<p><var>OnArchiveFiles</var> is a global event handler variable for customizing archive file operations.
This event handler enables system-wide customization of archive processing behavior.</p>
<p>When assigned, this event handler is called during archive operations to enable custom processing,
validation, or modification of archive creation and file packaging operations.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="ArchiveFilesProc">
<short>Global archive procedure variable</short>
<descr>
<p><var>ArchiveFilesProc</var> is a global procedure variable that holds the archive implementation function.
This variable enables system-wide configuration of the archive creation mechanism.</p>
<p>The archive procedure is called to perform actual file compression and archive creation,
allowing pluggable archive implementations such as ZIP, TAR, or other compression formats.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="Defaults">
<short>Global defaults instance</short>
<descr>
<p><var>Defaults</var> is a global variable that holds the system-wide default configuration instance.
This variable provides access to default build settings, paths, and options throughout the fpmake system.</p>
<p>The defaults instance contains configuration values for compiler paths, installation directories,
build options, and other system-wide settings that apply to all package operations.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="GlobalDictionary">
<short>Global dictionary instance</short>
<descr>
<p><var>GlobalDictionary</var> is a global dictionary instance used for system-wide variable storage and template processing.
This dictionary provides a shared namespace for global configuration variables and template substitutions.</p>
<p>The global dictionary is accessible throughout the build system and enables sharing of common
variables and settings across different packages and build operations.</p>
</descr>
</element>

<!-- function Visibility: default -->
<element name="CurrentOS">
<short>Gets the current operating system</short>
<descr>
<p><var>CurrentOS</var> returns the current operating system identifier for the running platform.
This function provides platform detection for conditional compilation and platform-specific build operations.</p>
<p>The operating system identifier is used to select appropriate compiler options, file paths,
and installation procedures for the target platform.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="CurrentOS.Result">
<short>Current operating system identifier</short>
</element>

<!-- function Visibility: default -->
<element name="CurrentCPU">
<short>Gets the current CPU architecture</short>
<descr>
<p><var>CurrentCPU</var> returns the current CPU architecture identifier for the running platform.
This function provides architecture detection for conditional compilation and architecture-specific build settings.</p>
<p>The CPU architecture identifier is used to select appropriate compiler targets, optimization options,
and platform-specific code generation settings during the build process.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="CurrentCPU.Result">
<short>Current CPU architecture identifier</short>
</element>

<!-- function Visibility: default -->
<element name="Installer">
<short>Gets the current installer instance</short>
<descr>
<p><var>Installer</var> returns the current installer instance or creates a new one using the specified installer class.
Note that only one class can be instantiated.
This function provides access to the global installer object for package management operations.</p>
<p>The installer instance manages the build process, package compilation, installation, and other
package lifecycle operations within the fpmake system.</p>
<p>
If no class is specified and no instance is present yet, the <link id="TFPCInstaller"/> class is used to create the installer class.
</p>
</descr>
<seealso>
<link id="TFPCInstaller"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Installer.Result">
<short>Current installer object</short>
</element>

<!-- argument Visibility: default -->
<element name="Installer.InstallerClass">
<short>Installer class to instantiate</short>
</element>

<!-- function Visibility: default -->
<element name="OSToString">
<short>Converts operating system identifier to string</short>
<descr>
<p><var>OSToString</var> converts an operating system identifier enumeration value to its string representation.
This function provides human-readable names for operating system identifiers used in build configuration.</p>
<p>The string representation is useful for logging, configuration files, and user interface display
of platform-specific information within the build system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="OSToString.Result">
<short>String representation of the operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="OSToString.OS">
<short>Operating system identifier to convert</short>
</element>

<!-- function Visibility: default -->
<element name="OSesToString">
<short>Converts set of operating systems to string</short>
<descr>
<p><var>OSesToString</var> converts a set of operating system identifiers to a comma-separated string representation.
This function provides a readable format for displaying multiple operating system targets.</p>
<p>The string representation is useful for logging supported platforms, configuration display,
and documentation of multi-platform package compatibility.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="OSesToString.Result">
<short>String representation of operating systems set</short>
</element>

<!-- argument Visibility: default -->
<element name="OSesToString.OSes">
<short>Set of operating systems to convert</short>
</element>

<!-- function Visibility: default -->
<element name="CPUToString">
<short>Converts CPU architecture identifier to string</short>
<descr>
<p><var>CPUToString</var> converts a CPU architecture identifier enumeration value to its string representation.
This function provides human-readable names for CPU architectures used in build configuration.</p>
<p>The string representation is useful for logging, configuration files, and user interface display
of architecture-specific information within the build system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="CPUToString.Result">
<short>String representation of the CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="CPUToString.CPU">
<short>CPU architecture identifier to convert</short>
</element>

<!-- function Visibility: default -->
<element name="CPUSToString">
<short>Converts set of CPU architectures to string</short>
<descr>
<p><var>CPUSToString</var> converts a set of CPU architecture identifiers to a comma-separated string representation.
This function provides a readable format for displaying multiple CPU architecture targets.</p>
<p>The string representation is used when logging supported architectures and configuration display.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="CPUSToString.Result">
<short>String representation of CPU architectures set</short>
</element>

<!-- argument Visibility: default -->
<element name="CPUSToString.CPUS">
<short>Set of CPU architectures to convert</short>
</element>

<!-- function Visibility: default -->
<element name="StringToOS">
<short>Converts string to operating system identifier</short>
<descr>
<p><var>StringToOS</var> converts a string representation of an operating system to its corresponding identifier enumeration.
This function enables parsing of operating system names from configuration files and command-line parameters.</p>
<p>The function supports standard operating system names.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="StringToOS.Result">
<short>Operating system identifier from string</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToOS.S">
<short>String representation of operating system</short>
</element>

<!-- function Visibility: default -->
<element name="IsDifferentFromBuild">
<short>Checks if target differs from build platform</short>
<descr>
<p><var>IsDifferentFromBuild</var> determines whether the specified target operating system and CPU architecture
differ from the current build platform. This function enables detection of cross-compilation scenarios.</p>
<p>The function returns <var>True</var> when building for a different platform than the current build system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="IsDifferentFromBuild.Result">
<short>True if target platform differs from build platform</short>
</element>

<!-- argument Visibility: default -->
<element name="IsDifferentFromBuild.ACpu">
<short>Target CPU architecture to check</short>
</element>

<!-- argument Visibility: default -->
<element name="IsDifferentFromBuild.AOs">
<short>Target operating system to check</short>
</element>

<!-- function Visibility: default -->
<element name="StringToCPU">
<short>Converts string to CPU architecture identifier</short>
<descr>
<p><var>StringToCPU</var> converts a string representation of a CPU architecture to its corresponding identifier enumeration.
This function enables parsing of CPU architecture names from configuration files and command-line parameters.</p>
<p>The function supports standard CPU architecture names.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="StringToCPU.Result">
<short>CPU architecture identifier from string</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToCPU.S">
<short>String representation of CPU architecture</short>
</element>

<!-- function Visibility: default -->
<element name="StringToCPUS">
<short>Converts string to CPU architecture set</short>
<descr>
<p><var>StringToCPUS</var> converts a comma-separated string of CPU architectures to a set of CPU identifier enumerations.
This function enables parsing of multiple CPU architecture targets from configuration strings.</p>
<p>The function processes comma-separated architecture names and builds a set containing
all valid CPU architecture identifiers found in the input string.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="StringToCPUS.Result">
<short>CPU architecture set from string</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToCPUS.S">
<short>String representation of CPU architectures</short>
</element>

<!-- function Visibility: default -->
<element name="ModeToString">
<short>Converts build mode to string representation</short>
<descr>
<p><var>ModeToString</var> converts a build mode identifier enumeration to its string representation.
This function provides human-readable names for build modes used in build configuration.</p>
<p>The string representation includes modes such as debug, release, and other build configurations
useful for logging and user interface display within the build system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="ModeToString.Result">
<short>String representation of the build mode</short>
</element>

<!-- argument Visibility: default -->
<element name="ModeToString.Mode">
<short>Build mode to convert to string</short>
</element>

<!-- function Visibility: default -->
<element name="StringToMode">
<short>Converts string to build mode identifier</short>
<descr>
<p><var>StringToMode</var> converts a string representation of a build mode to its corresponding identifier enumeration.
This function enables parsing of build mode names from configuration files and command-line parameters.</p>
<p>The function supports standard build mode names such as debug, release, and custom modes,
providing error handling for invalid or unrecognized mode strings.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="StringToMode.Result">
<short>Build mode identifier from string</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToMode.S">
<short>String representation of build mode</short>
</element>

<!-- function Visibility: default -->
<element name="MakeTargetString">
<short>Creates target string from parameters</short>
<descr>
<p><var>MakeTargetString</var> constructs a formatted target string from CPU architecture, operating system, and build mode parameters.
This function creates standardized target identifiers used throughout the build system.</p>
<p>The generated target string format enables consistent identification of build configurations
and target platforms within package management and compilation operations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="MakeTargetString.Result">
<short>Generated target string</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeTargetString.aTarget">
<short>Target type for string generation</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeTargetString.aLimit83">
<short>Whether to limit filename to 8.3 format</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeTargetString.CPU">
<short>CPU architecture for target string</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeTargetString.OS">
<short>Operating system for target string</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeTargetString.aSubTarget">
<short>Subtarget for target string generation</short>
</element>

<!-- procedure Visibility: default -->
<element name="StringToCPUOS">
<short>Parses string to extract CPU and OS information</short>
<descr>
<p><var>StringToCPUOS</var> parses a combined string containing CPU architecture and operating system information,
extracting the individual CPU and OS identifiers. This procedure handles target string parsing for build configuration.</p>
<p>The procedure processes target strings in various formats and populates the output parameters
with the corresponding CPU architecture and operating system enumeration values.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="StringToCPUOS.S">
<short>String containing CPU and OS information</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToCPUOS.CPU">
<short>Extracted CPU architecture identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="StringToCPUOS.OS">
<short>Extracted operating system identifier</short>
</element>

<!-- function Visibility: default -->
<element name="FixPath">
<short>Normalizes and fixes file path format</short>
<descr>
<p><var>FixPath</var> normalizes file paths by converting directory separators to the platform-appropriate format
and ensuring consistent path representation. This function handles cross-platform path compatibility.</p>
<p>The normalization includes converting forward/backward slashes, removing redundant separators,
and ensuring proper directory path formatting for the target operating system.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="FixPath.Result">
<short>Normalized file path</short>
</element>

<!-- argument Visibility: default -->
<element name="FixPath.APath">
<short>File path to normalize</short>
</element>

<!-- argument Visibility: default -->
<element name="FixPath.AIsDir">
<short>Whether the path is a directory</short>
</element>

<!-- function Visibility: default -->
<element name="IsRelativePath">
<short>Checks if a path is relative</short>
<descr>
<p><var>IsRelativePath</var> determines whether a file path is relative or absolute by examining its format.
This function provides platform-aware path type detection for build system operations.</p>
<p>The function returns <var>True</var> for relative paths and <var>False</var> for absolute paths.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="IsRelativePath.Result">
<short>Whether the path is relative</short>
</element>

<!-- argument Visibility: default -->
<element name="IsRelativePath.APath">
<short>File path to check</short>
</element>

<!-- procedure Visibility: default -->
<element name="ChangeDir">
<short>Changes current working directory</short>
<descr>
<p><var>ChangeDir</var> changes the current working directory to the specified path and handles errors appropriately.
This procedure provides controlled directory navigation during build operations.</p>
<p>The procedure validates the target directory exists and is accessible before changing the working directory.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="ChangeDir.APath">
<short>Directory path to change to</short>
</element>

<!-- procedure Visibility: default -->
<element name="SplitCommand">
<short>Splits command line into executable and options</short>
<descr>
<p><var>SplitCommand</var> parses a complete command line string and separates it into the executable name and its command-line options.
This procedure handles quoted arguments and proper command-line parsing for the build system.</p>
<p>The procedure populates separate output parameters with the executable name and the remaining options.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="SplitCommand.Cmd">
<short>Complete command line to split</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitCommand.Exe">
<short>Extracted executable name</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitCommand.Options">
<short>Extracted command line options</short>
</element>

<!-- procedure Visibility: default -->
<element name="AddCustomFpmakeCommandlineOption">
<short>Adds custom command line option to FPMake</short>
<descr>
<p>Registers a custom command line option that will be recognized by the FPMake build system.
This allows packages to define their own command line parameters for build customization.</p>
<p>After the command-line has been parsed, the value specified by the user can be retrieved
with the <link id="GetCustomFpmakeCommandlineOptionValue"/> function.</p>
</descr>
<seealso>
<link id="GetCustomFpmakeCommandlineOptionValue"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="AddCustomFpmakeCommandlineOption.ACommandLineOption">
<short>Command line option name to add</short>
</element>

<!-- argument Visibility: default -->
<element name="AddCustomFpmakeCommandlineOption.HelpMessage">
<short>Help text for the command line option</short>
</element>

<!-- function Visibility: default -->
<element name="GetCustomFpmakeCommandlineOptionValue">
<short>Gets value of custom command line option</short>
<descr>
<p><var>GetCustomFpmakeCommandlineOptionValue</var> retrieves the value of a previously registered custom command line option.
This function enables packages to access their custom command-line parameters during build operations.</p>
<p>The function returns the value specified for the command line option.</p>
<p>The custom command-line option must have been registered using the <link id="AddCustomFpmakeCommandlineOption"/> function first.</p>
</descr>
<seealso>
<link id="AddCustomFpmakeCommandlineOption"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetCustomFpmakeCommandlineOptionValue.Result">
<short>Value of the command line option</short>
</element>

<!-- argument Visibility: default -->
<element name="GetCustomFpmakeCommandlineOptionValue.ACommandLineOption">
<short>Command line option name to retrieve</short>
</element>

<!-- function Visibility: default -->
<element name="AddProgramExtension">
<short>Adds appropriate extension to program name</short>
<descr>
<p><var>AddProgramExtension</var> adds the platform-appropriate file extension to an executable program name.
This function ensures proper executable naming conventions for different operating systems.</p>
<p>The function appends extensions such as .exe for Windows or leaves names unchanged for Unix-like systems,
ensuring correct executable file naming for the target platform.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="AddProgramExtension.Result">
<short>Program name with platform-appropriate extension</short>
</element>

<!-- argument Visibility: default -->
<element name="AddProgramExtension.ExecutableName">
<short>Base executable name to extend</short>
</element>

<!-- argument Visibility: default -->
<element name="AddProgramExtension.AOS">
<short>Target operating system for extension</short>
</element>

<!-- function Visibility: default -->
<element name="AddLibraryExtension">
<short>Adds appropriate extension to library name</short>
<descr>
<p><var>AddLibraryExtension</var> adds the platform-appropriate file extension to a library name.
This function ensures proper library naming conventions for different operating systems.</p>
<p>The function appends extensions such as .dll for Windows, .so for Linux, or .dylib for macOS,
ensuring correct library file naming for the target platform.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="AddLibraryExtension.Result">
<short>Library name with platform-appropriate extension</short>
</element>

<!-- argument Visibility: default -->
<element name="AddLibraryExtension.LibraryName">
<short>Base library name to extend</short>
</element>

<!-- argument Visibility: default -->
<element name="AddLibraryExtension.AOS">
<short>Target operating system for extension</short>
</element>

<!-- function Visibility: default -->
<element name="GetImportLibraryFilename">
<short>Gets filename for import library</short>
<descr>
<p><var>GetImportLibraryFilename</var> generates the appropriate import library filename for a unit on the specified operating system.
Import libraries are used on platforms like Windows to link against dynamic libraries.</p>
<p>The function constructs the correct import library name following platform conventions,
enabling proper linking with dynamic libraries during the compilation process.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="GetImportLibraryFilename.Result">
<short>Import library filename</short>
</element>

<!-- argument Visibility: default -->
<element name="GetImportLibraryFilename.UnitName">
<short>Unit name for import library</short>
</element>

<!-- argument Visibility: default -->
<element name="GetImportLibraryFilename.AOS">
<short>Target operating system</short>
</element>

<!-- procedure Visibility: default -->
<element name="SearchFiles">
<short>Searches for files in specified paths</short>
<descr>
<p><var>SearchFiles</var> searches for files matching a filename pattern within specified search paths.
This procedure supports recursive directory traversal and wildcard pattern matching for file discovery.</p>
<p>The procedure populates a provided list with all matching files found during the search,
enabling file location and collection for build operations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="SearchFiles.AFileName">
<short>Filename pattern to search for</short>
</element>

<!-- argument Visibility: default -->
<element name="SearchFiles.ASearchPathPrefix">
<short>Search path prefix</short>
</element>

<!-- argument Visibility: default -->
<element name="SearchFiles.Recursive">
<short>Whether to search recursively</short>
</element>

<!-- argument Visibility: default -->
<element name="SearchFiles.List">
<short>List to store found files</short>
</element>

<!-- function Visibility: default -->
<element name="GetDefaultLibGCCDir">
<short>Gets default GCC library directory</short>
<descr>
<p><var>GetDefaultLibGCCDir</var> determines the default GCC library directory for the specified CPU architecture and operating system.
This function locates system GCC libraries required for linking compiled programs.</p>
<p>The function searches standard locations and returns the appropriate GCC library path.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="GetDefaultLibGCCDir.Result">
<short>Default GCC library directory path</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefaultLibGCCDir.CPU">
<short>Target CPU architecture</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefaultLibGCCDir.OS">
<short>Target operating system</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefaultLibGCCDir.ErrorMessage">
<short>Error message if directory not found</short>
</element>

<!-- function Visibility: default -->
<element name="GetPluginManager">
<short>Gets the global plugin manager instance</short>
<descr>
<p>Returns the global plugin manager instance used by the FPMake build system.
The plugin manager handles loading and managing build system extensions and add-ins.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="GetPluginManager.Result">
<short>Plugin manager instance</short>
</element>

</module> <!-- fpmkunit -->

</package>
</fpdoc-descriptions>
