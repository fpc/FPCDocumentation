<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="fcl">

<!--
  ====================================================================
    fpexprpars
  ====================================================================
-->

<module name="fpexprpars">
<short>Provides expression parsing with support for variables, functions, and mathematical operations</short>
<descr>
<p>This unit implements an expression parser and evaluator that supports a wide variety of data types, 
mathematical operations, and built-in functions. 
It provides the infrastructure for parsing and evaluating mathematical expressions with support for variables, functions, and complex data types.</p>
<p>The parser supports the following features:</p>
<ul>
<li>Multiple data types: integers, floats, strings, booleans, dates, and currency</li>
<li>Standard mathematical operators: +, -, *, /, mod, power</li>
<li>Comparison operators: =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=</li>
<li>Logical operators: and, or, xor, not</li>
<li>Built-in mathematical, string, and date/time functions comparable to what exists in the <link id="#rtl.sysutils">SysUtils</link> unit.</li>
<li>Variable and function definitions</li>
<li>Conditional expressions (if-then-else)</li>
<li>Aggregate functions for data processing</li>
</ul>
<p>The unit is designed to be extensible, allowing custom functions and variables to be registered with the parser for specialized applications.</p>
</descr>

<!-- uses unit Visibility: default -->
<element name="Classes">
<short>Provides basic object and class support</short>
</element>

<!-- uses unit Visibility: default -->
<element name="SysUtils">
<short>Provides system utility functions and classes</short>
</element>

<!-- uses unit Visibility: default -->
<element name="contnrs">
<short>Provides container classes for data storage</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTokenType">
<short>Type representing different token types in expression parsing</short>
<descr>
<p>This enumeration defines all possible token types that can be encountered during expression parsing and lexical analysis. 
Each token type represents a fundamental unit of the expression language, from operators and keywords to literals and identifiers.</p>
<p>The token types are organized into several categories:</p>
<ul>
<li>Arithmetic operators: ttPlus, ttMinus, ttMul, ttDiv, ttMod, ttPower</li>
<li>Comparison operators: ttEqual, ttUnequal, ttLessThan, ttLargerThan, ttLessThanEqual, ttLargerThanEqual</li>
<li>Logical operators: ttAnd, ttOr, ttXor, ttNot</li>
<li>Literals: ttNumber, ttString, ttTrue, ttFalse</li>
<li>Structure tokens: ttLeft, ttRight, ttComma</li>
<li>Keywords: ttIf, ttCase</li>
<li>Special tokens: ttIdentifier, ttEOF</li>
</ul>
<p>The <link id="TFPExpressionScanner">TFPExpressionScanner</link> uses these token types to categorize input text during 
the lexical analysis phase of expression parsing.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttPlus">
<short>Plus operator token (+)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttMinus">
<short>Minus operator token (-)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttLessThan">
<short>Less than comparison operator token (&lt;)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttLargerThan">
<short>Greater than comparison operator token (&gt;)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttEqual">
<short>Equality comparison operator token (=)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttDiv">
<short>Division operator token (/)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttMod">
<short>Modulo operator token (mod)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttMul">
<short>Multiplication operator token (*)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttLeft">
<short>Left parenthesis token (()</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttRight">
<short>Right parenthesis token ())</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttLessThanEqual">
<short>Less than or equal comparison operator token (&lt;=)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttLargerThanEqual">
<short>Greater than or equal comparison operator token (>=)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttunequal">
<short>Inequality comparison operator token (&lt;&gt;)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttNumber">
<short>Numeric literal token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttString">
<short>String literal token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttIdentifier">
<short>Identifier token (variable or function name)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttComma">
<short>Comma separator token (,)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttAnd">
<short>Logical AND operator token (and)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttOr">
<short>Logical OR operator token (or)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttXor">
<short>Logical XOR operator token (xor)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttTrue">
<short>Boolean true literal token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttFalse">
<short>Boolean false literal token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttNot">
<short>Logical NOT operator token (not)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttif">
<short>Conditional if keyword token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttCase">
<short>Case conditional keyword token</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttPower">
<short>Power/exponentiation operator token (**)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTokenType.ttEOF">
<short>End of file token marking end of input</short>
</element>

<!-- alias type Visibility: default -->
<element name="TExprFloat">
<short>Type representing floating-point values in expressions</short>
<descr>
<p>This type alias defines the standard floating-point data type used throughout the expression parser for all floating-point calculations and storage. 
It is currently defined as Double, providing the highest cross-platform precision for mathematical operations.</p>
<p>All floating-point operations within the expression parser, including mathematical functions and numeric conversions, 
use this type to ensure consistency and precision. 
The type is used in expression results, intermediate calculations, and function parameters.</p>
<p>Using a type alias allows for easy modification of the underlying floating-point precision across the 
entire expression parsing system if needed for specific applications or platforms.</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ttDelimiters">
<short>Set of token types used as operators and delimiters</short>
<descr>
<p>This constant set contains all <link id="TTokenType">TTokenType</link> values that represent operators and structural delimiters in expressions. 
It includes arithmetic operators, comparison operators, parentheses, and the power operator.</p>
<p>The set is used by the parser and scanner to identify tokens that serve as operators or structural elements, 
allowing the parser to distinguish between operands and operators during expression analysis.</p>
</descr>
<seealso>
<link id="ttComparisons"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ttComparisons">
<short>Set of token types used for comparison operations</short>
<descr>
<p>This constant set contains all <link id="TTokenType">TTokenType</link> values that represent comparison operators in expressions. 
It includes equality, inequality, and ordering operators such as equal, unequal, less than, greater than, less than or equal, and greater than or equal.</p>
<p>The set is used by the parser to identify comparison operations and ensure proper precedence handling when evaluating expressions.</p>
</descr>
<seealso>
<link id="ttDelimiters"/>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TFPExpressionParser">
<short>Class for parsing and evaluating mathematical expressions</short>
<descr>
<p>This is the main expression parser class that provides comprehensive functionality for parsing and evaluating mathematical expressions.</p>
<p>The parser handles the complete expression evaluation pipeline from tokenization through parsing to evaluation, 
supporting complex expressions with proper operator precedence, parentheses, function calls, and variable references.</p>
<p>Key features include built-in mathematical functions, string operations, date/time handling, boolean logic, 
comparison operations, and extensibility through custom functions and variables.</p>
</descr>
<seealso>
<link id="TExprBuiltInManager"/>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TExprBuiltInManager">
<short>Class for managing built-in functions and variables in expressions</short>
<descr>
<p>The <var>TExprBuiltInManager</var> class serves as a manager for built-in functions and predefined variables that can be used within expressions. 
It provides a centralized registry where built-in mathematical functions, string functions, date/time functions, 
and system variables are registered and made available to the expression parser.</p>
<p>The manager handles the registration, lookup, and instantiation of built-in functions when they are encountered during expression parsing. 
It also maintains predefined variables such as system constants that can be referenced in expressions.</p>
<p>The <var>TExprBuiltInManager</var> class allows for extensibility by enabling the registration of custom built-in functions and variables that should be available 
across all expression evaluations.</p>
</descr>
<seealso>
<link id="TFPExpressionParser"/>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TFPExprFunction">
<short>Internally used class for representing function calls in expression trees</short>
<descr>
<p>The <link id="TFPExprFunction">TFPExprFunction</link> class represents a function call node in the expression tree. 
It serves as the base class for all function implementations that can be called from within expressions, 
including mathematical functions, string functions, date/time functions, and user-defined functions.</p>
<p>The class manages function parameters, validates argument types and counts, and provides the framework 
for function evaluation. It handles the common aspects of function calls such as parameter management and type checking.</p>
<p>Derived classes implement specific functions by overriding the evaluation methods and providing function-specific logic. 
The class supports functions with varying numbers of parameters and different return types.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFPExprFunctionClass">
<short>Class reference type for TFPExprFunction</short>
<descr>
<p>This is a class reference type (metaclass) for <link id="TFPExprFunction">TFPExprFunction</link>. 
</p>
<p>This type is used by the function registry to store references to function classes that can be instantiated when the corresponding function is called in an expression.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TNumberKind">
<short>Type representing different number formats that can be parsed</short>
<descr>
<p>This enumeration defines the different numerical base formats that the expression scanner can recognize and parse when tokenizing numeric literals in expressions.</p>
<p>The scanner can handle numbers in various bases commonly used in programming and mathematical contexts, 
allowing expressions to contain numbers in the most convenient format for the specific use case.</p>
<p>Each kind represents a different base system with its own parsing rules and digit validation requirements during the scanning process.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNumberKind.nkDecimal">
<short>Decimal number format (base 10)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNumberKind.nkHex">
<short>Hexadecimal number format (base 16)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNumberKind.nkOctal">
<short>Octal number format (base 8)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TNumberKind.nkBinary">
<short>Binary number format (base 2)</short>
</element>

<!-- class Visibility: default -->
<element name="TFPExpressionScanner">
<short>Class for tokenizing expression strings into parser tokens</short>
<descr>
<p>The <var>TFPExpressionScanner</var> class performs lexical analysis on expression strings, breaking them into tokens that can be consumed by the expression parser.
It handles the low-level details of character recognition, string parsing, and token classification.</p>
<p>The scanner recognizes all token types defined in <link id="TTokenType">TTokenType</link> including operators, literals, identifiers, keywords, and delimiters.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TFPExpressionScanner.Create">
<short>Create a new expression scanner</short>
<descr>
<p>The <var>Create</var> constructor creates a new expression scanner instance and initializes its internal state for tokenizing expression strings.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionScanner.GetToken">
<short>Get the next token from the source expression</short>
<descr>
<p>The <var>GetToken</var> method advances the scanner to the next token in the source expression and returns the token type.
The token text is made available through the Token property.</p>
<p>The method handles all aspects of tokenization including whitespace skipping,
literal parsing, operator recognition, and error detection for invalid character sequences.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionScanner.GetToken.Result">
<short>Returns the type of token that was found</short>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionScanner.Token">
<short>The text of the current token</short>
<descr>
<p>This read-only property provides access to the text content of the token that was most recently extracted by the scanner. 
For identifiers and literals, this contains the exact text from the expression;
for operators and keywords, it contains the recognized symbol or word.</p>
<p>The property is updated automatically when <link id="TFPExpressionScanner.GetToken">GetToken</link> is called to advance to the next token.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionScanner.TokenType">
<short>The type of the current token</short>
<descr>
<p>This read-only property returns the type classification of the current token using values from the <link id="TTokenType">TTokenType</link> enumeration.
It indicates whether the token is an operator, identifier, literal, keyword, or delimiter.</p>
<p>The property is automatically updated when <link id="TFPExpressionScanner.GetToken">GetToken</link> advances to the next token.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionScanner.Source">
<short>The source expression string to scan</short>
<descr>
<p>The <var>Source</var> property gets or sets the expression string that will be tokenized by the scanner.
When assigned, the scanner resets its position to the beginning and prepares for tokenizing the new expression.</p>
<p>Setting this property initializes the scanning process and makes the scanner ready to extract tokens from the expression string.
The source string should contain a valid mathematical or logical expression using the supported syntax.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionScanner.Pos">
<short>Current position in the source string</short>
<descr>
<p>This read-only property returns the current character position within the source expression string during scanning.
The position starts at 1 (first character) and advances as tokens are extracted.</p>
<p>The position value is useful for error reporting and debugging, as it indicates exactly where in the
expression the scanner is currently located or where an error occurred during tokenization.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionScanner.CurrentChar">
<short>The current character being processed</short>
<descr>
<p>This read-only property returns the character at the current scanning position in the source expression string.
It provides access to the character that will be processed next during tokenization.</p>
<p>The property is useful for debugging and for understanding what character the scanner is currently examining.
When the scanner reaches the end of the source string, this property may return a null character or end-of-string marker.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="EExprScanner">
<short>Exception class for scanner errors</short>
<descr>
<p>This exception class is raised by the <link id="TFPExpressionScanner">TFPExpressionScanner</link> when lexical analysis errors occur during expression scanning.
It indicates problems encountered while tokenizing the input expression text.</p>
<p>Common scenarios that trigger this exception include:</p>
<ul>
<li>Invalid character sequences that cannot be recognized as valid tokens</li>
<li>Malformed string literals (unclosed quotes)</li>
<li>Invalid numeric literals (malformed number formats)</li>
<li>Unexpected characters that violate the expression grammar</li>
</ul>
<p>The exception typically provides detailed error information including the position where the error occurred and a description of what went wrong during the scanning process.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TResultType">
<short>Type representing different result data types in expressions</short>
<descr>
<p>This enumeration defines all possible data types that can be produced as results from expression evaluation.
Each value represents a specific data type that expression nodes can return, enabling type checking and proper value handling.</p>
<p>The result type system ensures that expressions are properly typed and that operations between different
types are handled correctly through appropriate type conversions when needed.</p>
<p>These types correspond to the variant record fields in <link id="TFPExpressionResult">TFPExpressionResult</link> and determine how result values should be interpreted and stored.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtBoolean">
<short>Boolean result type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtInteger">
<short>Integer result type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtFloat">
<short>Floating-point result type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtDateTime">
<short>Date/time result type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtString">
<short>String result type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TResultType.rtCurrency">
<short>Currency result type</short>
</element>

<!-- set type Visibility: default -->
<element name="TResultTypes">
<short>Set of result types</short>
<descr>
<p>This set type allows for specifying collections of <link id="TResultType">TResultType</link> values.
It is used in validation and type checking to define which result types are acceptable for specific operations or functions.</p>
<p>For example, arithmetic operations might accept a set containing rtInteger and rtFloat types,
while comparison operations might accept a broader set of types that can be compared.</p>
</descr>
</element>

<!-- record type Visibility: default -->
<element name="TFPExpressionResult">
<short>Record representing the result of expression evaluation</short>
<descr>
<p>The <var>TFPExpressionResult</var> record stores the result of evaluating an expression node, containing both the actual value and type information.</p>
<p>The <var>ResultType</var> field indicates which variant is active and determines how to interpret the value stored in the record.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResString">
<short>String value when result type is string</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResultType">
<short>The type of the result value</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResBoolean">
<short>Boolean value when result type is boolean</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResInteger">
<short>Integer value when result type is integer</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResFloat">
<short>Float value when result type is float</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResCurrency">
<short>Currency value when result type is currency</short>
</element>

<!-- variable Visibility: default -->
<element name="TFPExpressionResult.ResDateTime">
<short>DateTime value when result type is datetime</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PFPExpressionResult">
<short>Pointer to TFPExpressionResult record</short>
<descr>
<p>This type defines a pointer to a <link id="TFPExpressionResult">TFPExpressionResult</link> record.
It is used in function interfaces where results need to be passed by reference or when dynamic allocation of result records is required.</p>
</descr>
</element>

<!-- array type Visibility: default -->
<element name="TExprParameterArray">
<short>Array type for function parameters in expressions</short>
<descr>
<p>This array type holds the parameter values passed to functions during expression evaluation.
Each element is a <link id="TFPExpressionResult">TFPExpressionResult</link> containing both the value and type information for one parameter.</p>
<p>The array is dynamically sized to accommodate functions with varying numbers of parameters.
Functions use this array to access their input parameters and determine their types during evaluation.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPExprNode">
<short>Class for representing nodes in expression trees</short>
<descr>
<p>This is the abstract base class for all nodes in the expression tree.
Every element of a parsed expression (literals, variables, operators, functions) is represented by a class derived from <var>TFPExprNode</var>.</p>
<p>The class defines the common interface that all expression nodes must implement, including evaluation, type checking, and aggregate processing.
It provides the foundation for building complex expression trees through composition of different node types.</p>
<p>Derived classes implement specific functionality for different types of expression elements such as arithmetic operations,
function calls, variable references, and literal values.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprNode.Check">
<short>Validate the expression node for correctness</short>
<descr>
<p>The <var>Check</var> abstract method must be implemented by derived classes to validate the expression node and its operands or parameters.
It performs type checking, verifies that required operands are present, and ensures that the node can be safely evaluated.</p>
<p>The validation process typically includes checking operand types for compatibility, verifying function parameter counts and types,
and ensuring that all required references (variables, functions) are available.
If validation fails, appropriate exceptions must be raised.</p>
<p>The <link id="TFPExprNode.Check">Check</link> method is called during the expression preparation phase,
before evaluation begins, to catch errors early and provide meaningful error messages.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprNode.InitAggregate">
<short>Initialize aggregate processing for the node</short>
<descr>
<p>The <var>InitAggregate</var> virtual method initializes aggregate processing state for nodes that participate in aggregate operations.
It is called at the beginning of an aggregate processing cycle to reset counters, accumulators, and other aggregate state.</p>
<p>For most expression nodes, this method does nothing (default implementation).
However, nodes representing aggregate functions (like SUM, COUNT, AVG) override this method to initialize their aggregation state.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprNode.UpdateAggregate">
<short>Update aggregate calculations for the node</short>
<descr>
<p>The <var>UpdateAggregate</var> virtual method updates the aggregate calculation state for nodes that participate in aggregate operations.
It is called for each data row or iteration during aggregate processing to incorporate new values into the ongoing calculation.</p>
<p>For most expression nodes, this method does nothing (default implementation).
Nodes representing aggregate functions override this method to update their running totals, counts, or other aggregate state based on the current data values.</p>
<p>The <var>UpdateAggregate</var> method works in conjunction with <link id="TFPExprNode.InitAggregate">InitAggregate</link> to implement the aggregate processing cycle.</p>
</descr>
</element>

<!-- class function Visibility: public -->
<element name="TFPExprNode.IsAggregate">
<short>Check if this node represents an aggregate operation</short>
<descr>
<p>The <var>IsAggregate</var> class method returns True if the node class represents an aggregate operation that requires special processing during expression evaluation.
Most node types return False, indicating they are simple expression elements.</p>
<p>Aggregate nodes (like SUM, COUNT, AVG functions) return True to indicate they need to participate in the aggregate processing cycle with initialization and update phases.</p>
<p>The <var>IsAggregate</var> method allows the expression evaluator to identify which nodes need aggregate processing and to ensure proper handling of aggregate expressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprNode.IsAggregate.Result">
<short>Returns true if the node is an aggregate</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprNode.HasAggregate">
<short>Check if node tree contains any aggregate operations</short>
<descr>
<p>The <var>HasAggregate</var> method examines the expression subtree rooted at this node to determine if it contains any aggregate operations.
It returns True if this node or any of its descendant nodes represents an aggregate operation.</p>
<p>The method recursively checks child nodes to detect aggregate functions anywhere in the expression tree.
This information is used by the expression evaluator to determine if aggregate processing is required for the expression.</p>
<p>Unlike <link id="TFPExprNode.IsAggregate">IsAggregate</link> which only checks the current node,
this method performs a search of the entire subtree.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprNode.HasAggregate.Result">
<short>Returns true if tree has aggregate operations</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprNode.NodeType">
<short>Get the result type of this expression node</short>
<descr>
<p>The <var>NodeType</var> abstract method must be implemented by derived classes to return the <link id="TResultType">TResultType</link>
that indicates what type of value this node will produce when evaluated.</p>
<p>The result type information is essential for type checking during expression validation
and for determining appropriate type conversions when combining values from different nodes.</p>
<p>Common result types include boolean, integer, float, string, datetime, and currency,
depending on the specific operation or value represented by the node.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprNode.NodeType.Result">
<short>Returns the result type of the node</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprNode.NodeValue">
<short>Get the evaluated value of this expression node</short>
<descr>
<p>The <var>NodeValue</var> method evaluates the expression node and returns the result as a
<link id="TFPExpressionResult">TFPExpressionResult</link> record containing both the value and its type information.</p>
<p>The method performs the actual computation represented by this node, including evaluating any child nodes or operands as needed.
For simple nodes like literals, it returns the stored value; for complex nodes like operations, it computes the result from its operands.</p>
<p>The returned result includes type information to ensure proper handling of the value by calling code.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprNode.NodeValue.Result">
<short>Returns the evaluated result of the node</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprNode.AsString">
<short>Get string representation of the expression node</short>
<descr>
<p>The <var>AsString</var> abstract method must be implemented by derived classes to return a string representation of the expression node and its structure.
The string typically shows the operation or value in a human-readable format.</p>
<p>For operations, the string usually includes the operands and operator (e.g., "A + B").
For literals, it shows the value. For function calls, it shows the function name and parameters.</p>
<p>The <link id="TFPExprNode.AsString">AsString</link> method is primarily used for debugging, logging, and displaying expression structures to users.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprNode.AsString.Result">
<short>Returns string representation of the node</short>
</element>

<!-- array type Visibility: default -->
<element name="TExprArgumentArray">
<short>Array type for expression arguments</short>
<descr>
<p>The <var>TExprArgumentArray</var> array type holds the argument nodes passed to functions and operations that accept multiple parameters.
Each element is a <link id="TFPExprNode">TFPExprNode</link> representing one argument expression.</p>
<p>The array is dynamically sized to accommodate functions with varying numbers of arguments.
Functions and operations use this array to access their argument nodes and evaluate them during expression processing.</p>
<p>Unlike <link id="TExprParameterArray"/> which holds evaluated results, this array holds the actual expression nodes that produce the argument values.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPBinaryOperation">
<short>Internally used class for binary operations with left and right operands</short>
<descr>
<p>This <var>TFPBinaryOperation</var> is the base class for all binary operations in the expression parser.
Binary operations take two operands (left and right) and perform some operation to produce a result.
It extends <link id="TFPExprNode">TFPExprNode</link> to provide the foundation for all two-operand operations.</p>
<p>The class manages the operand nodes and provides common functionality such as aggregate handling,
validation, and resource management that is shared by all binary operations.</p>
<p>Derived classes implement specific operations such as arithmetic operations (+, -, *, /),
comparison operations (=, &lt;, &gt;), and logical operations (and, or, xor).
Each operation defines its own evaluation logic while leveraging the common binary operation infrastructure.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPBinaryOperation.Create">
<short>Create binary operation with left and right operands</short>
<descr>
<p>The <var>TFPBinaryOperation</var> constructor creates a new binary operation with the specified left and right operands.
It takes ownership of both operand nodes and manages their lifecycle as part of the binary operation.</p>
<p>The constructor properly initializes the binary operation structure and establishes the relationship
between the operation and its operands, ensuring that the operands are properly managed during the operation's lifetime.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPBinaryOperation.Create.ALeft">
<short>The left operand of the binary operation</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPBinaryOperation.Create.ARight">
<short>The right operand of the binary operation</short>
</element>

<!-- destructor Visibility: public -->
<element name="TFPBinaryOperation.Destroy">
<short>Destroy binary operation and free resources</short>
<descr>
<p>This destructor properly cleans up the binary operation by freeing both the left and right operand nodes and any other resources used by the operation.</p>
<p>The destructor ensures that all memory allocated for the operands is properly released, preventing memory leaks in complex expression trees.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBinaryOperation.InitAggregate">
<short>Initialize aggregate processing for binary operation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes aggregate processing for both the left and right operands of the binary operation.
It delegates the aggregate initialization to both operands to ensure that any aggregate expressions within the operands are properly initialized.</p>
<p>The <link id="TFPBinaryOperation.InitAggregate">InitAggregate</link> method is called as part of
the aggregate processing cycle when the expression contains aggregate functions that need special handling.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBinaryOperation.UpdateAggregate">
<short>Update aggregate calculations for binary operation</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates aggregate calculations for both the left and right operands of the binary operation.
It delegates the aggregate updates to both operands to ensure that any aggregate expressions are properly maintained during the aggregation cycle.</p>
<p>The method is called repeatedly during aggregate processing to update the state of aggregate functions contained within the operands.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPBinaryOperation.HasAggregate">
<short>Check if binary operation contains aggregates</short>
<descr>
<p>The <var>HasAggregate</var> method checks whether either the left or right operand contains aggregate expressions.
It returns True if any of the operands has aggregate functionality, which indicates that special aggregate processing is required for this operation.</p>
<p>The method is used by the expression parser to identify operations that need aggregate handling and to ensure proper processing order for aggregate expressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBinaryOperation.HasAggregate.Result">
<short>Returns true if operation has aggregates</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBinaryOperation.Check">
<short>Validate the binary operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates the binary operation by checking both operands for correctness and ensuring that they are compatible for the specific operation.
It calls the Check method on both operands to perform recursive validation.</p>
<p>The validation process ensures that the operation can be safely executed and that all type requirements and constraints are met before evaluation begins.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPBinaryOperation.left">
<short>Left operand of the binary operation</short>
<descr>
<p>The <var>left</var> property provides access to the left operand of the binary operation.
The left operand is the first operand in the operation and is typically evaluated before the right operand in operations where evaluation order matters.</p>
<p>The property returns the <link id="TFPExprNode">TFPExprNode</link> that represents the left side of the binary operation, allowing access to its value and type information.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPBinaryOperation.Right">
<short>Right operand of the binary operation</short>
<descr>
<p>The <var>Right</var> property provides access to the right operand of the binary operation.
The right operand is the second operand in the operation and is typically evaluated after
the left operand in operations where evaluation order matters.</p>
<p>The property returns the <link id="TFPExprNode">TFPExprNode</link> that
represents the right side of the binary operation, allowing access to its value and type information.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFPBinaryOperationClass">
<short>Class reference type for TFPBinaryOperation</short>
<descr>
<p>This is a class reference type (metaclass) for <link id="TFPBinaryOperation">TFPBinaryOperation</link>.
It allows for dynamic creation of binary operation instances and enables polymorphic handling of different binary operation types during expression parsing.</p>
<p>Class reference types are essential in factory patterns where the specific binary operation class to be instantiated
is determined at runtime based on the operator token encountered in the expression (such as +, -, *, /, etc.).</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPBooleanOperation">
<short>Internally used class for boolean operations in expressions</short>
<descr>
<p><var>TFPBooleanOperation</var> is the base class for binary operations that work with boolean operands and produce boolean results.
It extends <link id="TFPBinaryOperation">TFPBinaryOperation</link> to provide boolean-specific functionality and validation.</p>
<p>The class ensures that both operands are boolean expressions and provides the framework for logical operations such as AND, OR, and XOR.
It handles type validation to ensure that only boolean values participate in logical operations.</p>
<p>Derived classes implement specific boolean operations while leveraging the common boolean operation infrastructure for validation and type management.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBooleanOperation.Check">
<short>Validate the boolean operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that both operands of the boolean operation are boolean expressions.
It ensures type compatibility and prevents type mismatches that would result in runtime errors during evaluation.</p>
<p>The validation process checks that both the left and right operands produce boolean results, raising appropriate errors if non-boolean operands are found.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPBooleanOperation.NodeType">
<short>Get the result type for boolean operations</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtBoolean</link> to indicate that boolean operations always produce boolean results.
This type information is used by the expression parser for type checking and result handling.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBooleanOperation.NodeType.Result">
<short>Returns boolean as the result type</short>
</element>

<!-- class Visibility: default -->
<element name="TFPBinaryAndOperation">
<short>Internally used class for binary AND logical operation</short>
<descr>
<p>The <var>TFPBinaryAndOperation</var> class implements the logical AND operation between two boolean operands.
It extends <link id="TFPBooleanOperation">TFPBooleanOperation</link> to provide AND-specific functionality that evaluates to True only when both operands are True.</p>
<p>The operation uses short-circuit evaluation, meaning that if the left operand is False, the right operand is not evaluated since the result is already determined to be False.
This optimization improves performance and can prevent evaluation of potentially expensive or problematic right operands.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPBinaryAndOperation.AsString">
<short>Get string representation of AND operation</short>
<descr>
<p>The <link id="TFPBinaryAndOperation.AsString">AsString</link> method returns a string representation of the AND operation,
typically showing both operands connected by the "and" keyword for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBinaryAndOperation.AsString.Result">
<short>Returns string representation of the AND</short>
</element>

<!-- class Visibility: default -->
<element name="TFPBinaryOrOperation">
<short>Internally used class for binary OR logical operation</short>
<descr>
<p>The <var>TFPBinaryOrOperation</var> class implements the logical OR operation between two boolean operands.
It extends <link id="TFPBooleanOperation">TFPBooleanOperation</link> to provide OR-specific functionality that evaluates to True when at least one operand is True.</p>
<p>The operation uses short-circuit evaluation, meaning that if the left operand is True,
the right operand is not evaluated since the result is already determined to be True.
This optimization improves performance in expressions where the first condition is likely to be true.</p>
<p>The result is always a boolean value, following standard logical OR truth table rules where only False OR False produces False.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPBinaryOrOperation.AsString">
<short>Get string representation of OR operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the OR operation,
 typically showing both operands connected by the "or" keyword for debugging and display purposes.</p>
<p>The string format aids in visualizing the logical structure of expressions and provides valuable information for debugging complex boolean logic.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBinaryOrOperation.AsString.Result">
<short>Returns string representation of the OR</short>
</element>

<!-- class Visibility: default -->
<element name="TFPBinaryXOrOperation">
<short>Internally used class for binary XOR logical operation</short>
<descr>
<p>The <var>TFPBinaryXOrOperation</var> class implements the logical XOR (exclusive OR) operation between two boolean operands.
It extends <link id="TFPBooleanOperation">TFPBooleanOperation</link> to provide XOR-specific functionality that evaluates to True when exactly one operand is True.</p>
<p>The XOR operation returns True only when the operands have different boolean values (True XOR False or False XOR True),
and returns False when both operands have the same value (True XOR True or False XOR False).</p>
<p>Unlike AND and OR operations, XOR requires evaluation of both operands since both values are needed to determine the result.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPBinaryXOrOperation.AsString">
<short>Get string representation of XOR operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the XOR operation,
typically showing both operands connected by the "xor" keyword for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBinaryXOrOperation.AsString.Result">
<short>Returns string representation of the XOR</short>
</element>

<!-- class Visibility: default -->
<element name="TFPBooleanResultOperation">
<short>Internally used class for operations that result in boolean values</short>
<descr>
<p>The <var>TFPBooleanResultOperation</var> class serves as the base class for binary operations that produce boolean results but may accept non-boolean operands.
It extends <link id="TFPBinaryOperation">TFPBinaryOperation</link> to provide the framework for comparison and relational operations.</p>
<p>Unlike <link id="TFPBooleanOperation">TFPBooleanOperation</link> which requires boolean operands, this class allows various operand types while ensuring the result is always boolean.
This makes it suitable for comparison operations like equality, less than, greater than, etc.</p>
<p>The class provides the infrastructure for operations that compare values of compatible types and return boolean results indicating the relationship between the operands.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBooleanResultOperation.Check">
<short>Validate the boolean result operation</short>
<descr>
<p>The <link id="TFPBooleanResultOperation.Check">Check</link> method validates that the operands are compatible for the specific boolean result operation.
While the result will be boolean, the operands may be of various types depending on the specific operation (e.g., numeric types for comparison operations).</p>
<p>The validation ensures that the operands are type-compatible for the comparison or relational operation being performed.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPBooleanResultOperation.NodeType">
<short>Get the result type for boolean operations</short>
<descr>
<p>The <link id="TFPBooleanResultOperation.NodeType">NodeType</link> method returns <link id="TResultType">rtBoolean</link>
to indicate that operations derived from this class always produce boolean results, regardless of the input operand types.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPBooleanResultOperation.NodeType.Result">
<short>Returns boolean as the result type</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFPBooleanResultOperationClass">
<short>Class reference type for TFPBooleanResultOperation</short>
<descr>
<p>This is a class reference type (metaclass) for <link id="TFPBooleanResultOperation">TFPBooleanResultOperation</link>.
It allows for dynamic creation of boolean result operation instances and enables polymorphic handling of different boolean result operation types.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPEqualOperation">
<short>Internally used class for equality comparison operations</short>
<descr>
<p>The <var>TFPEqualOperation</var> class implements the equality comparison operation (=) between two operands of compatible types.
It extends <link id="TFPBooleanResultOperation">TFPBooleanResultOperation</link> to provide equality-specific comparison logic.</p>
<p>The operation compares two values and returns True if they are equal, False otherwise.
It handles different data types appropriately, using numeric equality for numbers, string comparison for strings, and boolean comparison for boolean values.</p>
<p>Type conversion is performed when necessary to compare values of different but compatible types (e.g., comparing an integer with a float).</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPEqualOperation.AsString">
<short>Get string representation of equality operation</short>
<descr>
<p>The <link id="TFPEqualOperation.AsString">AsString</link> method returns a string representation of the equality operation,
showing both operands connected by the "=" symbol for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPEqualOperation.AsString.Result">
<short>Returns string representation of the equality</short>
</element>

<!-- class Visibility: default -->
<element name="TFPUnequalOperation">
<short>Internally used class for inequality comparison operations</short>
<descr>
<p>The <var>TFPUnequalOperation</var> class implements the inequality comparison operation (&lt;&gt;) between two operands of compatible types.
It extends <link id="TFPBooleanResultOperation">TFPBooleanResultOperation</link> to provide inequality-specific comparison logic.</p>
<p>The operation compares two values and returns True if they are not equal, False if they are equal.
It handles different data types appropriately, using numeric comparison for numbers, string comparison for strings, and boolean comparison for boolean values.</p>
<p>Type conversion is performed when necessary to compare values of different but compatible types, ensuring that the inequality test works across different numeric types.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPUnequalOperation.AsString">
<short>Get string representation of inequality operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the inequality operation, showing both operands connected by the "&lt;&gt;" for debugging and display purposes.</p>
<p>The string format helps in understanding the structure of complex comparison expressions and provides useful information for debugging expression parsing and evaluation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPUnequalOperation.AsString.Result">
<short>Returns string representation of the inequality</short>
</element>

<!-- class Visibility: default -->
<element name="TFPOrderingOperation">
<short>Internally used class for ordering comparison operations</short>
<descr>
<p>The <var>TFPOrderingOperation</var> class is the base class for comparison operations that determine the ordering relationship between two values.
 It extends <link id="TFPBooleanResultOperation">TFPBooleanResultOperation</link> to provide the foundation for less-than, greater-than, and related comparison operations.</p>
<p>The class handles the common aspects of ordering comparisons such as type checking and ensuring that the operands can be meaningfully compared.
It provides the framework for operations that determine relative order rather than equality.</p>
<p>Derived classes implement specific ordering operations like &lt;, &gt;, &lt;=, and &gt;= while leveraging the common ordering infrastructure for validation and type management.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPOrderingOperation.Check">
<short>Validate the ordering operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that both operands of the ordering operation are compatible for comparison and can be meaningfully ordered.
It ensures that the operands are of types that support ordering relationships.</p>
<p>The validation process checks that both operands are of comparable types (such as numeric types, strings, or dates) and that the comparison operation can be safely performed.
It raises an exception if incompatible types are found.</p>
<p>The <var>Check</var> method extends the base validation from <link id="TFPBooleanResultOperation">TFPBooleanResultOperation</link> with ordering-specific type checking requirements.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPLessThanOperation">
<short>Internally used class for less-than comparison operations</short>
<descr>
<p>The <var>TFPLessThanOperation</var> class implements the less-than comparison operation (&lt;)
between two operands of compatible types. It extends <link id="TFPOrderingOperation">TFPOrderingOperation</link> to provide less-than-specific comparison logic.</p>
<p>The operation compares two values and returns True if the left operand is less than the right operand, False otherwise.
It handles different data types appropriately, using numeric comparison for numbers, lexicographic comparison for strings, and chronological comparison for date/time values.</p>
<p>Type conversion is performed when necessary to compare values of different but compatible types, ensuring proper ordering across numeric types.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPLessThanOperation.AsString">
<short>Get string representation of less-than operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the less-than operation,
showing both operands connected by the "&lt;" symbol for debugging and display purposes.</p>
<p>The string format helps in visualizing comparison expressions and provides valuable information for debugging expression parsing and evaluation logic.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPLessThanOperation.AsString.Result">
<short>Returns string representation of the less-than</short>
</element>

<!-- class Visibility: default -->
<element name="TFPGreaterThanOperation">
<short>Internally used class for greater-than comparison operations</short>
<descr>
<p>The <var>TFPGreaterThanOperation</var> class implements the greater-than comparison operation (&gt;)
between two operands of compatible types. It extends <link id="TFPOrderingOperation">TFPOrderingOperation</link> to provide greater-than-specific comparison logic.</p>
<p>The operation compares two values and returns True if the left operand is greater than the right operand, False otherwise.
It handles different data types appropriately, using numeric comparison for numbers, lexicographic comparison for strings, and chronological comparison for date/time values.</p>
<p>Type conversion is performed when necessary to compare values of different but compatible types, ensuring proper ordering across numeric types.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPGreaterThanOperation.AsString">
<short>Get string representation of greater-than operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the greater-than operation, showing both operands connected by the ">" symbol for debugging and display purposes.</p>
<p>The string format helps in visualizing comparison expressions and provides valuable information for debugging expression parsing and evaluation logic.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPGreaterThanOperation.AsString.Result">
<short>Returns string representation of the greater-than</short>
</element>

<!-- class Visibility: default -->
<element name="TFPLessThanEqualOperation">
<short>Internally used class for less-than-or-equal comparison operations</short>
<descr>
<p>The <var>TFPLessThanEqualOperation</var> class implements the less-than-or-equal comparison operation (&lt;=) between two operands of compatible types.
It extends <link id="TFPOrderingOperation">TFPOrderingOperation</link> to provide less-than-or-equal-specific comparison logic.</p>
<p>The operation compares two values and returns True if the left operand is less than or equal to the right operand, False otherwise.
It handles different data types appropriately, using numeric comparison for numbers, lexicographic comparison for strings, and chronological comparison for date/time values.</p>
<p>This operation combines both equality and less-than testing, returning True when either condition is satisfied.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPLessThanEqualOperation.AsString">
<short>Get string representation of less-than-equal operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the less-than-or-equal operation,
showing both operands connected by the "&lt;=" symbol for debugging and display purposes.</p>
<p>The string format helps in visualizing comparison expressions and provides clear indication of the combined less-than and equality test being performed.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPLessThanEqualOperation.AsString.Result">
<short>Returns string representation of the less-than-equal</short>
</element>

<!-- class Visibility: default -->
<element name="TFPGreaterThanEqualOperation">
<short>Internally used class for greater-than-or-equal comparison operations</short>
<descr>
<p>The <var>TFPGreaterThanEqualOperation</var> class implements the greater-than-or-equal comparison operation (&gt;=)
between two operands of compatible types. It extends <link id="TFPOrderingOperation">TFPOrderingOperation</link> to provide greater-than-or-equal-specific comparison logic.</p>
<p>The operation compares two values and returns True if the left operand is greater than or equal to the right operand, False otherwise.
It handles different data types appropriately, using numeric comparison for numbers, lexicographic comparison for strings, and chronological comparison for date/time values.</p>
<p>This operation combines both equality and greater-than testing, returning True when either condition is satisfied.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPGreaterThanEqualOperation.AsString">
<short>Get string representation of greater-than-equal operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the greater-than-or-equal operation,
showing both operands connected by the "&gt;=" symbol for debugging and display purposes.</p>
<p>The string format helps in visualizing comparison expressions and provides clear indication of the combined greater-than and equality test being performed.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPGreaterThanEqualOperation.AsString.Result">
<short>Returns string representation of the greater-than-equal</short>
</element>

<!-- class Visibility: default -->
<element name="TIfOperation">
<short>Internally used class for conditional if-then-else operations</short>
<descr>
<p>The <var>TIfOperation</var> class implements conditional if-then-else operations in expressions, allowing for branching logic based on boolean conditions.
It extends the expression framework to provide conditional evaluation similar to the ternary operator in many programming languages.</p>
<p>The operation evaluates a boolean condition and returns one of two expressions based on the result:
the "then" expression if the condition is True, or the "else" expression if the condition is False.
This enables complex conditional logic within expressions.</p>
<p>The class manages three operands: the condition (which must evaluate to boolean),
the "then" expression (evaluated when condition is True), and the "else" expression (evaluated when condition is False).
Only one of the result expressions is evaluated, providing efficient conditional processing.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TIfOperation.Check">
<short>Validate the conditional operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates the conditional operation by checking that the condition
expression evaluates to a boolean type and that the then-branch and else-branch expressions are present and valid.</p>
<p>The validation ensures that the condition is a boolean expression and that both branch expressions are compatible
for the intended result type. It also validates all three operand expressions recursively.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TIfOperation.InitAggregate">
<short>Initialize aggregate processing for if operation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes aggregate processing for the condition,
then-branch, and else-branch expressions of the conditional operation.
It delegates the aggregate initialization to all three operands.</p>
<p>The <link id="TIfOperation.InitAggregate">InitAggregate</link> method is called as part of the aggregate
 processing cycle when any of the conditional branches contain aggregate functions that need special handling.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TIfOperation.UpdateAggregate">
<short>Update aggregate calculations for if operation</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates aggregate calculations for the condition, then-branch, and
else-branch expressions of the conditional operation. It delegates the aggregate updates to all three operands.</p>
<p>The method is called repeatedly during aggregate processing to update the state of any aggregate functions contained within the conditional expressions.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TIfOperation.HasAggregate">
<short>Check if conditional operation contains aggregates</short>
<descr>
<p>The <var>HasAggregate</var> method checks whether any of the three operands (condition, then-branch, or else-branch) contain aggregate expressions. I
t returns True if any operand has aggregate functionality.</p>
<p>The method is used by the expression parser to identify conditional operations that need aggregate handling
and to ensure proper processing order for expressions with aggregate functions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIfOperation.HasAggregate.Result">
<short>Returns true if operation has aggregates</short>
</element>

<!-- function Visibility: public -->
<element name="TIfOperation.NodeType">
<short>Get the result type for conditional operation</short>
<descr>
<p>The <var>NodeType</var> method determines and returns the result type for the conditional operation based on the types of the then-branch and else-branch expressions.
The result type is typically the common type that both branches can be converted to.</p>
<p>The method analyzes both branch expressions to determine a compatible result type that can accommodate values from either branch,
ensuring type safety in conditional expressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIfOperation.NodeType.Result">
<short>Returns the result type of the conditional</short>
</element>

<!-- constructor Visibility: public -->
<element name="TIfOperation.Create">
<short>Create conditional operation with condition and branches</short>
<descr>
<p>The <var>Create</var> constructor creates a new conditional operation with the specified condition expression,
then-branch expression, and else-branch expression. It takes ownership of all three operand nodes.</p>
<p>The constructor properly initializes the conditional operation structure and establishes the relationship between the operation and its three operands
(condition, then-branch, and else-branch), ensuring proper resource management.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TIfOperation.Create.ACondition">
<short>The condition expression to evaluate</short>
</element>

<!-- argument Visibility: default -->
<element name="TIfOperation.Create.ALeft">
<short>The then-branch expression</short>
</element>

<!-- argument Visibility: default -->
<element name="TIfOperation.Create.ARight">
<short>The else-branch expression</short>
</element>

<!-- destructor Visibility: public -->
<element name="TIfOperation.destroy">
<short>Destroy conditional operation and free resources</short>
<descr>
<p><var>Destroy</var>  properly cleans up the conditional operation by freeing the condition expression,
then-branch expression, and else-branch expression, along with any other resources used by the operation.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TIfOperation.AsString">
<short>Get string representation of conditional operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the conditional operation, typically showing the condition,
then-branch, and else-branch expressions in a readable format such as "if condition then expr1 else expr2" for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIfOperation.AsString.Result">
<short>Returns string representation of the conditional</short>
</element>

<!-- property Visibility: public -->
<element name="TIfOperation.Condition">
<short>The condition expression of the if operation</short>
<descr>
<p>The <var>Condition</var> property provides access to the boolean condition expression that determines
which branch of the conditional operation will be evaluated.
The condition must evaluate to a boolean result.</p>
<p>The condition is evaluated first, and based on its boolean result, either the then-branch or else-branch expression
is evaluated to provide the final result of the conditional operation.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TCaseOperation">
<short>Internally used class for case-when conditional operations</short>
<descr>
<p>The <var>TCaseOperation</var> class implements case-when conditional operations in expressions, providing multi-way branching logic based on value matching.
It allows for testing a single expression against multiple possible values and executing different branches based on which value matches.</p>
<p>The case operation evaluates a test expression and compares it against a series of when-value pairs, executing the associated expression for the first matching value.
If no values match, an optional else expression is evaluated.</p>
<p>The <var>TCaseOperation</var> class enables complex multi-conditional logic within expressions,
similar to CASE statements in SQL or switch statements in programming languages,
providing an alternative to nested if-then-else constructs.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TCaseOperation.Check">
<short>Validate the case operation for correctness</short>
<descr>
<p>The <link id="TCaseOperation.Check">Check</link> method validates the case operation to ensure that all components are properly configured and type-compatible.
It checks that the condition expression and all case branches have compatible types and that the operation can be safely evaluated.</p>
<p>The validation process includes verifying that the condition can be evaluated to determine which case branch should be executed,
 and that all possible execution paths result in compatible data types.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCaseOperation.InitAggregate">
<short>Initialize aggregate processing for case operation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes aggregate processing for the case operation node.
It prepares the case operation for aggregate calculations by initializing any aggregate functions used within the case branches.</p>
<p>The initialization process ensures that all child nodes that contain aggregate functions are properly set up for aggregate processing,
 allowing the case operation to participate correctly in aggregate expression evaluation.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCaseOperation.UpdateAggregate">
<short>Update aggregate calculations for case operation</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates aggregate calculations for the case operation node during aggregate expression evaluation.
It ensures that aggregate functions within the selected case branch are properly updated with current data values.</p>
<p>The update process involves evaluating the condition to determine the active case branch,
then updating any aggregate functions contained within that branch,
allowing proper aggregate calculation in conditional expressions.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCaseOperation.HasAggregate">
<short>Check if case operation contains aggregates</short>
<descr>
<p>The <link id="TCaseOperation.HasAggregate">HasAggregate</link> method determines whether the case operation contains any aggregate
functions within its condition or case branches. It returns true if any part of the case operation uses aggregate functions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCaseOperation.HasAggregate.Result">
<short>Returns true if operation has aggregates</short>
</element>

<!-- function Visibility: public -->
<element name="TCaseOperation.NodeType">
<short>Get the result type for case operation</short>
<descr>
<p>The <var>NodeType</var> method returns the data type that will be produced by the case operation.
The result type is determined by analyzing all possible case branches to ensure they are compatible and determining the common result type.</p>
<p>The case operation ensures that all branches produce results of the same type,
or automatically performs appropriate type conversions to achieve a common result type for the entire operation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCaseOperation.NodeType.Result">
<short>Returns the result type of the case</short>
</element>

<!-- constructor Visibility: public -->
<element name="TCaseOperation.Create">
<short>Create case operation with arguments</short>
<descr>
<p>The <var>Create</var> constructor creates a new case operation node with the provided arguments array.
The arguments typically include the condition expression and alternating case values and result expressions.</p>
<p>The case operation follows a pattern commonly found in SQL:</p>
<code>
CASE condition
  WHEN value1 THEN result1
  WHEN value2 THEN result2
ELSE
  default_result
END.
</code>
<p>The arguments array contains these components in the appropriate order for evaluation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCaseOperation.Create.Args">
<short>The arguments array for case operation</short>
</element>

<!-- destructor Visibility: public -->
<element name="TCaseOperation.destroy">
<short>Destroy case operation and free resources</short>
<descr>
<p><var>Destroy</var> cleans up the case operation and frees all associated resources.
It properly deallocates all child expression nodes including the condition and all case branches.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCaseOperation.AsString">
<short>Get string representation of case operation</short>
<descr>
<p>The <link id="TCaseOperation.AsString">AsString</link> method returns a human-readable string representation of the case operation,
showing the condition and all case branches in a format that can be used for debugging or display purposes.</p>
<p>The string format typically follows the pattern: </p>
<code>
CASE condition
  WHEN value1 THEN result1
  WHEN value2 THEN result2
ELSE
  default_result
END.
</code>
<p>making the case logic clearly visible for analysis and debugging.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCaseOperation.AsString.Result">
<short>Returns string representation of the case</short>
</element>

<!-- property Visibility: public -->
<element name="TCaseOperation.Condition">
<short>The condition expression of the case operation</short>
<descr>
<p>The <link id="TCaseOperation.Condition">Condition</link> property provides access to the condition expression
that determines which case branch will be executed.
The condition is evaluated and its result is compared against the WHEN values to select the appropriate branch.</p>
<p>The condition expression can be any valid expression that produces a value compatible with the WHEN clause values,
allowing flexible case-based conditional logic.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TMathOperation">
<short>Internally used class for mathematical operations in expressions</short>
<descr>
<p>The <link id="TMathOperation">TMathOperation</link> class serves as a base class for mathematical operations that can be performed on numeric operands.
It provides common functionality for arithmetic operations including type checking and result type determination.</p>
<p>Mathematical operations support various numeric types including integers, floats, and currency values,
with automatic type promotion to ensure precision is maintained in calculations.
The class ensures that operands are compatible for mathematical operations.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMathOperation.Check">
<short>Validate the mathematical operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that the mathematical operation can be performed safely on the provided operands.
It checks that both operands are of compatible numeric types and that the operation is mathematically valid.</p>
<p>The validation includes type compatibility checking and ensures that operations like division by zero or other
mathematically undefined operations are detected before evaluation attempts.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TMathOperation.NodeType">
<short>Get the result type for mathematical operations</short>
<descr>
<p>The <var>NodeType</var> method determines the data type that will be produced by the mathematical operation.
The result type is calculated based on the types of the operands and follows standard type promotion rules.</p>
<p>For example, operations between integers produce integer results, but operations involving floats promote the
result to float type to maintain precision. Currency operations maintain currency type where appropriate.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TMathOperation.NodeType.Result">
<short>Returns the result type of the math operation</short>
</element>

<!-- class Visibility: default -->
<element name="TFPAddOperation">
<short>Internally used class for addition operations</short>
<descr>
<p>The <var>TFPAddOperation</var> class implements the addition operation between two numeric operands.
It extends the binary operation framework to provide addition-specific functionality for integers, floats, and currency values.</p>
<p>The operation handles type conversion automatically when operands have different numeric types,
promoting the result to the more precise type as needed. For example, adding an integer to a float produces a float result.</p>
<p>The addition operation also supports string concatenation when both operands are strings,
providing unified handling for both numeric addition and string concatenation under the same operator.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPAddOperation.AsString">
<short>Get string representation of addition operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the addition operation, showing both operands connected by the "+" symbol for debugging and display purposes.</p>
<p>The string representation helps in understanding the structure of mathematical expressions and provides useful debugging information for complex arithmetic operations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPAddOperation.AsString.Result">
<short>Returns string representation of the addition</short>
</element>

<!-- class Visibility: default -->
<element name="TFPSubtractOperation">
<short>Internally used class for subtraction operations</short>
<descr>
<p>The <var>TFPSubtractOperation</var> class implements the subtraction operation between two numeric operands.
It extends the binary operation framework to provide subtraction-specific functionality for integers, floats, and currency values.</p>
<p>The operation handles type conversion automatically when operands have different numeric types, promoting the result to the more precise type as needed.
The result type follows standard numeric promotion rules.</p>
<p>The subtraction operation computes the difference between the left operand (minuend) and the right operand (subtrahend), returning left - right.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPSubtractOperation.Check">
<short>Validate the subtraction operation for correctness</short>
<descr>
<p>The <link id="TFPSubtractOperation.Check">Check</link> method validates that both operands are numeric types suitable for subtraction.
It ensures type compatibility and prevents attempts to subtract incompatible types.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPSubtractOperation.GetNodeValue">
<short>Calculate the result of subtraction operation</short>
<descr>
<p>The <link id="TFPSubtractOperation.GetNodeValue">GetNodeValue</link> method performs the actual subtraction
by evaluating both operands and computing their difference.
It handles type conversion and returns the result in the appropriate numeric format.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPSubtractOperation.GetNodeValue.Result">
<short>Returns the result of the subtraction</short>
</element>

<!-- function Visibility: public -->
<element name="TFPSubtractOperation.AsString">
<short>Get string representation of subtraction operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the subtraction operation,
showing both operands connected by the "-" symbol for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPSubtractOperation.AsString.Result">
<short>Returns string representation of the subtraction</short>
</element>

<!-- class Visibility: default -->
<element name="TFPMultiplyOperation">
<short>Internally used class for multiplication operations</short>
<descr>
<p>The <var>TFPMultiplyOperation</var> class implements multiplication operation between two numeric operands,
handling type conversion and providing multiplication-specific functionality for integers, floats, and currency values.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPMultiplyOperation.check">
<short>Validate the multiplication operation for correctness</short>
<descr>
<p>The <var>check</var> method validates that both operands are numeric types suitable for multiplication, ensuring type compatibility.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPMultiplyOperation.AsString">
<short>Get string representation of multiplication operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation showing both operands connected by the "*" symbol for debugging purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPMultiplyOperation.AsString.Result">
<short>Returns string representation of the multiplication</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPMultiplyOperation.GetNodeValue">
<short>Calculate the result of multiplication operation</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the actual multiplication by evaluating both operands and computing their product with appropriate type handling.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPMultiplyOperation.GetNodeValue.Result">
<short>Returns the result of the multiplication</short>
</element>

<!-- class Visibility: default -->
<element name="TFPDivideOperation">
<short>Internally used class for division operations</short>
<descr>
<p>The <var>TFPDivideOperation</var> class implements division operations between two numeric operands,
handling division by zero checks and type conversion for integers, floats, and currency values.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPDivideOperation.Check">
<short>Validate the division operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that both operands are numeric types and checks for division by zero conditions to prevent runtime errors.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPDivideOperation.AsString">
<short>Get string representation of division operation</short>
<descr>
<p>Returns string representation showing operands connected by "/" symbol for debugging purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPDivideOperation.AsString.Result">
<short>Returns string representation of the division</short>
</element>

<!-- function Visibility: public -->
<element name="TFPDivideOperation.NodeType">
<short>Get the result type for division operations</short>
<descr>
<p>Returns the appropriate result type for division operations, typically promoting to floating-point for precise division results.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPDivideOperation.NodeType.Result">
<short>Returns the result type of the division</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPDivideOperation.GetNodeValue">
<short>Calculate the result of division operation</short>
<descr>
<p>Performs the division calculation after checking for division by zero, returning the quotient with appropriate type handling.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPDivideOperation.GetNodeValue.Result">
<short>Returns the result of the division</short>
</element>

<!-- class Visibility: default -->
<element name="TFPModuloOperation">
<short>Internally used class for modulo operations</short>
<descr>
<p>The <var>TFPModuloOperation</var> class implements modulo operations that return the remainder after division between two integer operands.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPModuloOperation.Check">
<short>Validate the modulo operation for correctness</short>
<descr>
<p>Validates that both operands are integer types and checks for modulo by zero conditions.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPModuloOperation.AsString">
<short>Get string representation of modulo operation</short>
<descr>
<p>Returns string representation showing operands connected by "mod" keyword for debugging purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPModuloOperation.AsString.Result">
<short>Returns string representation of the modulo</short>
</element>

<!-- function Visibility: public -->
<element name="TFPModuloOperation.NodeType">
<short>Get the result type for modulo operations</short>
<descr>
<p>Returns integer type as modulo operations work with and return integer values.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPModuloOperation.NodeType.Result">
<short>Returns the result type of the modulo</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPModuloOperation.GetNodeValue">
<short>Calculate the result of modulo operation</short>
<descr>
<p>Performs the modulo calculation returning the remainder after integer division.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPModuloOperation.GetNodeValue.Result">
<short>Returns the result of the modulo</short>
</element>

<!-- class Visibility: default -->
<element name="TFPPowerOperation">
<short>Internally used class for power/exponentiation operations</short>
<descr>
<p>The <var>TFPPowerOperation</var> class implements the power (exponentiation) operation for raising one numeric value to the power of another.
It extends the mathematical operation framework to provide exponentiation functionality with proper type handling.</p>
<p>The power operation supports integer, float, and currency operands, automatically promoting the result type to ensure sufficient precision.
The operation follows standard mathematical rules for exponentiation including handling of negative bases and fractional exponents.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPPowerOperation.Check">
<short>Validate the power operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that the power operation can be performed safely on the provided base and exponent operands.
It checks for mathematically invalid operations such as negative bases with fractional exponents.</p>
<p>The validation also ensures that both operands are of compatible numeric types and that the operation will not result in overflow or underflow conditions that could produce invalid results.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPPowerOperation.AsString">
<short>Get string representation of power operation</short>
<descr>
<p>The <link id="TFPPowerOperation.AsString">AsString</link> method returns a human-readable string representation of the power operation,
typically in the format 'base ^ exponent' or 'base ** exponent', showing both operands and the power operator.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPPowerOperation.AsString.Result">
<short>Returns string representation of the power</short>
</element>

<!-- function Visibility: public -->
<element name="TFPPowerOperation.NodeType">
<short>Get the result type for power operations</short>
<descr>
<p>The <var>NodeType</var> method determines the data type that will be produced by the power operation.
Power operations typically promote the result to a floating-point type to handle fractional results and maintain mathematical precision.</p>
<p>The result type is usually float regardless of the input operand types, since exponentiation often produces non-integer results even when both operands are integers.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPPowerOperation.NodeType.Result">
<short>Returns the result type of the power</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPPowerOperation.GetNodeValue">
<short>Calculate the result of power operation</short>
<descr>
<p>The <link id="TFPPowerOperation.GetNodeValue">GetNodeValue</link> method evaluates the power operation by
raising the left operand to the power of the right operand and returns the result.
It handles both integer and floating-point base values with numeric exponents.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPPowerOperation.GetNodeValue.Result">
<short>Returns the result of the power</short>
</element>

<!-- class Visibility: default -->
<element name="TFPUnaryOperator">
<short>Internally used class for unary operations with single operand</short>
<descr>
<p><var>TFPUnaryOperator</var> is the base class for all unary operations in the expression parser.
Unary operations take a single operand and perform some operation to produce a result.
It extends <link id="TFPExprNode">TFPExprNode</link> to provide the foundation for all single-operand operations.</p>
<p>The class manages the operand node and provides common functionality such as aggregate handling, validation,
and resource management that is shared by all unary operations.</p>
<p>Derived classes implement specific operations such as logical NOT, numeric negation, and type conversions.
Each operation defines its own evaluation logic while leveraging the common unary operation infrastructure.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPUnaryOperator.Create">
<short>Create unary operator with operand</short>
<descr>
<p>The <link id="TFPUnaryOperator">TFPUnaryOperator</link> constructor creates a new unary operation with the specified operand. It takes ownership of the operand node and manages its lifecycle as part of the unary operation.</p>
<p>The constructor properly initializes the unary operation structure and establishes the relationship between the operation and its operand, ensuring that the operand is properly managed during the operation's lifetime.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPUnaryOperator.Create.AOperand">
<short>The operand expression for the unary operator</short>
</element>

<!-- destructor Visibility: public -->
<element name="TFPUnaryOperator.Destroy">
<short>Destroy unary operator and free resources</short>
<descr>
<p>This destructor properly cleans up the unary operation by freeing the operand node and any other resources used by the operation.</p>
<p>The destructor ensures that all memory allocated for the operand is properly released, preventing memory leaks in complex expression trees.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPUnaryOperator.InitAggregate">
<short>Initialize aggregate processing for unary operator</short>
<descr>
<p>The <var>InitAggregate</var> method initializes aggregate processing for the operand of the unary operation.
It delegates the aggregate initialization to the operand to ensure that any aggregate expressions within the operand are properly initialized.</p>
<p>The <var>InitAggregate</var> method is called as part of the aggregate processing cycle when the expression contains aggregate functions that need special handling.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPUnaryOperator.UpdateAggregate">
<short>Update aggregate calculations for unary operator</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates aggregate calculations for the operand of the unary operation.
It delegates the aggregate updates to the operand to ensure that any aggregate expressions are properly maintained during the aggregation cycle.</p>
<p>The method is called repeatedly during aggregate processing to update the state of aggregate functions contained within the operand.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPUnaryOperator.HasAggregate">
<short>Check if unary operator contains aggregates</short>
<descr>
<p>The <var>HasAggregate</var> method checks whether the operand contains aggregate expressions.
   It returns True if the operand has aggregate functionality, which indicates that special aggregate processing is required for this operation.</p>
<p>The method is used by the expression parser to identify operations that need aggregate handling and to ensure proper processing order for aggregate expressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPUnaryOperator.HasAggregate.Result">
<short>Returns true if operator has aggregates</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPUnaryOperator.Check">
<short>Validate the unary operator for correctness</short>
<descr>
<p>The <var>Check</var> method validates the unary operation by
checking the operand for correctness and ensuring that it is compatible with the specific operation.
It calls the <var>Check</var> method on the operand to perform recursive validation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPUnaryOperator.Operand">
<short>The operand expression of the unary operator</short>
<descr>
<p>The <link id="TFPUnaryOperator.Operand">Operand</link> property provides access to the operand of the unary operation.
The operand is the single expression node that the unary operation acts upon to produce its result.</p>
<p>The property returns the <link id="TFPExprNode">TFPExprNode</link> that represents the operand,
allowing access to its value and type information for evaluation purposes.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPConvertNode">
<short>Internally used class for type conversion operations</short>
<descr>
<p><var>TFPConvertNode</var> is the base class for all type conversion operations in the expression parser.
It provides the fundamental infrastructure for converting values between different data types during expression evaluation.</p>
<p>The class extends <link id="TFPExprNode">TFPExprNode</link> to provide conversion-specific functionality
that enables automatic type coercion and explicit type casting operations within expressions.</p>
<p>Derived classes implement specific conversion logic for different source and target type combinations,
 ensuring type safety and proper value transformation during expression evaluation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="TFPConvertNode.AsString">
<short>Get string representation of conversion operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the conversion operation,
typically showing the source expression and the target type for debugging and display purposes.</p>
<p>The string representation helps in understanding the structure of complex expressions that include multiple type conversions
and provides useful information for debugging expression parsing issues.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPConvertNode.AsString.Result">
<short>Returns string representation of the conversion</short>
</element>

<!-- class Visibility: default -->
<element name="TFPNotNode">
<short>Internally used class for logical NOT operations</short>
<descr>
<p>The <var>TFPNotNode</var> class implements the logical NOT operation that inverts a boolean value.
It extends <link id="TFPUnaryOperator">TFPUnaryOperator</link> to provide NOT-specific functionality that converts True to False and False to True.</p>
<p>The NOT operation requires that its operand evaluates to a boolean value.
It performs the logical inversion of the boolean result, providing the fundamental logical negation operation for boolean expressions.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPNotNode.Check">
<short>Validate the NOT operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that the operand of the NOT operation is a boolean expression.
It ensures type compatibility and prevents type mismatches that would result in runtime errors during evaluation.</p>
<p>The validation process checks that the operand produces a boolean result, raising appropriate errors if non-boolean operands are found.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPNotNode.NodeType">
<short>Get the result type for NOT operations</short>
<descr>
<p>The <link id="TFPNotNode.NodeType">NodeType</link> method returns <link id="TResultType">rtBoolean</link> to indicate that NOT operations always produce boolean results.
This type information is used by the expression parser for type checking and result handling.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPNotNode.NodeType.Result">
<short>Returns boolean as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPNotNode.GetNodeValue">
<short>Calculate the result of NOT operation</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the logical NOT operation by evaluating the operand and inverting its boolean result.
It returns True if the operand is False, and False if the operand is True.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPNotNode.GetNodeValue.Result">
<short>Returns the result of the NOT</short>
</element>

<!-- function Visibility: public -->
<element name="TFPNotNode.AsString">
<short>Get string representation of NOT operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the NOT operation,
typically showing the operand prefixed with the "not" keyword for debugging and display purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPNotNode.AsString.Result">
<short>Returns string representation of the NOT</short>
</element>

<!-- class Visibility: default -->
<element name="TIntConvertNode">
<short>Internally used class for integer conversion operations</short>
<descr>
<p>The <var>TIntConvertNode</var> class handles conversion operations that produce integer results from various source data types.
It extends <link id="TFPConvertNode">TFPConvertNode</link> to provide integer-specific conversion functionality.</p>
<p>The class is used when expressions require values to be converted to integer representation,
such as when performing integer arithmetic operations or when explicit integer casting is needed.</p>
<p>The conversion handles different source types appropriately, applying truncation, rounding,
or other integer conversion rules based on the source data type.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TIntConvertNode.Check">
<short>Validate the integer conversion for correctness</short>
<descr>
<p>The <var>Check</var> method validates that the conversion operation can be safely performed and that the source value can be properly converted to an integer.
It checks for potential overflow conditions and invalid source data types.</p>
<p>The validation helps prevent runtime errors during expression evaluation by ensuring that all type conversions are valid before the actual conversion is attempted.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TIntToFloatNode">
<short>Internally used class for converting integer to float</short>
<descr>
<p>The <var>TIntToFloatNode</var> conversion node class handles the automatic conversion of integer values to floating-point values in expressions.
It extends the base conversion functionality to provide integer-to-float specific conversion logic.</p>
<p>The class is used internally by the expression parser when type coercion is needed to make integer values compatible with operations that require floating-point operands.
The conversion preserves the numeric value while changing the data type representation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TIntToFloatNode.NodeType">
<short>Get the result type for integer to float conversion</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtFloat</link> to indicate that this conversion node produces floating-point results.
It overrides the base class method to provide type-specific result type information.</p>
<p>The method is used by the expression parser to determine the result type of expressions that include this conversion node,
enabling proper type checking and result handling.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIntToFloatNode.NodeType.Result">
<short>Returns float as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TIntToFloatNode.GetNodeValue">
<short>Internally used convert integer value to float</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the actual conversion of an integer value to a floating-point value.
It retrieves the integer value from the source node and converts it to the equivalent floating-point representation.</p>
<p>The conversion maintains the numeric value while changing the internal representation to <link id="TExprFloat">TExprFloat</link> format.
The method ensures that the conversion is performed safely and accurately.</p>
<p>The result is returned in a <link id="TFPExpressionResult">TFPExpressionResult</link> structure with the result type set to
rtFloat and the converted value stored in the appropriate field.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TIntToFloatNode.GetNodeValue.Result">
<short>Returns the converted float value</short>
</element>

<!-- class Visibility: default -->
<element name="TIntToCurrencyNode">
<short>Internally used class for converting integer to currency</short>
<descr>
<p>This conversion node class handles the automatic conversion of integer values to currency values in expressions.
It extends the base conversion functionality to provide integer-to-currency specific conversion logic.</p>
<p>The class is used internally by the expression parser when type coercion is needed to make integer values compatible with currency operations.
The conversion treats the integer as a currency amount with appropriate decimal precision.</p>
<p>This conversion is useful in financial calculations where integer values need to be combined with currency values while maintaining proper decimal precision and formatting.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TIntToCurrencyNode.NodeType">
<short>Get the result type for integer to currency conversion</short>
<descr>
<p>The <link id="TIntToCurrencyNode.NodeType">NodeType</link> method returns <link id="TResultType">rtCurrency</link> to indicate that this conversion node produces currency results.
It overrides the base class method to provide type-specific result type information.</p>
<p>The method enables the expression parser to properly identify currency operations and apply appropriate formatting, precision,
and arithmetic rules for currency calculations.</p>
<p>This type information is crucial for maintaining proper currency handling throughout complex expressions involving mixed numeric types.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIntToCurrencyNode.NodeType.Result">
<short>Returns currency as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TIntToCurrencyNode.GetNodeValue">
<short>Convert integer value to currency</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the actual conversion of an integer value to a currency value. It retrieves the integer value from the source node and converts it to the equivalent currency representation.</p>
<p>The conversion maintains the numeric value while applying currency-specific precision and formatting rules. The integer is treated as a whole currency unit (e.g., dollars, euros) with appropriate decimal handling.</p>
<p>The result is returned in a <link id="TFPExpressionResult">TFPExpressionResult</link> structure with the result type set to rtCurrency and the converted value stored in the currency field.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TIntToCurrencyNode.GetNodeValue.Result">
<short>Returns the converted currency value</short>
</element>

<!-- class Visibility: default -->
<element name="TIntToDateTimeNode">
<short>Internally used class for converting integer to datetime</short>
<descr>
<p>The <var>TIntToDateTimeNode</var> conversion node class handles the conversion of integer values to date/time values in expressions.
It extends the base conversion functionality to provide integer-to-datetime specific conversion logic.</p>
<p>The class interprets integer values as datetime representations,
typically using the standard Pascal datetime encoding where integers represent days since a base date.
This allows integration of numeric date calculations with datetime operations.</p>
<p>The conversion enables mathematical operations on dates by treating them as numeric values
while maintaining proper datetime semantics and formatting in the final results.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TIntToDateTimeNode.NodeType">
<short>Get the result type for integer to datetime conversion</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtDateTime</link> to indicate that this conversion node produces datetime results.
It provides type information for the expression parser to handle datetime operations correctly.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TIntToDateTimeNode.NodeType.Result">
<short>Returns datetime as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TIntToDateTimeNode.GetNodeValue">
<short>Internally used convert integer value to datetime</short>
<descr>
<p>The <var>GetNodeValue</var> method converts an integer value to a datetime value using the standard Pascal datetime encoding.
The integer is interpreted as the number of days since the base date (typically December 30, 1899).</p>

</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TIntToDateTimeNode.GetNodeValue.Result">
<short>Returns the converted datetime value</short>
</element>

<!-- class Visibility: default -->
<element name="TFloatToDateTimeNode">
<short>Internally used class for converting float to datetime</short>
<descr>
<p>The <var>TFloatToDateTimeNode</var> conversion node class handles the conversion of floating-point values to date/time values in expressions.
It supports the standard Pascal datetime representation where the integer part represents days and the fractional part represents time.</p>
<p>The class enables precise datetime calculations by allowing floating-point values to represent both date and time components in a single numeric value.
This is particularly useful for calculations involving time intervals and fractional days.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFloatToDateTimeNode.Check">
<short>Validate the float to datetime conversion</short>
<descr>
<p>The <var>Check</var> method validates that the floating-point value can be safely converted to a datetime value.
It checks for valid datetime ranges and ensures that the conversion will not result in invalid date/time values.</p>
<p>The validation helps prevent runtime errors that could occur when attempting to convert floating-point values
that are outside the valid datetime range or represent invalid date combinations.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFloatToDateTimeNode.NodeType">
<short>Get the result type for float to datetime conversion</short>
<descr>
<p>The <link id="TFloatToDateTimeNode.NodeType">NodeType</link> method returns <link id="TResultType">rtDateTime</link> to indicate that this conversion produces datetime results.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFloatToDateTimeNode.NodeType.Result">
<short>Returns datetime as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFloatToDateTimeNode.GetNodeValue">
<short>Convert float value to datetime</short>
<descr>
<p>The <link id="TFloatToDateTimeNode.GetNodeValue">GetNodeValue</link> method converts a floating-point value to a datetime value using the Pascal datetime encoding.
The integer part represents days since the base date, and the fractional part represents the time portion of the day.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFloatToDateTimeNode.GetNodeValue.Result">
<short>Returns the converted datetime value</short>
</element>

<!-- class Visibility: default -->
<element name="TFloatToCurrencyNode">
<short>Internally used class for converting float to currency</short>
<descr>
<p>The <var>TFloatToCurrencyNode</var> conversion node class handles the conversion of floating-point values to currency values in expressions.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFloatToCurrencyNode.Check">
<short>Validate the float to currency conversion</short>
<descr>
<p>The <var>Check</var> method validates that the floating-point value can be safely converted to a currency value,
checking for valid currency ranges and preventing overflow conditions that could result in incorrect currency amounts.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFloatToCurrencyNode.NodeType">
<short>Get the result type for float to currency conversion</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtCurrency</link> to indicate that this conversion produces currency results,
enabling proper currency handling in the expression parser.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFloatToCurrencyNode.NodeType.Result">
<short>Returns currency as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFloatToCurrencyNode.GetNodeValue">
<short>Convert float value to currency</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the actual conversion of a floating-point value to a currency value,
applying appropriate rounding and precision rules to ensure accurate currency representation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFloatToCurrencyNode.GetNodeValue.Result">
<short>Returns the converted currency value</short>
</element>

<!-- class Visibility: default -->
<element name="TCurrencyToDateTimeNode">
<short>Internally used class for converting currency to datetime</short>
<descr>
<p>The <var>TCurrencyToDateTimeNode</var> conversion node class handles the conversion of currency values to date/time values in expressions.
It treats the currency value as a numeric representation that can be converted to datetime format.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TCurrencyToDateTimeNode.Check">
<short>Validate the currency to datetime conversion</short>
<descr>
<p>The <var>Check</var> method validates that the currency value can be safely converted to a datetime value,
checking for valid datetime ranges and ensuring the conversion will produce a valid date/time result.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCurrencyToDateTimeNode.NodeType">
<short>Get the result type for currency to datetime conversion</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtDateTime</link>
 to indicate that this conversion produces datetime results, enabling proper datetime handling in subsequent operations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCurrencyToDateTimeNode.NodeType.Result">
<short>Returns datetime as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCurrencyToDateTimeNode.GetNodeValue">
<short>Convert currency value to datetime</short>
<descr>
<p>The <var>GetNodeValue</var> method converts a currency value to a datetime value
by treating the currency amount as a numeric datetime representation, applying the standard Pascal datetime encoding.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCurrencyToDateTimeNode.GetNodeValue.Result">
<short>Returns the converted datetime value</short>
</element>

<!-- class Visibility: default -->
<element name="TCurrencyToFloatNode">
<short>Internally used class for converting currency to float</short>
<descr>
<p>The <var>TCurrencyToFloatNod</var> conversion node class handles the conversion of currency values to floating-point values in expressions.
It preserves the numeric value while changing the data type to enable mathematical operations that require floating-point operands.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TCurrencyToFloatNode.Check">
<short>Validate the currency to float conversion</short>
<descr>
<p>The <var>Check</var> method validates that the currency value can be safely converted to a floating-point value,
ensuring that precision is maintained and no overflow conditions occur during the conversion process.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCurrencyToFloatNode.NodeType">
<short>Get the result type for currency to float conversion</short>
<descr>
<p>The <var>NodeType</var> method returns <link id="TResultType">rtFloat</link> to indicate that this conversion produces floating-point results,
enabling proper type handling for subsequent mathematical operations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TCurrencyToFloatNode.NodeType.Result">
<short>Returns float as the result type</short>
</element>

<!-- procedure Visibility: public -->
<element name="TCurrencyToFloatNode.GetNodeValue">
<short>Convert currency value to float</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the actual conversion of a currency value to a floating-point value,
maintaining the numeric precision while changing the data type representation for mathematical compatibility.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TCurrencyToFloatNode.GetNodeValue.Result">
<short>Returns the converted float value</short>
</element>

<!-- class Visibility: default -->
<element name="TFPNegateOperation">
<short>Internally used class for numeric negation operations</short>
<descr>
<p>The <var>TFPNegateOperation</var> class implements numeric negation operations that change the sign of numeric values.
It extends <link id="TFPUnaryOperator">TFPUnaryOperator</link> to provide negation-specific functionality for integers, floats, and currency values.</p>
<p>The negation operation converts positive values to negative and negative values to positive, essentially multiplying the operand by -1.</p>
<p>The operation requires that its operand be a numeric type (integer, float, or currency) and produces a result of the same or compatible numeric type.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPNegateOperation.Check">
<short>Validate the negation operation for correctness</short>
<descr>
<p>The <var>Check</var> method validates that the operand of the negation operation is a numeric type suitable for negation.
It ensures type compatibility and prevents attempts to negate non-numeric values.</p>
<p>The validation process checks that the operand is of a numeric type (integer, float, or currency) that supports negation operations.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPNegateOperation.NodeType">
<short>Get the result type for negation operations</short>
<descr>
<p>The <var>NodeType</var> method returns the result type for negation operations,
which typically matches the type of the operand. The result preserves the numeric type of the input (integer, float, or currency) to maintain type consistency.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPNegateOperation.NodeType.Result">
<short>Returns the result type of the negation</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPNegateOperation.GetNodeValue">
<short>Calculate the negated value</short>
<descr>
<p>The <var>GetNodeValue</var> method performs the numeric negation by evaluating the operand and changing its sign.
It multiplies the operand's value by -1, effectively converting positive values to negative and negative values to positive.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPNegateOperation.GetNodeValue.Result">
<short>Returns the negated result</short>
</element>

<!-- function Visibility: public -->
<element name="TFPNegateOperation.AsString">
<short>Get string representation of negation operation</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the negation operation,
typically showing the operand prefixed with a minus sign "-" for debugging and display purposes.</p>
<p>The string format helps in understanding the structure of arithmetic expressions and provides
useful information for debugging expression parsing and evaluation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPNegateOperation.AsString.Result">
<short>Returns string representation of the negation</short>
</element>

<!-- class Visibility: default -->
<element name="TFPConstExpression">
<short>Internally used class for constant value expressions</short>
<descr>
<p>The <var>TFPConstExpression</var> class represents constant literal values in expressions,
storing fixed values that do not change during expression evaluation. It provides the foundation for all literal constants including strings,
 integers, floats, booleans, and date/time values.</p>
<p>Constant expressions are the leaf nodes of expression trees that provide actual data values rather than computed results.
They are essential building blocks that supply the raw data that other expression nodes operate on.</p>
<p>The class handles various data types through different constructor methods and provides type-safe storage and retrieval of constant values during expression evaluation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateString">
<short>Create constant expression with string value</short>
<descr>
<p>The <var>TFPConstExpression</var> constructor creates a constant expression that holds a string literal value.
The string value is stored internally and will be returned whenever the expression is evaluated.</p>
<p>String constants are used for literal text values in expressions and can be used in string operations,
comparisons, and function parameters that expect string arguments.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateString.AValue">
<short>The string value for the constant</short>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateInteger">
<short>Create constant expression with integer value</short>
<descr>
<p>The <var>TFPConstExpression</var> constructor creates a constant expression that holds an integer literal value.
The integer value is stored internally and will be returned whenever the expression is evaluated.</p>
<p>Integer constants are used for whole number values in expressions and can be used in arithmetic operations,
 comparisons, and function parameters that expect integer arguments.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateInteger.AValue">
<short>The integer value for the constant</short>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateDateTime">
<short>Create constant expression with datetime value</short>
<descr>
<p>The <var>CreateDateTime</var> constructor creates a new constant expression node that holds a datetime value.
The datetime constant can be used in expressions for date/time arithmetic, comparisons, and function parameters that expect datetime arguments.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateDateTime.AValue">
<short>The datetime value for the constant</short>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateFloat">
<short>Create constant expression with float value</short>
<descr>
<p>The <var>CreateFloat</var> constructor creates a new constant expression node that holds a floating-point value.
The float constant can be used in expressions for mathematical calculations, comparisons,
and function parameters that expect floating-point arguments.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateFloat.AValue">
<short>The float value for the constant</short>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateBoolean">
<short>Create constant expression with boolean value</short>
<descr>
<p>The <var>TFPConstExpression</var> constructor creates a new constant expression node that holds a boolean value (true or false).</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateBoolean.AValue">
<short>The boolean value for the constant</short>
</element>

<!-- constructor Visibility: public -->
<element name="TFPConstExpression.CreateCurrency">
<short>Create constant expression with currency value</short>
<descr>
<p>The <var>TFPConstExpression</var> constructor creates a new constant expression node that holds a currency value with fixed-point precision.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.CreateCurrency.AValue">
<short>The currency value for the constant</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPConstExpression.Check">
<short>Validate the constant expression</short>
<descr>
<p>The <var>Check</var> method validates the constant expression to ensure that the stored constant value is valid and consistent with its declared type.
For constant expressions, validation is typically straightforward since the value is fixed.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPConstExpression.NodeType">
<short>Get the result type for constant expressions</short>
<descr>
<p>The <var>NodeType</var> method returns the data type of the constant value stored in the expression.
The result type corresponds directly to the type of the constant data, whether it's integer, float, string, boolean, datetime, or currency.</p>
<p>For constant expressions, the node type is fixed and determined when the constant is created.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPConstExpression.NodeType.Result">
<short>Returns the result type of the constant</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPConstExpression.GetNodeValue">
<short>Get the constant value</short>
<descr>
<p>The <var>GetNodeValue</var> method returns the constant value stored in the expression as a <link id="TFPExpressionResult">TFPExpressionResult</link>.
Since constants have fixed values, this method always returns the same result regardless of context.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPConstExpression.GetNodeValue.Result">
<short>Returns the constant value</short>
</element>

<!-- function Visibility: public -->
<element name="TFPConstExpression.AsString">
<short>Get string representation of constant expression</short>
<descr>
<p>The <var>AsString</var> method returns a string representation of the constant expression, showing the constant value in a readable format.
The string representation varies based on the data type of the constant value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPConstExpression.AsString.Result">
<short>Returns string representation of the constant</short>
</element>

<!-- property Visibility: public -->
<element name="TFPConstExpression.ConstValue">
<short>The constant value stored in the expression</short>
<descr>
<p>The <var>ConstValue</var> property provides access to the constant value held by the expression node.
The value is stored as a <link id="TFPExpressionResult">TFPExpressionResult</link> record containing both the value and its type information.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TIdentifierType">
<short>Type representing different kinds of identifiers in expressions</short>
<descr>
<p>This enumeration defines the different types of identifiers that can be encountered in expressions.
It distinguishes between variables and functions to enable proper handling and resolution during expression parsing and evaluation.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TIdentifierType.itVariable">
<short>Variable identifier type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TIdentifierType.itFunctionCallBack">
<short>Function callback identifier type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TIdentifierType.itFunctionHandler">
<short>Function event handler identifier type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TIdentifierType.itFunctionNode">
<short>Function node identifier type</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TFPExprFunctionCallBack">
<short>Callback procedure type for function evaluation</short>
<descr>
<p>This procedural type defines the signature for callback procedures that can be used to implement custom function evaluation.
It allows external code to provide function implementations that will be called during expression evaluation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunctionCallBack.Result">
<short>The result of the function callback</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunctionCallBack.Args">
<short>The arguments passed to the function</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TFPExprFunctionEvent">
<short>Event procedure type for function evaluation</short>
<descr>
<p>This event procedure type defines the signature for event handlers that implement custom function evaluation.
It provides a method-based approach to function implementation using object methods rather than standalone procedures.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunctionEvent.Result">
<short>The result of the function event</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunctionEvent.Args">
<short>The arguments passed to the function</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TFPExprVariableCallBack">
<short>Callback procedure type for variable evaluation</short>
<descr>
<p>This procedural type defines the signature for callback procedures that provide variable values during expression evaluation.
It allows external code to resolve variable names to their corresponding values at runtime.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprVariableCallBack.Result">
<short>The result of the variable callback</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprVariableCallBack.AName">
<short>The name of the variable being evaluated</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TFPExprVariableEvent">
<short>Event procedure type for variable evaluation</short>
<descr>
<p>This event procedure type defines the signature for event handlers that resolve variable values during expression evaluation.
It provides a method-based approach to variable resolution using object methods rather than standalone procedures.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprVariableEvent.Result">
<short>The result of the variable event</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprVariableEvent.AName">
<short>The name of the variable being evaluated</short>
</element>

<!-- class Visibility: default -->
<element name="TFPExprIdentifierDef">
<short>Class for defining identifiers in expressions</short>
<descr>
<p>The <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> class defines an identifier (variable or function) that can be used in expressions.
It holds the name, type, and implementation details for identifiers, allowing the expression parser to resolve and evaluate them during expression processing.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDef.ArgumentCount">
<short>Get the number of arguments for function identifier</short>
<descr>
<p>The <var>ArgumentCount</var> method returns the number of arguments that a function identifier expects.
For variable identifiers, it returns 0. For function identifiers, it returns the count of parameters required for the function call.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDef.ArgumentCount.Result">
<short>Returns the argument count</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprIdentifierDef.Assign">
<short>Assign values from another identifier definition</short>
<descr>
<p>The <link id="TFPExprIdentifierDef.Assign">Assign</link> method copies all properties and settings from another <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> object.
It enables  copying identifier definitions with all their associated configuration and callback information, as usual for a <var>TPersistent</var> descendant.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDef.Assign.Source">
<short>The source identifier definition to copy from</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDef.EventBasedVariable">
<short>Check if identifier is an event-based variable</short>
<descr>
<p>The <var>EventBasedVariable</var> method returns True if the identifier represents a variable that uses event-based evaluation rather than callback procedures.
 Event-based variables use method calls on objects for value resolution instead of standalone procedures.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDef.EventBasedVariable.Result">
<short>Returns true if variable is event-based</short>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsFloat">
<short>Get identifier value as float</short>
<descr>
<p>The <var>AsFloat</var> property returns the identifier's value converted to a floating-point number.
If the identifier represents a variable, it retrieves the current value; if it represents a function,
it calls the function and returns the result converted to float format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsCurrency">
<short>Get identifier value as currency</short>
<descr>
<p>The <var>AsCurrency</var> property returns the identifier's value converted to a currency data type.
If the identifier represents a variable, it retrieves the current value; if it represents a function,
it calls the function and returns the result converted to currency format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsInteger">
<short>Get identifier value as integer</short>
<descr>
<p>The <var>AsInteger</var> property returns the identifier's value converted to an integer number.
If the identifier represents a variable, it retrieves the current value; if it represents a function,
it calls the function and returns the result converted to integer format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsString">
<short>Get identifier value as string</short>
<descr>
<p>The <link id="TFPExprIdentifierDef.AsString">AsString</link> property returns the identifier's value converted to a string representation.
If the identifier represents a variable, it retrieves the current value; if it represents a function, it calls the function and returns the
result converted to string format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsBoolean">
<short>Get identifier value as boolean</short>
<descr>
<p>The <var>AsBoolean</var> property returns the identifier's value converted to a boolean value.
If the identifier represents a variable, it retrieves the current value; if it represents a function,
it calls the function and returns the result converted to boolean format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.AsDateTime">
<short>Get identifier value as datetime</short>
<descr>
<p>The <var>AsDateTime</var> property returns the identifier's value converted to a date/time value.
If the identifier represents a variable, it retrieves the current value; if it represents a function,
it calls the function and returns the result converted to datetime format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.OnGetFunctionValueCallBack">
<short>Callback property for function value evaluation</short>
<descr>
<p>The <var>OnGetFunctionValueCallBack</var> property holds a callback function that is called when the identifier represents a function and needs to be evaluated.
The callback receives the function parameters and returns the computed result value.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDef.OnGetVariableValueCallBack">
<short>Callback property for variable value evaluation</short>
<descr>
<p>The <var>OnGetVariableValueCallBack</var> property holds a callback function that is called when the identifier represents a variable and its value needs to be retrieved.
The callback returns the current value of the variable.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.IdentifierType">
<short>The type of this identifier</short>
<descr>
<p>The <var>IdentifierType</var> property specifies whether this identifier definition represents a variable or a function.
The identifier type determines how the identifier will be processed during expression parsing and evaluation.</p>
<p>Variables are simple value holders, while functions require parameter processing and can perform complex calculations.
The identifier type affects parsing behavior and determines which callback or evaluation method is used.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.Name">
<short>The name of the identifier</short>
<descr>
<p>The <var>Name</var> property contains the name string that identifies this variable or function within expressions.
The name is used during expression parsing to match identifier references to their definitions.</p>
<p>Identifier names are case-sensitive and must follow valid identifier naming conventions.
This name serves as the key for looking up the identifier during expression evaluation.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.Value">
<short>The value of the identifier</short>
<descr>
<p>The <var>Value</var> property contains the current value of the identifier when it represents a variable.
For variables, this property holds the actual data value that will be returned when the identifier is evaluated in expressions.</p>
<p>The value is stored as a string but is interpreted according to the identifier's result type.
For function identifiers, this property is typically not used as functions compute their results dynamically.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.ParameterTypes">
<short>The parameter types for function identifiers</short>
<descr>
<p>The <var>ParameterTypes</var> property specifies the expected parameter types for function identifiers.
It contains an array or string describing the data types that the function expects to receive as arguments.</p>
<p>The parameter type information is used during expression parsing and validation to ensure that
function calls provide arguments of the correct types, enabling compile-time type checking for function calls.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.ResultType">
<short>The result type of the identifier</short>
<descr>
<p>The <var>ResultType</var> property specifies the data type that this identifier produces when evaluated.
For variables, it indicates the type of the stored value. For functions, it indicates the type of value returned by the function.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.OnGetFunctionValue">
<short>Event for function value evaluation</short>
<descr>
<p>The <var>OnGetFunctionValue</var> event is triggered when the identifier represents a function and needs to be evaluated with the provided parameters.
The event handler receives the function arguments and should return the computed result.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.OnGetVariableValue">
<short>Event for variable value evaluation</short>
<descr>
<p>The <var>OnGetVariableValue</var>event is triggered when the identifier represents a variable and its value needs to be retrieved during expression evaluation.
The event handler should return the current value of the variable.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExprIdentifierDef.NodeType">
<short>The node type for this identifier</short>
<descr>
<p>The <var>NodeType</var> property returns the result type that this identifier will produce when used in expressions.
It corresponds to the <link id="TFPExprIdentifierDef.ResultType">ResultType</link> property and is used for expression tree type checking.</p>
<p>The node type information is essential for the expression parser to determine type compatibility and perform appropriate type conversions when this identifier is used in operations.</p>
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TBuiltInCategory">
<short>Type representing categories of built-in functions</short>
<descr>
<p>This enumeration categorizes the different types of built-in functions available in the expression parser.
Each category groups related functions together, such as string functions, mathematical functions, date/time functions, and others.</p>
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcStrings">
<short>String manipulation functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcDateTime">
<short>Date and time functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcMath">
<short>Mathematical functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcBoolean">
<short>Boolean functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcConversion">
<short>Type conversion functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcData">
<short>Data manipulation functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcVaria">
<short>Miscellaneous functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcUser">
<short>User-defined functions category</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBuiltInCategory.bcAggregate">
<short>Aggregate functions category</short>
</element>

<!-- set type Visibility: default -->
<element name="TBuiltInCategories">
<short>Set of built-in function categories</short>
<descr>
<p>This set type allows for specifying collections of <link id="TBuiltInCategory">TBuiltInCategory</link> values.
It is used to define which categories of built-in functions should be enabled or available in specific contexts.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPBuiltInExprIdentifierDef">
<short>Class for built-in expression identifier definitions</short>
<descr>
<p>The <var>TFPBuiltInExprIdentifierDef</var> class extends <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> to provide
additional functionality for built-in functions and variables.
It includes category information and other metadata specific to built-in identifiers that come predefined with the expression parser.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPBuiltInExprIdentifierDef.Assign">
<short>Assign values from another built-in identifier definition</short>
<descr>
<p>The <var>Assign</var> method copies all properties and settings from another <var>TFPBuiltInExprIdentifierDef</var> object,
as usual for a <var>TPersistent</var> descendant</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPBuiltInExprIdentifierDef.Assign.Source">
<short>The source built-in identifier definition to copy from</short>
</element>

<!-- property Visibility: published -->
<element name="TFPBuiltInExprIdentifierDef.Category">
<short>The category of the built-in identifier</short>
<descr>
<p>The <var>Category</var> property specifies which <link id="TBuiltInCategory">TBuiltInCategory</link> this built-in identifier belongs to.
The category is used to group related functions together and can be used for selective inclusion or exclusion of function groups.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPExprIdentifierDefs">
<short>Collection class for expression identifier definitions</short>
<descr>
<p>This collection class manages a set of <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> objects,
providing methods for adding, removing, and searching identifier definitions. I
t serves as a registry for all available variables and functions in an expression context.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.IndexOfIdentifier">
<short>Find the index of an identifier by name</short>
<descr>
<p>The <var>IndexOfIdentifier</var> method searches the collection for an identifier with the specified name and returns its index position.
If no identifier with the given name is found, it returns -1. </p>
<p>The search is case-sensitive.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.IndexOfIdentifier.Result">
<short>Returns the index of the identifier or -1 if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.IndexOfIdentifier.AName">
<short>The name of the identifier to find</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.FindIdentifier">
<short>Find an identifier by name</short>
<descr>
<p>The <var>FindIdentifier</var> method searches the collection for an identifier with the specified
name and returns the <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> object if found, or nil if not found.
The search is case-sensitive and provides a convenient way to locate identifier definitions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.FindIdentifier.Result">
<short>Returns the identifier definition or nil if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.FindIdentifier.AName">
<short>The name of the identifier to find</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.IdentifierByName">
<short>Get an identifier by name</short>
<descr>
<p>The <var>IdentifierByName</var> method retrieves an identifier by name from the collection.
Unlike <link id="TFPExprIdentifierDefs.FindIdentifier">FindIdentifier</link>, this method raises an exception if the identifier is not found,
making it suitable for cases where the identifier is expected to exist.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.IdentifierByName.Result">
<short>Returns the identifier definition</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.IdentifierByName.AName">
<short>The name of the identifier to get</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddVariable">
<short>Add a variable to the identifier collection</short>
<descr>
<p>The <var>AddVariable</var> method creates and adds a new variable identifier to the collection with the specified name and value.
The variable can then be referenced in expressions by its name to retrieve the stored value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddVariable.Result">
<short>Returns the added variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddVariable.AName">
<short>The name of the variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddVariable.AResultType">
<short>The result type of the variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddVariable.ACallback">
<short>The callback for variable evaluation</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddVariable.AValue">
<short>The value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddBooleanVariable">
<short>Add a boolean variable to the collection</short>
<descr>
<p>The <var>AddBooleanVariable</var> method creates and adds a new boolean variable identifier to the collection with the specified name and boolean value.
The variable can then be referenced in expressions to retrieve the boolean value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddBooleanVariable.Result">
<short>Returns the added boolean variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddBooleanVariable.AName">
<short>The name of the boolean variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddBooleanVariable.AValue">
<short>The boolean value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddIntegerVariable">
<short>Add an integer variable to the collection</short>
<descr>
<p>The <var>AddIntegerVariable</var> method creates and adds a new integer variable identifier to the collection with the specified name and integer value.
The variable can then be referenced in expressions to retrieve the numeric value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddIntegerVariable.Result">
<short>Returns the added integer variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddIntegerVariable.AName">
<short>The name of the integer variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddIntegerVariable.AValue">
<short>The integer value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddFloatVariable">
<short>Add a float variable to the collection</short>
<descr>
<p>The <var>AddFloatVariable</var> method creates and adds a new floating-point variable identifier to the collection with the specified name and float value.
The variable can then be referenced in expressions to retrieve the floating-point value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFloatVariable.Result">
<short>Returns the added float variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFloatVariable.AName">
<short>The name of the float variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFloatVariable.AValue">
<short>The float value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddCurrencyVariable">
<short>Add a currency variable to the collection</short>
<descr>
<p>The <var>AddCurrencyVariable</var> method creates and adds a new currency variable identifier to the collection with the specified name and currency value.
The variable can then be referenced in expressions to retrieve the monetary value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddCurrencyVariable.Result">
<short>Returns the added currency variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddCurrencyVariable.AName">
<short>The name of the currency variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddCurrencyVariable.AValue">
<short>The currency value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddStringVariable">
<short>Add a string variable to the collection</short>
<descr>
<p>The <var>AddStringVariable</var> method creates and adds a new string variable identifier to the collection with the specified name and string value.
The variable can then be referenced in expressions to retrieve the text value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddStringVariable.Result">
<short>Returns the added string variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddStringVariable.AName">
<short>The name of the string variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddStringVariable.AValue">
<short>The string value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddDateTimeVariable">
<short>Add a datetime variable to the collection</short>
<descr>
<p>The <var>AddDateTimeVariable</var> method creates and adds a new date/time variable identifier to the collection with the specified name and datetime value.
The variable can then be referenced in expressions to retrieve the date/time value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddDateTimeVariable.Result">
<short>Returns the added datetime variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddDateTimeVariable.AName">
<short>The name of the datetime variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddDateTimeVariable.AValue">
<short>The datetime value of the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierDefs.AddFunction">
<short>Add a function to the collection</short>
<descr>
<p>The <var>AddFunction</var> method creates and adds a new function identifier to the collection with the specified
name, parameter types, result type, and implementation details.
The function becomes available for use in expressions parsed by this identifier collection.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.Result">
<short>Returns the added function identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.AName">
<short>The name of the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.AResultType">
<short>The result type of the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.AParamTypes">
<short>The parameter types of the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.ACallBack">
<short>The callback for function evaluation</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierDefs.AddFunction.ANodeClass">
<short>The node class for the function</short>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierDefs.Identifiers">
<short>Access to identifier definitions by index</short>
<descr>
<p>This indexed property provides direct access to identifier definitions in the collection by their numeric index.
It allows iteration through all identifiers and enables index-based retrieval of <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> objects.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TFPExprIdentifierDefs.Identifiers.AIndex">
<short>The index of the identifier to access</short>
</element>

<!-- class Visibility: default -->
<element name="TFPExprIdentifierNode">
<short>Internally used class for identifier nodes in expression trees</short>
<descr>
<p>The <var>TFPExprIdentifierNode</var> class represents an identifier reference in the expression tree.
 It holds a reference to the identifier definition and handles the resolution and evaluation of variables
  and function calls during expression evaluation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPExprIdentifierNode.CreateIdentifier">
<short>Create identifier node with identifier definition</short>
<descr>
<p>The <var>CreateIdentifier</var> constructor creates a new identifier node and associates
it with the specified <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> object.
The identifier definition provides the name, type, and evaluation mechanism for the identifier.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierNode.CreateIdentifier.AID">
<short>The identifier definition for this node</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExprIdentifierNode.NodeType">
<short>Get the result type for identifier nodes</short>
<descr>
<p>The <link id="TFPExprIdentifierNode.NodeType">NodeType</link> method returns
the data type that this identifier node will produce when evaluated.
The result type is determined by the associated identifier definition and its configured result type.</p>
<p>The node type is used by the expression parser for type checking
and ensuring type compatibility throughout the expression tree during parsing and evaluation.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprIdentifierNode.NodeType.Result">
<short>Returns the result type of the identifier</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprIdentifierNode.GetNodeValue">
<short>Get the value of the identifier</short>
<descr>
<p>The <var>GetNodeValue</var> method retrieves the current value of the identifier by calling the appropriate evaluation mechanism
(callback, event handler, or direct value access) based on the identifier's configuration.</p>
<p>For variables, this returns the stored value. For functions, this executes the function with any provided parameters and returns the computed result.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprIdentifierNode.GetNodeValue.Result">
<short>Returns the identifier value</short>
</element>

<!-- property Visibility: public -->
<element name="TFPExprIdentifierNode.Identifier">
<short>The identifier definition for this node</short>
<descr>
<p>The <var>Identifier</var> property references the <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link>
object that defines this identifier's characteristics, including its name, type, value, and evaluation methods.</p>
<p>The identifier definition contains all the metadata needed to properly evaluate this identifier node during
expression evaluation, including callbacks, event handlers, and type information.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPExprVariable">
<short>Internally used class for variable expression nodes</short>
<descr>
<p>The <var>TFPExprVariable</var> class represents a variable reference in an expression tree.
Variables are identifiers that hold values and can be referenced by name within expressions to retrieve their current values.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="TFPExprVariable.Check">
<short>Validate the variable expression</short>
<descr>
<p>The <var>Check</var> method validates that the variable expression is properly configured and that the associated variable definition is valid and accessible for evaluation.</p>
</descr>
</element>

<!-- function Visibility: default -->
<element name="TFPExprVariable.AsString">
<short>Get string representation of variable expression</short>
<descr>
<p>The <var>AsString</var> method returns a human-readable string representation of the variable expression, typically showing the variable name as it appears in the original expression text.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprVariable.AsString.Result">
<short>Returns string representation of the variable</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprFunction.Check">
<short>Validate the function expression</short>
<descr>
<p>The <var>Check</var> method validates that the function expression is properly configured, with correct parameter count and types matching the function definition.
It ensures that all arguments are valid expressions and that the function can be safely evaluated.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TFPExprFunction.CreateFunction">
<short>Create function with identifier and arguments</short>
<descr>
<p>The <var>CreateFunction</var> constructor creates a new function node with the specified identifier definition and argument expressions.
It saves the function call structure and associates the function implementation with its parameters.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunction.CreateFunction.AID">
<short>The function identifier definition</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExprFunction.CreateFunction.Args">
<short>The arguments for the function</short>
</element>

<!-- destructor Visibility: public -->
<element name="TFPExprFunction.Destroy">
<short>Destroy function expression and free resources</short>
<descr>
<p>This destructor properly cleans up the function expression by freeing all argument nodes and any other resources used by the function expression.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprFunction.InitAggregate">
<short>Initialize aggregate processing for function</short>
<descr>
<p>The <var>InitAggregate</var> method initializes aggregate processing for the function and all its arguments.
It ensures that any aggregate operations within the function arguments are properly initialized for a new aggregate calculation cycle.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExprFunction.UpdateAggregate">
<short>Update aggregate calculations for function</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates aggregate calculations for the function and all its arguments.
It ensures that any aggregate operations within the function arguments are properly updated during the aggregate processing cycle.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExprFunction.HasAggregate">
<short>Check if function contains aggregates</short>
<descr>
<p>The <link id="TFPExprFunction.HasAggregate">HasAggregate</link> method determines whether the function or any of its arguments contain aggregate operations.
It returns True if aggregate processing is required for this function, indicating that special aggregate handling is needed.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprFunction.HasAggregate.Result">
<short>Returns true if function has aggregates</short>
</element>

<!-- property Visibility: public -->
<element name="TFPExprFunction.ArgumentNodes">
<short>The argument nodes for the function</short>
<descr>
<p>The <var>ArgumentNodes</var> property provides access to the array of expression nodes that represent the function arguments.
Each element is a <link id="TFPExprNode">TFPExprNode</link> containing the expression tree for one function parameter.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExprFunction.ArgumentParams">
<short>The argument parameters for the function</short>
<descr>
<p>The <var>ArgumentParams</var> property provides access to the array of evaluated parameter values for the function.
Each element is a <link id="TFPExpressionResult">TFPExpressionResult</link> containing the evaluated value and type information for one function parameter.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExprFunction.AsString">
<short>Get string representation of function expression</short>
<descr>
<p>The <var>AsString</var> method returns a human-readable string representation of the function expression,
including the function name and its arguments.
The format typically shows the function call as it would appear in an expression.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExprFunction.AsString.Result">
<short>Returns string representation of the function</short>
</element>

<!-- class Visibility: default -->
<element name="TAggregateExpr">
<short>Internally used Base class for aggregate expressions</short>
<descr>
<p>This abstract base class provides the foundation for all aggregate expression classes in the expression parser.
Aggregate expressions perform calculations over multiple values, such as sums, averages, counts, minimums, and maximums.</p>
<p>The class extends <link id="TFPExprNode">TFPExprNode</link> to provide aggregate-specific
functionality including initialization and update methods that are called as values are processed.
Derived classes must implement the specific aggregation logic for their particular operation.</p>
<p>Aggregate expressions typically maintain internal state that accumulates as values are processed,
making them stateful unlike regular expression nodes.
The aggregation process involves initialization, iterative updates, and final value calculation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- class function Visibility: public -->
<element name="TAggregateExpr.IsAggregate">
<short>Check if expression is an aggregate</short>
<descr>
<p>The <var>TAggregateExpr.IsAggregate</var> class function returns True to indicate that this expression is an aggregate expression.
It overrides the default behavior from <link id="TFPExprNode">TFPExprNode</link> which returns False for regular expressions.</p>
<p>The method is used by the expression parser to identify aggregate expressions and handle them differently from regular expressions,
 as aggregates require special processing including initialization and incremental updates.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TAggregateExpr.IsAggregate.Result">
<short>Returns true for aggregate expressions</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateExpr.GetNodeValue">
<short>Get the aggregate expression value</short>
<descr>
<p>The <var>GetNodeValue</var> method returns the final calculated value of the aggregate expression after all values have been processed.
It is called after the aggregation process is complete to retrieve the accumulated result.</p>
<p>The method returns the result in a <link id="TFPExpressionResult">TFPExpressionResult</link> structure,
which can contain different data types depending on the specific aggregate operation (numeric for sums and averages, integer for counts, etc.).</p>
<p>The <link id="TAggregateExpr.GetNodeValue">GetNodeValue</link> method should only be called after the aggregation initialization and update phases
are complete, as the result depends on all processed values.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TAggregateExpr.GetNodeValue.Result">
<short>Returns the aggregate result</short>
</element>

<!-- class Visibility: default -->
<element name="TAggregateMin">
<short>Internally used class for minimum aggregate functions</short>
<descr>
<p>The <var>AggregateMin</var> class implements the minimum aggregate function, which finds the smallest value among all processed values.
It extends <link id="TAggregateExpr">TAggregateExpr</link> to provide minimum-specific aggregation logic.</p>
<p>The class maintains an internal state that tracks the minimum value encountered so far during the aggregation process.
The first value encountered is used as the initial minimum, and subsequent values are compared to update the minimum when smaller values are found.</p>
<p>The minimum function works with numeric types (integers, floats, currency) and can also compare string and date/time values using appropriate comparison logic for each data type.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAggregateMin.FFirst">
<short>Flag indicating first value in aggregation</short>
<descr>
<p>This boolean field tracks whether the next value to be processed will be the first value in the aggregation sequence.
 It is used to determine when to initialize the minimum value rather than compare against an existing minimum.</p>
<p>The field is set to True during initialization and set to False after the first value is processed.
This ensures that the first value becomes the initial minimum value, providing a proper starting point for subsequent comparisons.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateMin.InitAggregate">
<short>Initialize minimum aggregation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes the minimum aggregate for a new aggregation cycle.
It sets up the internal state needed to track the minimum value across multiple value updates.</p>
<p>The method sets an internal flag, indicating that the next value processed will be the first value in the aggregation sequence.
It also prepares any internal storage needed for the minimum calculation.</p>
<p>The <var>InitAggregate</var> method must be called before starting a new aggregation cycle to ensure proper initialization of the aggregate state.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateMin.UpdateAggregate">
<short>Update minimum aggregate with new value</short>
<descr>
<p>The <var>UpdateAggregate</var> method processes a new value in the minimum aggregation sequence.
If this is the first value, it becomes the initial minimum.
Otherwise, the new value is compared with the current minimum and replaces it if smaller.</p>
<p>After processing the first value, the FFirst flag is set to False to ensure subsequent values are properly compared against the established minimum.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TAggregateMax">
<short>Internally used class for maximum aggregate functions</short>
<descr>
<p>The <var>TAggregateMax</var> class implements the maximum aggregate function, which finds the largest value among all processed values.
It extends <link id="TAggregateExpr">TAggregateExpr</link> to provide maximum-specific aggregation logic.</p>
<p>The class maintains an internal state that tracks the maximum value encountered so far during the aggregation process.
The first value encountered is used as the initial maximum, and subsequent values are compared to update the maximum when larger values are found.</p>
<p>The maximum function works with numeric types (integers, floats, currency) and can also compare string and date/time values using appropriate comparison logic for each data type.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAggregateMax.FFirst">
<short>Flag indicating first value in aggregation</short>
<descr>
<p>This boolean field tracks whether the next value to be processed will be the first value in the aggregation sequence.
It is used to determine when to initialize the maximum value rather than compare against an existing maximum.</p>
<p>The field is set to True during initialization and set to False after the first value is processed.
This ensures that the first value becomes the initial maximum value, providing a proper starting point for subsequent comparisons.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateMax.InitAggregate">
<short>Initialize maximum aggregation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes the maximum aggregate for a new aggregation cycle.
It sets up the internal state needed to track the maximum value across multiple value updates.</p>
<p>The method resets an internal flag, indicating that the next value processed will be the first value in the aggregation sequence.
It also prepares any internal storage needed for the maximum calculation.</p>
<p>The <link id="TAggregateMax.InitAggregate">InitAggregate</link> method must be called before starting a new aggregation cycle to ensure proper initialization of the aggregate state.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateMax.UpdateAggregate">
<short>Update maximum aggregate with new value</short>
<descr>
<p>The <var>UpdateAggregate</var> method processes a new value in the maximum aggregation sequence.
If this is the first value, it becomes the initial maximum.
Otherwise, the new value is compared with the current maximum and replaces it if larger.</p>
<p>The method handles different data types appropriately, using numeric comparison for numbers and lexical comparison for strings.
Type compatibility is maintained throughout the aggregation process.</p>
<p>After processing the first value, the FFirst flag is set to False to ensure subsequent values are properly compared against the established maximum.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TAggregateSum">
<short>Internally used class for sum aggregate functions</short>
<descr>
<p>The <var>TAggregateSum</var> class implements the sum aggregate function,
which calculates the total of all processed numeric values.
It extends <link id="TAggregateExpr">TAggregateExpr</link> to provide summation-specific aggregation logic.</p>
<p>The class maintains an internal accumulator that adds each new value to the running total.
 It handles different numeric types (integers, floats, currency) and performs appropriate type conversions to maintain precision during the summation process.</p>
<p>The sum function ensures type safety by converting arguments to compatible numeric types before performing addition operations.
The final result type depends on the types of values processed during aggregation.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TAggregateSum.ConvertArgument">
<short>Convert argument for sum aggregation</short>
<descr>
<p>The <var>ConvertArgument</var> method converts an expression node argument to an appropriate numeric type for summation.
It handles type conversion between different numeric types to ensure compatibility during the sum calculation process.</p>
<p>The method takes the argument index, the expression node containing the value, and the target result type,
then performs the necessary conversion to make the value compatible with the sum operation.</p>
<p>This conversion ensures that mixed numeric types can be properly summed together while maintaining appropriate precision and avoiding type-related runtime errors.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TAggregateSum.ConvertArgument.Result">
<short>Returns the converted argument</short>
</element>

<!-- argument Visibility: default -->
<element name="TAggregateSum.ConvertArgument.aIndex">
<short>The index of the argument to convert</short>
</element>

<!-- argument Visibility: default -->
<element name="TAggregateSum.ConvertArgument.aNode">
<short>The node containing the argument</short>
</element>

<!-- argument Visibility: default -->
<element name="TAggregateSum.ConvertArgument.aType">
<short>The type to convert the argument to</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateSum.InitAggregate">
<short>Initialize sum aggregation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes the sum aggregate for a new aggregation cycle.
It resets the internal accumulator to zero and prepares the aggregate state for processing new values.</p>
<p>The method sets up the appropriate initial values based on the expected result type (integer, float, or currency)
and ensures that the accumulator is ready to receive and sum new values.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateSum.UpdateAggregate">
<short>Update sum aggregate with new value</short>
<descr>
<p>The <var>UpdateAggregate</var> method adds a new value to the running sum during the aggregation process.
It handles the addition of different numeric types while maintaining appropriate precision and type compatibility.</p>
<p>The method performs type conversion as needed using the <link id="TAggregateSum.ConvertArgument">ConvertArgument</link> method,
then adds the converted value to the internal accumulator.
It ensures that the sum calculation maintains the appropriate result type throughout the process.</p>
<p>Each call to this method processes one value from the aggregation sequence and updates the internal sum state accordingly.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TAggregateAvg">
<short>Internally used class for average aggregate functions</short>
<descr>
<p>The <var>TAggregateAvg</var> class implements the average (mean) aggregate function, which calculates the arithmetic mean of all processed numeric values.
It extends <link id="TAggregateSum">TAggregateSum</link> to leverage summation functionality while adding count tracking for average calculation.</p>
<p>The average function handles different numeric types and ensures appropriate precision in the final result.
Division by zero is handled appropriately when no values have been processed.</p>
<p>This class is used internally by the <link id="TFPExpressionParser"/> class to construct an AST (Abstract Syntax Tree).
There is normally no need for you to use or instantiate this class directly.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateAvg.InitAggregate">
<short>Initialize average aggregation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes the average aggregate for a new aggregation cycle.
It resets both the sum accumulator and the count of processed values to zero, preparing the aggregate for processing new values.</p>
<p>The method calls the parent <link id="TAggregateSum.InitAggregate">TAggregateSum.InitAggregate</link>
to handle sum initialization and additionally resets the count tracking needed for average calculation.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateAvg.UpdateAggregate">
<short>Update average aggregate with new value</short>
<descr>
<p>The <var>UpdateAggregate</var> method processes a new
value for the average calculation by updating both the running sum and incrementing the count of processed values.
It leverages the parent <link id="TAggregateSum.UpdateAggregate">TAggregateSum.UpdateAggregate</link> for sum handling.</p>
<p>Each call to this method adds one value to the sum and increases the count by one, maintaining the data needed to calculate the final average when requested.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateAvg.GetNodeValue">
<short>Calculate the average from aggregated values</short>
<descr>
<p>The <var>GetNodeValue</var> method calculates and returns the final average value by dividing the accumulated sum by the count of processed values.
It overrides the base class behavior to provide average-specific result calculation.</p>
<p>The method handles edge cases such as division by zero (when no values have been processed) and ensures appropriate result type conversion based on the input data types.</p>
<p>The returned result is a <link id="TFPExpressionResult">TFPExpressionResult</link> containing the calculated average as a floating-point value.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TAggregateAvg.GetNodeValue.Result">
<short>Returns the calculated average</short>
</element>

<!-- class Visibility: default -->
<element name="TAggregateCount">
<short>Internally used class for count aggregate functions</short>
<descr>
<p>The <var>TAggregateCount</var> class implements the count aggregate function, which counts the number of values processed during aggregation.
It extends <link id="TAggregateExpr">TAggregateExpr</link> to provide count-specific aggregation logic.</p>
<p>Unlike other aggregate functions that process the actual values, the count function simply increments a counter for each value encountered, regardless of the value's content or type.
This makes it useful for determining the number of records or values in a dataset.</p>
<p>The count function always returns an integer result representing the total number of values processed during the aggregation cycle.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateCount.InitAggregate">
<short>Initialize count aggregation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes the count aggregate for a new aggregation cycle.
It resets the internal counter to zero, preparing the aggregate to count new values from the beginning.</p>
<p>The method sets up the initial state needed for accurate counting and ensures that the counter starts from zero for each new aggregation sequence.</p>
<p>Proper initialization is essential for accurate count results, as it establishes the starting point for the counting process.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAggregateCount.UpdateAggregate">
<short>Update count aggregate with new value</short>
<descr>
<p>The <var>UpdateAggregate</var> method increments the internal counter by one for each value encountered during the aggregation process.
Unlike other aggregates, it does not examine the actual value content, only the presence of a value.</p>
<p>Each call to this method represents the processing of one item in the aggregation sequence, and the counter is incremented regardless of the value's type or content.</p>
<p>This simple counting approach makes the count aggregate efficient and applicable to any data type or value combination.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPFunctionCallBack">
<short>Internally used class for callback-based function expressions</short>
<descr>
<p>The <var>TFPFunctionCallBack</var> class implements function calls that are resolved using callback mechanisms rather than built-in function implementations.
 It extends the expression framework to allow dynamic function resolution through user-defined callback procedures.</p>
<p>The callback function mechanism enables applications to provide custom function implementations that can be called from within expressions.
This allows for extending the expression language with application-specific functions without modifying the core expression parser.</p>
<p>When a callback function is called, the registered callback procedure is invoked with the function arguments and is expected to compute and return the function result.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPFunctionCallBack.CreateFunction">
<short>Create callback function with identifier and arguments</short>
<descr>
<p>The <var>CreateFunction</var> constructor creates a new callback function instance with the specified identifier definition and argument list.
It establishes the connection between the function call and the callback mechanism that will handle the function execution.</p>
<p>The constructor stores the identifier information and argument expressions that will be used during function evaluation to
invoke the appropriate callback procedure with the correct parameters.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionCallBack.CreateFunction.AID">
<short>The function identifier definition</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionCallBack.CreateFunction.Args">
<short>The arguments for the callback function</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPFunctionCallBack.GetNodeValue">
<short>Get callback function result</short>
<descr>
<p>The <var>GetNodeValue</var> method evaluates the callback function by calling the registered callback procedure with the function parameters and returns the computed result.
It bridges the expression tree evaluation with external function implementations.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionCallBack.GetNodeValue.Result">
<short>Returns the callback function result</short>
</element>

<!-- property Visibility: public -->
<element name="TFPFunctionCallBack.CallBack">
<short>The callback procedure for function evaluation</short>
<descr>
<p>The <var>CallBack</var> property holds the callback procedure that is invoked when the function needs to be evaluated.
The callback receives the function parameters and returns the computed result, allowing external code to provide custom function implementations.</p>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TFPFunctionEventHandler">
<short>Internally used class for event-based function expressions</short>
<descr>
<p>The <var>TFPFunctionEventHandler</var> class provides event-based function evaluation using object method calls instead of standalone callback procedures.
It extends <link id="TFPExprFunction">TFPExprFunction</link> to support method-based function implementations.</p>
</descr>
<seealso>
<link id="TFPExprNode"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPFunctionEventHandler.CreateFunction">
<short>Create event function with identifier and arguments</short>
<descr>
<p>The <var>CreateFunction</var> constructor creates a new event-based function node with the specified identifier definition and argument expressions.
It sets up the function call structure to use event handlers for function evaluation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionEventHandler.CreateFunction.AID">
<short>The function identifier definition</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionEventHandler.CreateFunction.Args">
<short>The arguments for the event function</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPFunctionEventHandler.GetNodeValue">
<short>Get event function result</short>
<descr>
<p>The <link id="TFPFunctionEventHandler.GetNodeValue">GetNodeValue</link> method evaluates the event-based function by c
alling the registered event handler method with the function parameters and returns the computed result.
It provides method-based function evaluation.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPFunctionEventHandler.GetNodeValue.Result">
<short>Returns the event function result</short>
</element>

<!-- property Visibility: public -->
<element name="TFPFunctionEventHandler.CallBack">
<short>The event handler for function evaluation</short>
<descr>
<p>The <var>CallBack</var> property holds the event handler method that is invoked when the function needs to be evaluated.
The event handler receives the function parameters and returns the computed result, enabling object-based function implementations.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TFPExpressionParser.Create">
<short>Create expression parser instance</short>
<descr>
<p>The <var>Create</var> constructor creates a new expression parser instance that can parse and evaluate mathematical expressions.
The parser is initialized with empty identifier collections and is ready to accept expression strings for parsing.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExpressionParser.Create.AOwner">
<short>The owner component for the parser</short>
</element>

<!-- destructor Visibility: public -->
<element name="TFPExpressionParser.Destroy">
<short>Destroy expression parser and free resources</short>
<descr>
<p>This destructor properly cleans up the expression parser by freeing all allocated resources,
including the parsed expression tree, identifier definitions, and any other internal structures used by the parser.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionParser.IdentifierByName">
<short>Get identifier definition by name</short>
<descr>
<p>The <var>IdentifierByName</var> method searches for an identifier definition with the
specified name in the parser's identifier collection.
It returns the <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> object if found, or raises an exception if not found.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionParser.IdentifierByName.Result">
<short>Returns the identifier definition</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExpressionParser.IdentifierByName.AName">
<short>The name of the identifier to find</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExpressionParser.Clear">
<short>Clear the current expression</short>
<descr>
<p>The <var>Clear</var> method clears the currently parsed expression from the parser,
freeing any expression tree that was previously built. After calling this method, the parser is ready to parse a new expression.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExpressionParser.EvaluateExpression">
<short>Evaluate the expression and return result</short>
<descr>
<p>The <var>EvaluateExpression</var> method evaluates the currently parsed expression using the
provided identifier values and returns the computed result.
It processes the entire expression tree to produce the final result value.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TFPExpressionParser.EvaluateExpression.Result">
<short>Returns the evaluation result</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionParser.ExtractNode">
<short>Extract expression node from result</short>
<descr>
<p>The <var>ExtractNode</var> method extracts and returns the expression tree node from an expression result structure.
It provides access to the internal node representation for advanced manipulation or analysis of the parsed expression.</p>
<p>This allows you to evaluate the same expression multiple times without needing to re-parse the expresion: by changing e.g. the
value of a variable and calling the <link id="TFPExpressionResult.NodeValue"/> method on the extracted node, you can get the updated result.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionParser.ExtractNode.Result">
<short>Returns the extracted node</short>
</element>

<!-- argument Visibility: default -->
<element name="TFPExpressionParser.ExtractNode.N">
<short>The result to extract node from</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionParser.Evaluate">
<short>Evaluate the current expression</short>
<descr>
<p>The <var>Evaluate</var> method evaluates the currently parsed expression and returns the result as an <link id="TFPExpressionResult">TFPExpressionResult</link>.
It executes the complete expression tree and computes the final value.</p>
<p>The evaluation process includes resolving variables, calling functions, and performing all arithmetic and logical operations according to the expression structure and operator precedence rules.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionParser.Evaluate.Result">
<short>Returns the evaluation result</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionParser.ResultType">
<short>Get the result type of the expression</short>
<descr>
<p>The <var>ResultType</var> method returns the data type that the currently parsed expression will produce when evaluated.
The result type is determined by analyzing the expression tree and applying type promotion rules.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionParser.ResultType.Result">
<short>Returns the result type</short>
</element>

<!-- function Visibility: public -->
<element name="TFPExpressionParser.HasAggregate">
<short>Check if expression contains aggregates</short>
<descr>
<p>The <var>HasAggregate</var> method determines whether
the current expression contains any aggregate functions such as Sum, Count, Average, Min, or Max.
Aggregate functions require special handling during evaluation.</p>
<p>This information is important for determining the evaluation strategy,
as expressions with aggregates may need multiple evaluation passes or special initialization steps.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TFPExpressionParser.HasAggregate.Result">
<short>Returns true if expression has aggregates</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExpressionParser.InitAggregate">
<short>Initialize aggregate calculation</short>
<descr>
<p>The <var>InitAggregate</var> method initializes all aggregate functions within the expression for aggregate processing.
It prepares aggregate functions like Sum, Count, Average, Min, and Max for data processing by resetting their internal state.</p>
<p>The <var>InitAggregate</var> method must be called before processing data sets with expressions containing aggregate functions to ensure correct aggregate calculations.</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TFPExpressionParser.UpdateAggregate">
<short>Update aggregate calculation with value</short>
<descr>
<p>The <var>UpdateAggregate</var> method updates all aggregate functions in the expression with new data values during aggregate processing.
It processes each data row or value set through the expression's aggregate functions.</p>
<p>The <var>TFPExpressionParser</var> method is called repeatedly for each data item
when processing datasets with aggregate expressions to accumulate the aggregate results.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsFloat">
<short>Expression result as floating point value</short>
<descr>
<p>The <var>AsFloat</var> property returns the expression evaluation result converted to a floating-point value.
It automatically handles type conversion from the expression's native result type to float.</p>

</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsCurrency">
<short>Expression result as currency value</short>
<descr>
<p>The <var>AsCurrency</var> property returns the expression evaluation result converted to a currency value with fixed-point precision.
It handles automatic type conversion from compatible numeric types to currency.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsInteger">
<short>Expression result as integer value</short>
<descr>
<p>The <var>AsInteger</var> property returns the expression evaluation result converted to an integer value.
It automatically handles type conversion from the expression's native result type to integer, applying appropriate rounding or truncation.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsString">
<short>Expression result as string value</short>
<descr>
<p>The <link id="TFPExpressionParser.AsString">AsString</link> property returns the expression evaluation result converted to a string representation.
It automatically handles type conversion from any result type to a human-readable string format.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsBoolean">
<short>Expression result as boolean value</short>
<descr>
<p>The <var>AsBoolean</var> property returns the expression evaluation result converted to a boolean value.
It handles automatic type conversion from compatible types to boolean, following standard conversion rules.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TFPExpressionParser.AsDateTime">
<short>Expression result as date/time value</short>
<descr>
<p>The <var>AsDateTime</var> property returns the expression evaluation result converted to a date/time value.
It automatically handles type conversion from compatible numeric or string types to datetime format.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExpressionParser.Expression">
<short>Expression string to be evaluated</short>
<descr>
<p>The <var>Expression</var> property contains the expression text that will be parsed and evaluated by the parser.
Setting this property triggers the parsing process, converting the text into an internal expression tree representation.</p>
<p>The expression string follows the syntax rules supported by the parser, including operators, functions, variables, and constants.
Any syntax errors in the expression will be reported during the parsing phase.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExpressionParser.Identifiers">
<short>Collection of identifiers and their values</short>
<descr>
<p>The <var>Identifiers</var> property provides access to the collection of user-defined identifiers
(variables and functions) that can be referenced within expressions.
It contains <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> objects defining each identifier.</p>
<p>Applications can add custom variables and functions to this collection to extend
the expression language with domain-specific functionality and data sources.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TFPExpressionParser.BuiltIns">
<short>Manager for built-in functions and constants</short>
<descr>
<p>The <var>BuiltIns</var> property references the <link id="TExprBuiltInManager">TExprBuiltInManager</link> instance that p
rovides access to built-in mathematical functions, string functions, date/time functions, and predefined constants.</p>
<p>The built-ins manager can be customized to add or modify the set of built-in functions available to expressions,
allowing applications to tailor the function library to their specific needs.</p>
</descr>
</element>

<!-- "class of" type Visibility: default -->
<element name="TFPExpressionParserClass">
<short>Class reference type for TFPExpressionParser</short>
<descr>
<p>This is a class reference type that can hold references to <link id="TFPExpressionParser">TFPExpressionParser</link> or its derived classes.
It enables polymorphic creation and manipulation of parser instances.</p>
<p>This type is useful for applications that need to work with different parser implementations
or create parser instances dynamically based on runtime conditions.</p>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TExprBuiltInManager.Create">
<short>Create built-in manager instance</short>
<descr>
<p>The <link id="TExprBuiltInManager">TExprBuiltInManager</link> constructor creates a new built-in manager instance
that provides standard built-in functions and variables for expression parsing.
The manager registers common mathematical, string, date/time, and conversion functions.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.Create.AOwner">
<short>Owner of the built-in manager</short>
</element>

<!-- destructor Visibility: public -->
<element name="TExprBuiltInManager.Destroy">
<short>Destroy built-in manager instance</short>
<descr>
<p>This destructor properly cleans up the built-in manager by freeing all registered built-in identifier
definitions and any other allocated resources used by the manager.</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.IndexOfIdentifier">
<short>Find index of built-in identifier</short>
<descr>
<p>The <link id="TExprBuiltInManager.IndexOfIdentifier">IndexOfIdentifier</link> method searches for a built-in identifier with the
specified name and returns its index position in the collection.
If the identifier is not found, it returns -1. The search is case-sensitive.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.IndexOfIdentifier.Result">
<short>Returns index or -1 if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.IndexOfIdentifier.AName">
<short>Name of identifier to find</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.FindIdentifier">
<short>Find built-in identifier by name</short>
<descr>
<p>The <link id="TExprBuiltInManager.FindIdentifier">FindIdentifier</link> method searches for a built-in identifier with the specified
name and returns the <link id="TFPBuiltInExprIdentifierDef">TFPBuiltInExprIdentifierDef</link> object if found, or nil if not found.
The search is case-sensitive and covers all registered built-in functions and variables.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.FindIdentifier.Result">
<short>Returns identifier or nil if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.FindIdentifier.AName">
<short>Name of identifier to find</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.IdentifierByName">
<short>Get identifier by name with exception on not found</short>
<descr>
<p>The <link id="TExprBuiltInManager.IdentifierByName">IdentifierByName</link> method retrieves a built-in
identifier by name from the manager. Unlike <link id="TExprBuiltInManager.FindIdentifier">FindIdentifier</link>,
this method raises an exception if the identifier is not found, making it suitable when the identifier is expected to exist.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.IdentifierByName.Result">
<short>Returns the found identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.IdentifierByName.AName">
<short>Name of identifier to retrieve</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddVariable">
<short>Add variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddVariable">AddVariable</link> method creates and adds a new built-in variable
to the manager with the specified category, name, and value. The variable becomes available for use in expressions parsed by this manager.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddVariable.Result">
<short>Returns the added variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddVariable.ACategory">
<short>Category for the variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddVariable.AName">
<short>Name of the variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddVariable.AResultType">
<short>Result type for the variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddVariable.AValue">
<short>Initial value for the variable</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddBooleanVariable">
<short>Add boolean variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddBooleanVariable">AddBooleanVariable</link> method creates and adds a new boolean built-in variable
to the manager with the specified category, name, and boolean value. The variable can then be referenced in expressions to retrieve the boolean value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddBooleanVariable.Result">
<short>Returns the added boolean variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddBooleanVariable.ACategory">
<short>Category for the boolean variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddBooleanVariable.AName">
<short>Name of the boolean variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddBooleanVariable.AValue">
<short>Initial boolean value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddIntegerVariable">
<short>Add integer variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddIntegerVariable">AddIntegerVariable</link> method creates and
adds a new integer built-in variable to the manager with the specified category, name, and integer value.
The variable can then be referenced in expressions to retrieve the numeric value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddIntegerVariable.Result">
<short>Returns the added integer variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddIntegerVariable.ACategory">
<short>Category for the integer variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddIntegerVariable.AName">
<short>Name of the integer variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddIntegerVariable.AValue">
<short>Initial integer value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddFloatVariable">
<short>Add float variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddFloatVariable">AddFloatVariable</link> method creates and adds a new floating-point built-in
variable to the manager with the specified category, name, and float value.
The variable can then be referenced in expressions to retrieve the floating-point value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddFloatVariable.Result">
<short>Returns the added float variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFloatVariable.ACategory">
<short>Category for the float variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFloatVariable.AName">
<short>Name of the float variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFloatVariable.AValue">
<short>Initial float value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddCurrencyVariable">
<short>Add currency variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddCurrencyVariable">AddCurrencyVariable</link> method creates and adds
a new currency built-in variable to the manager with the specified category, name, and currency value.
The variable can then be referenced in expressions to retrieve the monetary value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddCurrencyVariable.Result">
<short>Returns the added currency variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddCurrencyVariable.ACategory">
<short>Category for the currency variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddCurrencyVariable.AName">
<short>Name of the currency variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddCurrencyVariable.AValue">
<short>Initial currency value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddStringVariable">
<short>Add string variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddStringVariable">AddStringVariable</link> method creates and adds a
new string built-in variable to the manager with the specified category, name, and string value.
The variable can then be referenced in expressions to retrieve the text value.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddStringVariable.Result">
<short>Returns the added string variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddStringVariable.ACategory">
<short>Category for the string variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddStringVariable.AName">
<short>Name of the string variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddStringVariable.AValue">
<short>Initial string value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddDateTimeVariable">
<short>Add datetime variable to built-in collection</short>
<descr>
<p>The <link id="TExprBuiltInManager.AddDateTimeVariable">AddDateTimeVariable</link> method adds a datetime variable
with the specified name and initial value to the built-in collection.
The variable will be available in expressions under the provided name and will initially hold the specified datetime value.</p>
<p>Built-in datetime variables can be used to provide predefined date/time values like current date,
system timestamps, or reference dates that expressions can access and use in date/time calculations.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddDateTimeVariable.Result">
<short>Returns the added datetime variable identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddDateTimeVariable.ACategory">
<short>Category for the datetime variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddDateTimeVariable.AName">
<short>Name of the datetime variable</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddDateTimeVariable.AValue">
<short>Initial datetime value</short>
</element>

<!-- function Visibility: public -->
<element name="TExprBuiltInManager.AddFunction">
<short>Add function to built-in collection</short>
<descr>
<p>The <var>AddFunction</var> method adds a custom function to the built-in collection, making it available for use in expressions.
The function must provide appropriate callback or event handling mechanisms for evaluation.</p>
<p>Built-in functions extend the expression language with domain-specific functionality,
allowing applications to provide mathematical, string, date/time, or business-logic functions that can be called from within expressions.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.Result">
<short>Returns the added function identifier</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.ACategory">
<short>Category for the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.AName">
<short>Name of the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.AResultType">
<short>Result type for the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.AParamTypes">
<short>Parameter types for the function</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.ACallBack">
<short>Callback function for the built-in</short>
</element>

<!-- argument Visibility: default -->
<element name="TExprBuiltInManager.AddFunction.ANodeClass">
<short>Node class for the function</short>
</element>

<!-- property Visibility: public -->
<element name="TExprBuiltInManager.IdentifierCount">
<short>Number of built-in identifiers</short>
<descr>
<p>The <var>IdentifierCount</var> property returns the total number of built-in identifiers (functions and variables) currently registered in the manager.
It includes all predefined mathematical functions, string functions, date/time functions, and variables.</p>
<p>This count is useful for iterating through all available built-ins or for applications that need to report or analyze the available expression language features.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TExprBuiltInManager.Identifiers">
<short>Array access to built-in identifiers</short>
<descr>
<p>The <var>Identifiers</var> property provides indexed access to the built-in identifier definitions registered in the manager.
Each element is a <link id="TFPExprIdentifierDef">TFPExprIdentifierDef</link> object containing function or variable information.</p>
<p>The array allows applications to enumerate and examine all available built-in functions and variables, useful for creating help systems, function browsers, or validation tools.</p>
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TExprBuiltInManager.Identifiers.AIndex">
<short>Index of identifier to access</short>
</element>

<!-- class Visibility: default -->
<element name="EExprParser">
<short>Expression parser exception class</short>
<descr>
<p>This exception class is raised by the <link id="TFPExpressionParser">TFPExpressionParser</link> when parsing or evaluation errors occur.
It encompasses both syntactic errors during expression parsing and runtime errors during expression evaluation.</p>
<p>This exception is raised in various scenarios:</p>
<ul>
<li>Syntax errors in expression structure (mismatched parentheses, invalid operators)</li>
<li>Type mismatches during expression evaluation</li>
<li>Undefined variable or function references</li>
<li>Runtime errors during function calls or mathematical operations</li>
<li>Invalid function arguments or parameter count mismatches</li>
<li>Division by zero and other mathematical errors</li>
</ul>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="AllBuiltIns">
<short>Set of all built-in identifier categories</short>
<descr>
<p>This constant represents the complete set of all available built-in identifier categories in the expression parser.
It includes all predefined categories such as string functions, date/time operations, mathematical functions, boolean operations, data conversion functions, and user-defined functions.</p>
<p>This provides a convenient way to enable the full feature set of the expression parser without having to specify individual categories manually.</p>
</descr>
</element>

<!-- function Visibility: default -->
<element name="TokenName">
<short>Get name for token type</short>
<descr>
<p>The <link id="TokenName">TokenName</link> function converts a <link id="TTokenType">TTokenType</link> enumeration value to its corresponding string name.
It provides a human-readable representation of token types for debugging, error reporting, and logging purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TokenName.Result">
<short>Returns string name for the token</short>
</element>

<!-- argument Visibility: default -->
<element name="TokenName.AToken">
<short>Token type to get name for</short>
</element>

<!-- function Visibility: default -->
<element name="ResultTypeName">
<short>Get name for result type</short>
<descr>
<p>The <link id="ResultTypeName">ResultTypeName</link> function converts a <link id="TResultType">TResultType</link> enumeration value to its corresponding string name.
It provides a human-readable representation of result types for debugging, error reporting, and logging purposes.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="ResultTypeName.Result">
<short>Returns string name for result type</short>
</element>

<!-- argument Visibility: default -->
<element name="ResultTypeName.AResult">
<short>Result type to get name for</short>
</element>

<!-- function Visibility: default -->
<element name="CharToResultType">
<short>Convert character to result type</short>
<descr>
<p>The <var>CharToResultType</var> function converts a single character code to the corresponding <link id="TResultType">TResultType</link> enumeration value.
It is used internally for parsing type specifications and managing result type conversions within the expression parser.</p>
<p>The character codes map to specific result types:</p>
<ul>
<li>'B' maps to Boolean type (rtBoolean)</li>
<li>'I' maps to Integer type (rtInteger)</li>
<li>'F' maps to Float type (rtFloat)</li>
<li>'S' maps to String type (rtString)</li>
<li>'D' maps to DateTime type (rtDateTime)</li>
<li>'C' maps to Currency type (rtCurrency)</li>
</ul>
<p>The <var>CharToResultType</var> function is primarily used for internal type management and serialization purposes within the expression parsing framework.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="CharToResultType.Result">
<short>Returns corresponding result type</short>
</element>

<!-- argument Visibility: default -->
<element name="CharToResultType.C">
<short>Character to convert to result type</short>
</element>

<!-- function Visibility: default -->
<element name="BuiltinIdentifiers">
<short>Get built-in identifiers manager</short>
<descr>
<p>The <var>BuiltinIdentifiers</var> function provides access to the global <link id="TExprBuiltInManager">TExprBuiltInManager</link> instance that contains all standard built-in functions and variables available to the expression parser. The manager is automatically initialized with default built-in functions when first accessed.</p>
<p>The returned manager includes predefined mathematical functions (sin, cos, sqrt, etc.), string manipulation functions (length, uppercase, etc.), date/time functions (now, date, etc.), and conversion functions between different data types.</p>
<p>This global manager can be extended with custom functions and variables, or individual parsers can use their own manager instances for specialized functionality.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="BuiltinIdentifiers.Result">
<short>Returns global built-in identifiers manager</short>
</element>

<!-- procedure Visibility: default -->
<element name="RegisterStdBuiltins">
<short>Register standard built-in functions</short>
<descr>
<p>This procedure registers the standard set of built-in functions and variables with the specified manager. It populates the manager with predefined mathematical, string, date/time, and utility functions based on the selected categories.</p>
<p>The registration process allows applications to customize which built-in functions are available by specifying categories, enabling selective loading of functionality to meet specific requirements while minimizing memory usage.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="RegisterStdBuiltins.AManager">
<short>Built-in manager to register functions to</short>
</element>

<!-- argument Visibility: default -->
<element name="RegisterStdBuiltins.Categories">
<short>Categories of built-in functions to register</short>
</element>

<!-- function Visibility: default -->
<element name="ArgToFloat">
<short>Convert argument to float value</short>
<descr>
<p>This utility function converts an <link id="TFPExpressionResult">TFPExpressionResult</link> argument to a floating-point value. It handles conversion from various result types including integer, currency, and string representations to the standard <link id="TExprFloat">TExprFloat</link> type.</p>
<p>The function is primarily used internally by mathematical operations and built-in functions that require floating-point operands. It provides type safety by ensuring consistent conversion behavior across different numeric types.</p>
<p>If the argument cannot be converted to a valid floating-point value, appropriate error handling is performed to maintain expression evaluation integrity.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="ArgToFloat.Result">
<short>Returns float representation of argument</short>
</element>

<!-- argument Visibility: default -->
<element name="ArgToFloat.Arg">
<short>Expression argument to convert</short>
</element>

</module> <!-- fpexprpars -->

</package>
</fpdoc-descriptions>
