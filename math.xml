<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<!--  

   $Id: math.xml,v 1.4 2005/04/29 07:57:29 michael Exp $ 
   This file is part of the FPC documentation. 
   Copyright (C) 1997, by Michael Van Canneyt 
 
   The FPC documentation is free text; you can redistribute it and/or 
   modify it under the terms of the GNU Library General Public License as 
   published by the Free Software Foundation; either version 2 of the 
   License, or (at your option) any later version. 
 
   The FPC Documentation is distributed in the hope that it will be useful, 
   but WITHOUT ANY WARRANTY; without even the implied warranty of 
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   Library General Public License for more details. 
 
   You should have received a copy of the GNU Library General Public 
   License along with the FPC documentation; see the file COPYING.LIB.  If not, 
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA. 
 -->
<package name="rtl">
<module name="math">
<short>Additional mathematical routines.</short>
<!-- \FPCexampledir{mathex} -->
<descr>
<p>
This document describes the <file>math</file> unit. The <var>math</var> unit
was initially written by Florian Klaempfl. It provides mathematical
functions which aren't covered by the system unit.
</p>
<p>
This chapter starts out with a definition of all types and constants
that are defined, after which an overview is presented of the available 
functions, grouped by category, and the last part contains a 
complete explanation of each function.
</p>
<p>
The following things must be taken into account when using this unit:
</p>
<ol>
<li>This unit is compiled in Object Pascal mode so all <var>integers</var> are 32 bit.</li>
<li> Some overloaded functions exist for data arrays of integers and
floats. When using the address operator (<var>@</var>) to pass an array of 
data to such a function, make sure the address is typecasted to the 
right type, or turn on the 'typed address operator' feature. failing to
do so, will cause the compiler not be able to decide which function you 
want to call.
</li>
</ol>
</descr>

<topic name="MinMaxRoutines">
<short>Min/max determination</short>
<descr>
<p>
Functions to determine the minimum or maximum of numbers:
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="max"/></td><td>Maximum of 2 values</td></tr>
<tr><td><link id="maxIntValue"/></td><td>Maximum of an array of integer values</td></tr>
<tr><td><link id="maxvalue"/></td><td>Maximum of an array of values</td></tr>
<tr><td><link id="min"/></td><td>Minimum of 2 values</td></tr>
<tr><td><link id="minIntValue"/></td><td>Minimum of an array of integer values</td></tr>
<tr><td><link id="minvalue"/></td><td>Minimum of an array of values</td></tr>
</table>
</descr>
</topic>

<topic name="AngleConversionRoutines">
<short>Angle unit conversion</short>
<descr>
<p>
Routines to convert angles between different angle units.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="cycletorad"/></td><td>convert cycles to radians</td></tr>
<tr><td><link id="degtograd"/></td><td>convert degrees to grads</td></tr>
<tr><td><link id="degtorad"/></td><td>convert degrees to radians</td></tr>
<tr><td><link id="gradtodeg"/></td><td>convert grads to degrees</td></tr>
<tr><td><link id="gradtorad"/></td><td>convert grads to radians</td></tr>
<tr><td><link id="radtocycle"/></td><td>convert radians to cycles</td></tr>
<tr><td><link id="radtodeg"/></td><td>convert radians to degrees</td></tr>
<tr><td><link id="radtograd"/></td><td>convert radians to grads</td></tr>
</table>
</descr>
</topic>

<topic name="TrigoniometricRoutines">
<short>Trigonometric functions</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="arccos"/></td><td>calculate reverse cosine</td></tr>
<tr><td><link id="arcsin"/></td><td>calculate reverse sine</td></tr>
<tr><td><link id="arctan2"/></td><td>calculate reverse tangent</td></tr>
<tr><td><link id="cotan"/></td><td>calculate cotangent</td></tr>
<tr><td><link id="sincos"/></td><td>calculate sine and cosine</td></tr>
<tr><td><link id="tan"/></td><td>calculate tangent</td></tr>
</table>
</descr>
</topic>

<topic name="HyperbolicRoutines">
<short>Hyperbolic functions</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="arcosh"/></td><td>calculate reverse hyperbolic cosine</td></tr>
<tr><td><link id="arsinh"/></td><td>calculate reverse hyperbolic sine</td></tr>
<tr><td><link id="artanh"/></td><td>calculate reverse hyperbolic tangent</td></tr>
<tr><td><link id="cosh"/></td><td>calculate hyperbolic cosine</td></tr>
<tr><td><link id="sinh"/></td><td>calculate hyperbolic sine</td></tr>
<tr><td><link id="tanh"/></td><td>calculate hyperbolic tangent</td></tr>
</table>
</descr>
</topic>

<topic name="ExpLogRoutines">
<short>Exponential and logarithmic functions</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="intpower"/></td><td>Raise float to integer power</td></tr>
<tr><td><link id="ldexp"/></td><td>Calculate $2^p x$</td></tr>
<tr><td><link id="lnxp1"/></td><td>calculate <var>log(x+1)</var></td></tr>
<tr><td><link id="log10"/></td><td>calculate 10-base log</td></tr>
<tr><td><link id="log2"/></td><td>calculate 2-base log</td></tr>
<tr><td><link id="logn"/></td><td>calculate N-base log</td></tr>
<tr><td><link id="power"/></td><td>raise float to arbitrary power</td></tr>
</table>
</descr>
</topic>

<topic name="NumberConversionRoutines">
<short>Number converting</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="ceil"/></td><td>Round to infinity</td></tr>
<tr><td><link id="floor"/></td><td>Round to minus infinity</td></tr>
<tr><td><link id="frexp"/></td><td>Return mantissa and exponent</td></tr>
</table>
</descr>
</topic>

<topic name="StatisticalRoutines">
<short>Statistical functions</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="mean"/></td><td>Mean of values</td></tr>
<tr><td><link id="meanandstddev"/></td><td>Mean and standard deviation of values</td></tr>
<tr><td><link id="momentskewkurtosis"/></td><td>Moments, skew and kurtosis</td></tr>
<tr><td><link id="popnstddev"/></td><td>Population standard deviation</td></tr>
<tr><td><link id="popnvariance"/></td><td>Population variance</td></tr>
<tr><td><link id="randg"/></td><td>Gaussian distributed random value</td></tr>
<tr><td><link id="stddev"/></td><td>Standard deviation</td></tr>
<tr><td><link id="sum"/></td><td>Sum of values</td></tr>
<tr><td><link id="sumofsquares"/></td><td>Sum of squared values</td></tr>
<tr><td><link id="sumsandsquares"/></td><td>Sum of values and squared values</td></tr>
<tr><td><link id="totalvariance"/></td><td>Total variance of values</td></tr>
<tr><td><link id="variance"/></td><td>variance of values</td></tr>
</table>
</descr>
</topic>

<topic name="GeometricalRoutines">
<short>Geometrical functions</short>
<descr>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="hypot"/></td><td>Hypotenuse of triangle</td></tr>
<tr><td><link id="norm"/></td><td>Euclidean norm</td></tr>
</table>
</descr>
</topic>

<topic name="CashFlowFunctions">
<short>Cash flow functions</short>
<descr>
<p>
The cash flow functions in the math unit resolve the following equation:
</p>
<pre>
FV + PV * q^n + PMT (q^n - 1) / (q - 1) = 0
</pre>
<p>
In this formula, the following variables are present:
</p>
<dl>
<dt>FV</dt><dd>Future value</dd>
<dt>PV</dt><dd>Present value</dd>
<dt>PMT</dt><dd>Payment per period</dd>
<dt>n</dt><dd>Number of payments (number of periods)</dd>
<dt>q></dt><dd>Interest Rate (return rate)</dd>
</dl>
<p>
The financial functions <link id="FutureValue"/>, <link id="NumberOfPeriods"/>, 
<link id="Payment"/>, <link id="PresentValue"/> and 
<link id="InterestRate"/> solve this equation for one of the variables, when
the other variables are known.
</p>
</descr>
<seealso>
<element name="FutureValue"/>
<link id="FutureValue"/>
<link id="NumberOfPeriods"/>
<link id="Payment"/>
<link id="PresentValue"/>
<link id="TPaymentTime"/>
</seealso>
</topic>

<element name="Float">
<short>Float type used in all calls</short>
<descr>
All calculations are done with the Float type which is the largest float
type available for the current CPU. This allows to
recompile the unit with a different float type to obtain a
desired precision. The pointer type <link id="PFloat"/>
is used in functions that accept an array of values of arbitrary length.
</descr>
</element>

<element name="PFloat">
<short>Pointer to <link id="Float"/> type.</short>
</element>

<element name="TPaymentTime">
<short>Type used in financial (interest) calculations.</short>
</element>
<element name="TPaymentTime.PTEndOfPeriod">
<short>End of period.</short>
</element>
<element name="TPaymentTime.PTStartOfPeriod">
<short>Start of period.</short>
</element>

<element name="EInvalidArgument">
<short>Exception raised when invalid arguments are passed to a function.</short>
</element>

<element name="arccos">
<short>Return inverse cosine</short>
<descr>
<var>Arccos</var> returns the inverse cosine of its argument <var>x</var>. The
argument <var>x</var> should lie between -1 and 1 (borders included). 
</descr>
<errors>
If the argument <var>x</var> is not in the allowed range, an
<var>EInvalidArgument</var> exception is raised.
</errors>
<seealso>
<link id="arcsin"/>
<link id="arcosh"/>
<link id="arsinh"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex1"/>
</element>

<element name="arcosh">
<short>Return inverse hyperbolic cosine</short>
<descr>
<var>Arcosh</var> returns the inverse hyperbolic cosine of its argument <var>x</var>. 
The argument <var>x</var> should be larger than 1. 

The <var>arccosh</var> variant of this function is supplied for Delphi 
compatibility.
</descr>
<errors>
If the argument <var>x</var> is not in the allowed range, an <var>EInvalidArgument</var>
exception is raised.
</errors>
<seealso>
<link id="cosh"/>
<link id="sinh"/>
<link id="arcsin"/>
<link id="arsinh"/>
<link id="artanh"/>,
<link id="tanh"/>
</seealso>
<example file="mathex/ex3"/>
</element>

<element name="arcsin">
<short>Return inverse sine</short>
<descr>
<var>Arcsin</var> returns the inverse sine of its argument <var>x</var>. The
argument <var>x</var> should lie between -1 and 1. 
</descr>
<errors>
If the argument <var>x</var> is not in the allowed range, an <var>EInvalidArgument</var>
exception is raised.
</errors>
<seealso>
<link id="arccos"/>
<link id="arcosh"/>
<link id="arsinh"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex2"/>
</element>


<element name="arctan2">
<short>Return arctangent of (y/x)</short>
<descr>
<var>arctan2</var> calculates <var>arctan(y/x)</var>, and returns an angle in the
correct quadrant. The returned angle will be in the range $-\pi$ to
$\pi$ radians.
The values of <var>x</var> and <var>y</var> must be between -2\^{}64 and 2\^{}64,
moreover <var>x</var> should be different from zero.

On Intel systems this function is implemented with the native intel
<var>fpatan</var> instruction.
</descr>
<seealso>
<link id="arccos"/>
<link id="arcosh"/>
<link id="arsinh"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex6"/>
</element>

<element name="arsinh">
<short>Return inverse hyperbolic sine</short>
<descr>
<var>arsinh</var> returns the inverse hyperbolic sine of its argument <var>x</var>. 

The <var>arscsinh</var> variant of this function is supplied for Delphi 
compatibility.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="arcosh"/>
<link id="arccos"/>
<link id="arcsin"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex4"/>
</element>


<element name="artanh">
<short>Return inverse hyperbolic tangent</short>
<descr>
<var>artanh</var> returns the inverse hyperbolic tangent of its argument <var>x</var>,
where <var>x</var> should lie in the interval [-1,1], borders included.

The <var>arctanh</var> variant of this function is supplied for Delphi compatibility.
</descr>
<errors>
In case <var>x</var> is not in the interval [-1,1], an <var>EInvalidArgument</var>
exception is raised.
</errors>
<seealso>
<link id="arcosh"/>
<link id="arccos"/>
<link id="arcsin"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex5"/>
</element>


<element name="ceil">
<short>Return the lowest integer number greater than or equal to argument</short>
<descr>
<var>Ceil</var> returns the lowest integer number greater than or equal to <var>x</var>.
The absolute value of <var>x</var> should be less than <var>maxint</var>.
</descr>
<errors>
If the absolute value of <var>x</var> is larger than maxint, an overflow error will
occur.
</errors>
<seealso>
<link id="floor"/>
</seealso>
<example file="mathex/ex7"/>
</element>

<element name="cosh">
<short>Return hyperbolic cosine</short>
<descr>
<var>Cosh</var> returns the hyperbolic cosine of it's argument {x}.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="arcosh"/>
<link id="sinh"/>
<link id="arsinh"/>
</seealso>
<example file="mathex/ex8"/>
</element>


<element name="cotan">
<short>Return cotangent</short>
<descr>
<var>Cotan</var> returns the cotangent of it's argument <var>x</var>. 
The argument <var>x</var> must be in radians.
<var>x</var> should be different from zero. 
</descr>
<errors>
If <var>x</var> is zero then a overflow error will occur.
</errors>
<seealso>
<link id="tanh"/>
</seealso>
<example file="mathex/ex9"/>
</element>


<element name="cycletorad">
<short>Convert cycle angle to radians angle</short>
<descr>
<var>Cycletorad</var> transforms it's argument <var>cycle</var>
(an angle expressed in cycles) to radians.
(1 cycle is $2 \pi$ radians).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="degtograd"/>
<link id="degtorad"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="radtocycle"/>
</seealso>
<example file="mathex/ex10"/>
</element>


<element name="degtograd">
<short>Convert degree angle to grads angle</short>
<descr>
<var>Degtograd</var> transforms it's argument <var>deg</var> (an angle in degrees)
to grads.

(90 degrees is 100 grad.)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="cycletorad"/>
<link id="degtorad"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="radtocycle"/>
</seealso>
<example file="mathex/ex11"/>
</element>


<element name="degtorad">
<short>Convert degree angle to radians angle.</short>
<descr>
<var>Degtorad</var> converts it's argument <var>deg</var> (an angle in degrees) to
radians.

(pi radians is 180 degrees)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="cycletorad"/>
<link id="degtograd"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="radtocycle"/>
</seealso>
<example file="mathex/ex12"/>
</element>


<element name="floor">
<short>Return the largest integer smaller than or equal to argument</short>
<descr>
<var>Floor</var> returns the largest integer smaller than or equal to <var>x</var>.
The absolute value of <var>x</var> should be less than <var>maxint</var>.
</descr>
<errors>
If <var>x</var> is larger than <var>maxint</var>, an overflow will occur.
</errors>
<seealso>
<link id="ceil"/>
</seealso>
<example file="mathex/ex13"/>
</element>


<element name="frexp">
<short>Return mantissa and exponent.</short>
<descr>
<var>Frexp</var> returns the mantissa and exponent of it's argument
<var>x</var> in <var>mantissa</var> and <var>exponent</var>.
</descr>
<errors>
None
</errors>
<seealso>
</seealso>
<example file="mathex/ex14"/>
</element>


<element name="gradtodeg">
<short>Convert grads angle to degrees angle</short>
<descr>
<var>Gradtodeg</var> converts its argument <var>grad</var> (an angle in grads)
to degrees.

(100 grad is 90 degrees)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="cycletorad"/>
<link id="degtograd"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="radtocycle"/>
<link id="gradtorad"/>
</seealso>
<example file="mathex/ex15"/>
</element>


<element name="gradtorad">
<short>Convert grads angle to radians angle</short>
<descr>
<var>Gradtorad</var> converts its argument <var>grad</var> (an angle in grads)
to radians.

(200 grad is pi degrees).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="cycletorad"/>
<link id="degtograd"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="radtocycle"/>
<link id="gradtodeg"/>
</seealso>
<example file="mathex/ex16"/>
</element>


<element name="hypot">
<short>Return hypotenuse of triangle</short>
<descr>
<var>Hypot</var> returns the hypotenuse of the triangle where the sides
adjacent to the square angle have lengths <var>x</var> and <var>y</var>.

The function uses Pythagoras' rule for this.
</descr>
<errors>
None.
</errors>
<seealso>
</seealso>
<example file="mathex/ex17"/>
</element>


<element name="intpower">
<short>Return integer power.</short>
<descr>
<var>Intpower</var> returns <var>base</var> to the power <var>exponent</var>,
where exponent is an integer value.
</descr>
<errors>
If <var>base</var> is zero and the exponent is negative, then an
overflow error will occur.
</errors>
<seealso>
<link id="power"/>
</seealso>
<example file="mathex/ex18"/>
</element>


<element name="ldexp">
<short>Return (2 to the power p) times x</short>
<descr>
<var>Ldexp</var> returns (2 to the power <var>p</var>) times <var>x</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="lnxp1"/>
<link id="log10"/>
<link id="log2"/>
<link id="logn"/>
</seealso>
<example file="mathex/ex19"/>
</element>


<element name="lnxp1">
<short>Return natural logarithm of 1+X</short>
<descr>
<var>Lnxp1</var> returns the natural logarithm of <var>1+X</var>. The result
is more precise for small values of <var>x</var>. <var>x</var> should be larger
than -1.
</descr>
<errors>
If $x\leq -1$ then an <var>EInvalidArgument</var> exception will be raised.
</errors>
<seealso>
<link id="ldexp"/>
<link id="log10"/>
<link id="log2"/>
<link id="logn"/>
</seealso>
<example file="mathex/ex20"/>
</element>

<element name="log10">
<short>Return 10-Based logarithm.</short>
<descr>
<var>Log10</var> returns the 10-base logarithm of <var>X</var>.
</descr>
<errors>
If <var>x</var> is less than or equal to 0 an 'invalid fpu operation' error
will occur.
</errors>
<seealso>
<link id="ldexp"/>
<link id="lnxp1"/>
<link id="log2"/>
<link id="logn"/>
</seealso>
<example file="mathex/ex21"/>
</element>


<element name="log2">
<short>Return 2-based logarithm</short>
<descr>
<var>Log2</var> returns the 2-base logarithm of <var>X</var>.
</descr>
<errors>
If <var>x</var> is less than or equal to 0 an 'invalid fpu operation' error
will occur.
</errors>
<seealso>
<link id="ldexp"/>
<link id="lnxp1"/>
<link id="log10"/>
<link id="logn"/>
</seealso>
<example file="mathex/ex22"/>
</element>


<element name="logn">
<short>Return N-based logarithm.</short>
<descr>
<var>Logn</var> returns the n-base logarithm of <var>X</var>.
</descr>
<errors>
If <var>x</var> is less than or equal to 0 an 'invalid fpu operation' error
will occur.
</errors>
<seealso>
<link id="ldexp"/>
<link id="lnxp1"/>
<link id="log10"/>
<link id="log2"/>
</seealso>
<example file="mathex/ex23"/>
</element>

<element name="max">
<short>Return largest of 2 values</short>
<descr>
<var>Max</var> returns the maximum of <var>Int1</var> and <var>Int2</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="min"/>
<link id="maxIntValue"/>
<link id="maxvalue"/>
</seealso>
<example file="mathex/ex24"/>
</element>

<element name="maxIntValue">
<short>Return largest element in integer array</short>
<descr>
<p>
<var>MaxIntValue</var> returns the largest integer out of the <var>Data</var>
array.
</p>
<p>
This function is provided for Delphi compatibility, use the <link id="maxvalue"/>
function instead.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="maxvalue"/>
<link id="minvalue"/>
<link id="minIntValue"/>
</seealso>
<example file="mathex/ex25"/>
</element>


<element name="maxvalue">
<short>Return largest value in array</short>
<descr>
<p>
<var>Maxvalue</var> returns the largest value in the <var>data</var> 
array with integer or float values. The return value has 
the same type as the elements of the array.
</p>
<p>
The third and fourth forms accept a pointer to an array of <var>N</var> 
integer or float values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="maxIntValue"/>
<link id="minvalue"/>
<link id="minIntValue"/>
</seealso>
<example file="mathex/ex26"/>
</element>

<element name="mean">
<short>Return mean value of array</short>
<descr>
<var>Mean</var> returns the average value of <var>data</var>.

The second form accepts a pointer to an array of <var>N</var> values.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="meanandstddev"/>
<link id="momentskewkurtosis"/>
<link id="sum"/>
</seealso>
<example file="mathex/ex27"/>
</element>

<element name="meanandstddev">
<short>Return mean and standard deviation of array</short>
<descr>
<var>meanandstddev</var> calculates the mean and standard deviation of <var>data</var>
and returns the result in <var>mean</var> and <var>stddev</var>, respectively.
Stddev is zero if there is only one value.

The second form accepts a pointer to an array of <var>N</var> values.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="mean"/>
<link id="sum"/>
<link id="sumofsquares"/>
<link id="momentskewkurtosis"/>
</seealso>
<example file="mathex/ex28"/>
</element>


<element name="min">
<short>Return smallest of two values.</short>
<descr>
<var>min</var> returns the smallest value of <var>Int1</var> and <var>Int2</var>;
</descr>
<errors>
None.
</errors>
<seealso>
<link id="max"/>
</seealso>
<example file="mathex/ex29"/>
</element>

<element name="minIntValue">
<short>Return smallest value in integer array</short>
<descr>
<p>
<var>MinIntvalue</var> returns the smallest value in the <var>Data</var> array.
</p>
<p>
This function is provided for Delphi compatibility, use <var>minvalue</var>
instead.
</p>
</descr>
<errors>
None
</errors>
<seealso>
<link id="minvalue"/>
<link id="maxIntValue"/>
<link id="maxvalue"/>
</seealso>
<example file="mathex/ex30"/>
</element>


<element name="minvalue">
<short>Return smallest value in array</short>
<descr>
<p>
<var>Minvalue</var> returns the smallest value in the <var>data</var> 
array with integer or float values. The return value has 
the same type as the elements of the array.
</p>
<p>
The third and fourth forms accept a pointer to an array of <var>N</var> 
integer or float values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="maxIntValue"/>
<link id="maxvalue"/>
<link id="minIntValue"/>
</seealso>
<example file="mathex/ex31"/>
</element>


<element name="momentskewkurtosis">
<short>Return 4 first moments of distribution</short>
<descr>
<var>momentskewkurtosis</var> calculates the 4 first moments of the distribution
of value in <var>data</var> and returns them in <var>m1</var>,<var>m2</var>,<var>m3</var> and
<var>m4</var>, as well as the <var>skew</var> and <var>kurtosis</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="mean"/>
<link id="meanandstddev"/>
</seealso>
<example file="mathex/ex32"/>
</element>

<element name="norm">
<short>Return Euclidean norm</short>
<descr>
<p>
<var>Norm</var> calculates the Euclidean norm of the array of data.
This equals <var>sqrt(sumofsquares(data))</var>.
</p>
<p>
The second form accepts a pointer to an array of <var>N</var> values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="sumofsquares"/>
</seealso>
<example file="mathex/ex33"/>
</element>


<element name="popnstddev">
<short>Return Population standard deviation</short>
<descr>
<p>
<var>Popnstddev</var> returns the square root of the population variance of
the values in the  <var>Data</var> array. It returns zero if there is only one value.
</p>
<p>
The second form of this function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="popnvariance"/>
<link id="mean"/>
<link id="meanandstddev"/>
<link id="stddev"/>
<link id="momentskewkurtosis"/>
</seealso>
<example file="mathex/ex35"/>
</element>


<element name="popnvariance">
<short>Return population variance</short>
<descr>
<p>
<var>Popnvariance</var> the population variance of the values in the
<var>Data</var> array. It returns zero if there is only one value.
</p>
<p>
The second form of this function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="popnstddev"/>
<link id="mean"/>
<link id="meanandstddev"/>
<link id="stddev"/>,
<link id="momentskewkurtosis"/>
</seealso>
<example file="mathex/ex36"/>
</element>


<element name="power">
<short>Return real power.</short>
<descr>
<var>power</var> raises <var>base</var> to the power <var>power</var>. This is equivalent
to <var>exp(power*ln(base))</var>. Therefore <var>base</var> should be non-negative.
</descr>
<errors>
Any number of floating point math exceptions may be raised, if they are not
masked by <link id="SetExceptionMask"/>.
</errors>
<seealso>
<link id="intpower"/>
</seealso>
<example file="mathex/ex34"/>
</element>


<element name="radtocycle">
<short>Convert radians angle to cycle angle</short>
<descr>
<p>
<var>Radtocycle</var> converts its argument <var>rad</var> (an angle expressed in
radians) to an angle in cycles.
</p>
<p>
(1 cycle equals 2 <var>pi</var> radians)
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="degtograd"/>
<link id="degtorad"/>
<link id="radtodeg"/>,
<link id="radtograd"/>
<link id="cycletorad"/>
</seealso>
<example file="mathex/ex37"/>
</element>


<element name="radtodeg">
<short>Convert radians angle to degrees angle</short>
<descr>
<var>Radtodeg</var> converts its argument <var>rad</var> (an angle expressed in
radians) to an angle in degrees.

(180 degrees equals pi radians)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="degtograd"/>
<link id="degtorad"/>
<link id="radtocycle"/>,
<link id="radtograd"/>
<link id="cycletorad"/>
</seealso>
<example file="mathex/ex38"/>
</element>


<element name="radtograd">
<short>Convert radians angle to grads angle</short>
<descr>
<p>
<var>Radtodeg</var> converts its argument <var>rad</var> (an angle expressed in
radians) to an angle in grads.
</p>
<p>
(200 grads equals pi radians)
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="degtograd"/>
<link id="degtorad"/>
<link id="radtocycle"/>,
<link id="radtodeg"/>
<link id="cycletorad"/>
</seealso>
<example file="mathex/ex39"/>
</element>


<element name="randg">
<short>Return gaussian distributed random number.</short>
<descr>
<var>randg</var> returns a random number which - when produced in large
quantities - has a Gaussian distribution with mean <var>mean</var> and 
standarddeviation <var>stddev</var>. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="mean"/>
<link id="stddev"/>
<link id="meanandstddev"/>
</seealso>
<example file="mathex/ex40"/>
</element>


<element name="sincos">
<short>Return sine and cosine of argument</short>
<descr>
<p>
<var>Sincos</var> calculates the sine and cosine of the angle <var>theta</var>,
and returns the result in <var>sinus</var> and <var>cosinus</var>.
</p>
<p>
On Intel hardware, This calculation will be faster than making 2 calls
to calculate the sine and cosine separately.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="arcsin"/>
<link id="arccos"/>.
</seealso>
<example file="mathex/ex41"/>
</element>


<element name="sinh">
<short>Return hyperbolic sine</short>
<descr>
<var>Sinh</var> returns the hyperbolic sine of its argument <var>x</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="cosh"/>
<link id="arsinh"/>
<link id="tanh"/>
<link id="artanh"/>
</seealso>
<example file="mathex/ex42"/>
</element>


<element name="stddev">
<short>Return standard deviation of data</short>
<descr>
<p>
<var>Stddev</var> returns the standard deviation of the values in <var>Data</var>.
It returns zero if there is only one value.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="mean"/>
<link id="meanandstddev"/>
<link id="variance"/>
<link id="totalvariance"/>
</seealso>
<example file="mathex/ex43"/>
</element>


<element name="sum">
<short>Return sum of values</short>
<descr>
<p>
<var>Sum</var> returns the sum of the values in the <var>data</var> array.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="sumofsquares"/>
<link id="sumsandsquares"/>
<link id="totalvariance"/>
<link id="variance"/>
</seealso>
<example file="mathex/ex44"/>
</element>


<element name="sumofsquares">
<short>Return sum of squares of values</short>
<descr>
<p>
<var>Sumofsquares</var> returns the sum of the squares of the values in the <var>data</var> 
array.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="sum"/>
<link id="sumsandsquares"/>
<link id="totalvariance"/>
<link id="variance"/>
</seealso>
<example file="mathex/ex45"/>
</element>


<element name="sumsandsquares">
<short>Return sum and sum of squares of values.</short>
<descr>
<p>
<var>sumsandsquares</var> calculates the sum of the values and the sum of 
the squares of the values in the <var>data</var> array and returns the
results in <var>sum</var> and <var>sumofsquares</var>.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="sum"/>
<link id="sumofsquares"/>
<link id="totalvariance"/>
<link id="variance"/>
</seealso>
<example file="mathex/ex46"/>
</element>


<element name="tan">
<short>Return tangent</short>
<descr>
<var>Tan</var> returns the tangent of <var>x</var>. The argument
<var>x</var> must be in radians.
</descr>
<errors>
If <var>x</var> (normalized) is pi/2 or 3pi/2 then an overflow will occur.
</errors>
<seealso>
<link id="tanh"/>
<link id="arcsin"/>
<link id="sincos"/>
<link id="arccos"/>
</seealso>
<example file="mathex/ex47"/>
</element>


<element name="tanh">
<short>Return hyperbolic tangent</short>
<descr>
<var>Tanh</var> returns the hyperbolic tangent of <var>x</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="arcsin"/>
<link id="sincos"/>
<link id="arccos"/>
</seealso>
<example file="mathex/ex48"/>
</element>


<element name="totalvariance">
<short>Return total variance of values</short>
<descr>
<p>
<var>TotalVariance</var> returns the total variance of the values in the 
<var>data</var> array. It returns zero if there is only one value.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="variance"/>
<link id="stddev"/>
<link id="mean"/>
</seealso>
<example file="mathex/ex49"/>
</element>


<element name="variance">
<short>Return variance of values</short>
<descr>
<p>
<var>Variance</var> returns the variance of the values in the 
<var>data</var> array. It returns zero if there is only one value.
</p>
<p>
The second form of the function accepts a pointer to an array of <var>N</var>
values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="totalvariance"/>
<link id="stddev"/>
<link id="mean"/>
</seealso>
<example file="mathex/ex50"/>
<example file="mathex/ex51"/>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="sysutils">
<short>Used for exception definitions.</short>
</element>

<!-- constant Visibility: default -->
<element name="MinExtended">
<short>Minimum value (closest to zero) of extended type</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxExtended">
<short>Maximum value of extended type</short>
</element>

<!-- constant Visibility: default -->
<element name="MinFloat">
<short>Minimum value (closest to zero) of float type</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxFloat">
<short>Maximum value of float type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInteger">
<short>Pointer to integer type</short>
</element>

<!-- range type Visibility: default -->
<element name="TValueRelationship">
<short>Type to describe relational order between values</short>
</element>

<!-- constant Visibility: default -->
<element name="EqualsValue">
<short>Values are the same</short>
</element>

<!-- constant Visibility: default -->
<element name="LessThanValue">
<short>First value is less than second value</short>
</element>

<!-- constant Visibility: default -->
<element name="GreaterThanValue">
<short>First values is greater than second value</short>
</element>

<!-- constant Visibility: default -->
<element name="NaN">
<short>Value is Not a Number</short>
</element>

<!-- constant Visibility: default -->
<element name="Infinity">
<short>Value is infinity</short>
</element>

<element name="NegInfinity">
<short>Value is negative (minus) infinity</short>
</element>

<!-- function Visibility: default -->
<element name="InRange">
<short>Check whether value is in range.</short>
<descr>
<var>InRange</var> returns <var>True</var> if <var>AValue</var> is in the
range <var>AMin</var>..<var>AMax</var>. It returns <var>False</var> if
<var>Value</var> lies outside the specified range.
</descr>
<seealso>
<link id="EnsureRange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="EnsureRange">
<short>Change value to it falls in specified range.</short>
<descr>
<var>EnsureRange</var> returns <var>Value</var> if <var>AValue</var> is in
the range <var>AMin</var>..<var>AMax</var>. It returns <var>AMin</var> if
the value is less than <var>AMin</var>, or <var>AMax</var> if the value is
larger than <var>AMax</var>.
</descr>
<seealso>
<link id="InRange"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DivMod">
<short>Return DIV and MOD of arguments</short>
<descr>
<var>DivMod</var> returns <var>Dividend</var> DIV <var>Divisor</var> in
<var>Result</var>, and <var>Dividend</var> MOD <var>Divisor</var> in
<var>Remainder</var>
</descr>
</element>

<!-- range type Visibility: default -->
<element name="TValueSign">
<short>Type indicating sign of a value</short>
</element>

<!-- constant Visibility: default -->
<element name="NegativeValue">
<short>Value is negative</short>
</element>

<!-- constant Visibility: default -->
<element name="ZeroValue">
<short>Value is zero</short>
</element>

<!-- constant Visibility: default -->
<element name="PositiveValue">
<short>Value is positive</short>
</element>

<!-- function Visibility: default -->
<element name="Sign">
<short>Return sign of argument</short>
<descr>
<var>Sign</var> returns the sign of it's argument, which can be an Integer,
64 bit integer, or a double. The returned value is an integer which is -1, 0
or 1, and can be used to do further calculations with.
</descr>
</element>

<!-- function Visibility: default -->
<element name="IsZero">
<short>Check whether value is zero</short>
<descr>
<p>
<var>IsZero</var> checks whether the float value <var>A</var> is zero, up to a 
precision of <var>Epsilon</var>. It returns <var>True</var> if Abs(<var>A</var>) is
less than <var>Epsilon</var>.
</p>
<p>
The default value for <var>Epsilon</var> depends on the type of the
argument: it is 1E-4 for Single, 1E-12 for Double and 1E-16 for extended.
</p>
</descr>
<seealso>
<link id="IsNan"/>
<link id="IsInfinite"/>
<link id="SameValue"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsNan">
<short>Check whether value is Not a Number</short>
<descr>
<var>IsNan</var> returns <var>True</var> if the double <var>d</var> 
contains Not A Number (a value which cannot be represented correctly 
in double format).
</descr>
<seealso>
<link id="IsZero"/>
<link id="IsInfinite"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsInfinite">
<short>Check whether value is infinite</short>
<descr>
<var>IsInfinite</var> returns <var>True</var> if the double <var>d</var> 
contains the infinite value.
</descr>
<seealso>
<link id="IsZero"/>
<link id="IsInfinite"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SameValue">
<short>Check whether 2 float values are the same</short>
<descr>
<p>
<var>SameValue</var> returns <var>True</var> if the floating-point values
<var>A</var> and <var>B</var> are the same, i.e. whether the absolute value
of their their difference is smaller than <var>Epsilon</var>. If their
difference is larger, then <var>False</var> is returned.
</p>
<p>
If unspecified, the default value for <var>Epsilon</var> is 0.0.
</p>
</descr>
<seealso>
<link id="MinFloat"/>
<link id="IsZero"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="arccosh">
<short>Return inverse hyperbolic cosine</short>
<descr>
<p>
<var>arccosh</var> returns the inverse hyperbolic cosine of it's argument 
<var>x</var>.
</p>
<p>
This function is an alias for <link id="arcosh"/>, provided for Delphi
compatibility.
</p>
</descr>
<seealso>
<link id="arcosh"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="arcsinh">
<short>Return inverse hyperbolic sine</short>
<descr>
<p>
<var>arcsinh</var> returns the inverse hyperbolic sine of it's argument 
<var>x</var>.
</p>
<p>
This function is an alias for <link id="arsinh"/>, provided for Delphi
compatibility.
</p>
</descr>
<seealso>
<link id="arsinh"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="arctanh">
<short>Return inverse hyperbolic tangent</short>
<descr>
<p>
<var>arcsinh</var> returns the inverse hyperbolic tangent of it's argument
<var>x</var>.
</p>
<p>
This function is an alias for <link id="artanh"/>, provided for Delphi
compatibility.
</p>
</descr>
<seealso>
<link id="artanh"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPURoundingMode">
<short>Type describing the rounding mode for the Floating Point processor.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmNearest">
<short>Round to nearest integer value, using banker's rounding in case of a tie.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmDown">
<short>Round to biggest integer less than value.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmUp">
<short>Round to smallest integer larger than value.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmTruncate">
<short>Round towards zero, i.e. cut off fractional part.</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPUPrecisionMode">
<short>Type describing the default precision for the Floating Point processor.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmSingle">
<short>Single-type precision</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmReserved">
<short>?</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmDouble">
<short>Double-type precision</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmExtended">
<short>Extended-type precision</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPUException">
<short>Type describing Floating Point processor exceptions.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exInvalidOp">
<short>Invalid operation error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exDenormalized">
<short></short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exZeroDivide">
<short>Division by zero error.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exOverflow">
<short>Float overflow error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exUnderflow">
<short>Float underflow error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exPrecision">
<short>Precision error</short>
</element>

<!-- set type Visibility: default -->
<element name="TFPUExceptionMask">
<short>Type to set the Floating Point Unit exception mask.</short>
</element>

<!-- function Visibility: default -->
<element name="GetRoundMode">
<short>Return the Floating Point Unit rounding mode.</short>
<descr>
</descr>
</element>

<!-- function Visibility: default -->
<element name="SetRoundMode">
<short>Set the Floating Point Unit rounding mode.</short>
<descr>
<p>
<var>SetRoundMode</var> sets the floating point unit rounding mode.
</p>
<dl>
<dt>rmNearest</dt>
<dd><printshort id="#rtl.system.TFPURoundingMode.rmNearest"/></dd>
<dt>rmDown</dt>
<dd><printshort id="#rtl.system.TFPURoundingMode.rmDown"/></dd>
<dt>rmUp</dt>
<dd><printshort id="#rtl.system.TFPURoundingMode.rmUp"/></dd>
<dt>rmTruncate</dt>
<dd><printshort id="#rtl.system.TFPURoundingMode.rmTruncate"/></dd>
</dl>
</descr>
<seealso>
<link id="GetRoundMode"/>
<link id="TFPURoundingMode"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetPrecisionMode">
<short>Return the Floating Point Unit precision mode.</short>
<descr>
</descr>
</element>

<!-- function Visibility: default -->
<element name="SetPrecisionMode">
<short>Set the Floating Point Unit precision mode.</short>
<descr>
</descr>
</element>

<!-- function Visibility: default -->
<element name="GetExceptionMask">
<short>Get the Floating Point Unit exception mask.</short>
<descr>
</descr>
</element>

<!-- function Visibility: default -->
<element name="SetExceptionMask">
<short>Set the Floating Point Unit exception mask.</short>
<descr>
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="ClearExceptions">
<short>Clear Floating Point Unit exceptions</short>
<descr>
</descr>
</element>

<element name="GetSSECSR">
<short>Get MXCSR control word (Intel only)</short>
<descr>
<var>GetSSECSR</var> can be used to get the SSE/SSE2 control DWord.
It is equivalent to the <var>LDMXCSR</var> assembler instruction, and
returns the control dword.
</descr>
</element>

<element name="ifthen">
<short>Return one of two values, depending on a boolean condition</short>
<descr>
<p>
<var>ifthen</var> returns <var>iftrue</var> if <var>val</var> is
<var>True</var>, and <var>iffalse</var> if <var>val</var> is <var>False</var>.
</p>
<p>
This function can be used in expressions.
</p>
</descr>
</element>

<element name="SetSSECSR">
<short>Set MXCSR control word (Intel only)</short>
<descr>
<var>SetSSECSR</var> can be used to set the SSE/SSE2 control DWord.
It is equivalent to the <var>STMXCSR</var> assembler instruction, and stores
<var>w</var> in the control dword.
</descr>
</element>


<!-- unresolved type reference Visibility: default -->
<element name="sysutils">
<short>Exception support</short>
</element>

<!-- function Visibility: default -->
<element name="operator **">
<short>Exponent operator</short>
<descr>
<var>**</var> raises <var>base</var> to the power <var>expt</var>. Both numbers can be floats or 64-bit integers.
</descr>
<errors>
Overflow exceptions can occur.
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="sumInt">
<short>Return the sum of an array of integers</short>
<descr>
<var>SumInt</var> returns the sum of the <var>N</var> integers in the <var>Data</var>
array, where this can be an open array or a pointer to an array.
</descr>
<errors>
An overflow may occur.
</errors>
</element>

<!-- range type Visibility: default -->
<element name="TRoundToRange">
<short>Range with valid range of digits in <var>RoundTo</var></short>
<descr>
<var>TRoundToRange</var> is the range of valid digits to be used in the
<link id="RoundTo"/> function.
</descr>
<seealso>
<link id="RoundTo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RoundTo">
<short>Round to the specified number of digits</short>
<descr>
<var>RoundTo</var> rounds the specified float <var>AValue</var> to the
specified number of digits and returns the result. This result is accurate 
to "10 to the power Digits". It uses the standard <var>Round</var> function
for this.
</descr>
<errors>
An exception may occur if the value <var>AValue</var> is not inside a valid integer (or Int64) range.
</errors>
<seealso>
<link id="TRoundToRange"/>
<link id="SimpleRoundTo"/>
<link id="SetRoundMode"/>
<link id="TFPURoundingMode"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SimpleRoundTo">
<short>Round to the specified number of digits (rounding up if needed)</short>
<descr>
<var>SimpleRoundTo</var> rounds the specified float <var>AValue</var> to the
specified number of <var>digits</var> using symmetric arithmetic rounding (rounding up for positive or down for negative) and returns the result. 
This result is accurate to "10 to the power <var>Digits</var>". It uses the standard <var>Round</var> function
for this.
</descr>
<errors>
An exception may occur if the value <var>AValue</var> is not inside a valid integer (or Int64) range.
</errors>
<seealso>
<link id="TRoundToRange"/>
<link id="RoundTo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="cot">
<short>Alias for <var>Cotan</var></short>
<descr>
<var>cot</var> is an alias for the <link id="cotan"/> function.
</descr>
<seealso>
<link id="cotan"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="secant">
<short>Calculate secant</short>
<descr>
<var>Secant</var> calculates the secant (1/<var>cos(x)</var>) of its argument <var>x</var>.
</descr>
<errors>
If 90 or 270 degrees is specified, an exception will be raised.
</errors>
<seealso>
<link id="cosecant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="cosecant">
<short>Calculate cosecant</short>
<descr>
<var>cosecant</var> calculates the cosecant (1/<var>sin(x)</var>) of its argument
<var>x</var>.
</descr>
<errors>
If 0 or 180 degrees is specified, an exception will be raised.
</errors>
<seealso>
<link id="secant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="sec">
<short>Alias for <var>secant</var></short>
<descr>
<var>sec</var> is an alias for the <link id="secant"/> function.
</descr>
<seealso>
<link id="secant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="csc">
<short>Alias for <var>cosecant</var></short>
<descr>
<var>csc</var> is an alias for the <link id="cosecant"/> function.
</descr>
<seealso>
<link id="cosecant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CompareValue">
<short>Compare 2 values</short>
<descr>
<p>
<var>CompareValue</var> compares 2 integer or floating point values
<var>A</var> and <var>B</var> and returns one of the following values:
</p>
<dl>
<dt>-1</dt><dd>if <var>A&lt;B</var></dd>
<dt>0</dt><dd>if <var>A=B</var></dd>
<dt>1</dt><dd>if <var>A&gt;B</var></dd>
</dl>
</descr>
<seealso>
<link id="TValueRelationship"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RandomRange">
<short>Return a random number in a range</short>
<descr>
<var>RandomRange</var> returns a random value in the range <var>AFrom</var> to
<var>ATo</var>. <var>AFrom</var> and <var>ATo</var> do not need to be in
increasing order. The upper border is not included in the generated value,
but the lower border is.
</descr>
<seealso>
<link id="#rtl.system.Random"/>
<link id="RandomFrom"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RandomFrom">
<short>Return a random element of an array of numbers</short>
<descr>
<var>RandomFrom</var> returns a random element from the array <var>AValues</var>.
The return value has the same type as the type of the array elements.
</descr>
<seealso>
<link id="#rtl.system.Random"/>
<link id="RandomRange"/>
</seealso>
</element>


<!-- function Visibility: default -->
<element name="FutureValue">
<short>Calculate the future value of an investment.</short>
<descr>
<p>
<var>FutureValue</var> calculates the future value of an investment
(<var>FV</var>) in the cash flow formula (see <link id="CashFlowFunctions"/>)
The function result is the future value of an investment of
<var>APresentValue</var> (<var>PV</var>), where <var>APayment</var>
(<var>PMT</var>) is invested for <var>NPeriods</var> (<var>n</var>) at the rate of
<var>ARate</var> (<var>q</var>) per period. 
</p>
<p>
The <var>APaymentTime</var> parameter determines whether the investment (payment) 
is an ordinary annuity or an annuity due: <var>ptEndOfPeriod</var> must be used if 
payments are at the end of each period. If the payments are at the beginning
of the periode, <var>ptStartOfPeriod</var> must be used. 
</p>
</descr>
<seealso>
<link id="InterestRate"/>
<link id="NumberOfPeriods"/>
<link id="Payment"/>
<link id="PresentValue"/>
<link id="TPaymentTime"/>
<link id="CashFlowFunctions"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterestRate">
<short>Calculate the interest rate value of an investment</short>
<descr>
<p>
<var>InterestRate</var> calculates the future value of an investment
(<var>q</var>) in the cash flow formula (see <link id="CashFlowFunctions"/>).
The function result is the interest rate value in case of a future value
<var>AFutureValue</var> for an investment of a start value <var>APresentValue</var> 
(<var>PV</var>), where <var>APayment</var> (<var>PMT</var>) is invested 
for <var>NPeriods</var> (<var>n</var>).
</p>
<p> 
The <var>APaymentTime</var> parameter determines whether the investment
(payment) is an ordinary annuity or an annuity due: <var>ptEndOfPeriod</var> 
must be used if payments are at the end of each period. If the payments are at the beginning
of the periode, <var>ptStartOfPeriod</var> must be used. 
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FutureValue"/>
<link id="NumberOfPeriods"/>
<link id="Payment"/>
<link id="PresentValue"/>
<link id="TPaymentTime"/>
<link id="CashFlowFunctions"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="NumberOfPeriods">
<short>Calculate the number of periods for an investment</short>
<descr>
<p>
<var>NumberOfPeriods</var> calculates the number of periods (<var>n</var>)
needed to obtain future value of an investment  in the cash flow formula (see <link
id="CashFlowFunctions"/>).
The function result is the number of periods a payment
<var>APayment</var> (<var>PMT</var>) must be paid in order to obtain a future value
<var>AFutureValue</var> for an investment of a start value <var>APresentValue</var>
(<var>PV</var>), where <var>APayment</var> (<var>PMT</var>) is invested
at a rate <var>ARate</var> (<var>q</var>).
</p>
<p> 
The <var>APaymentTime</var> parameter determines whether the investment
(payment) is an ordinary annuity or an annuity due: <var>ptEndOfPeriod</var>
NumberOfPeriods must be used if payments are at the end of each period. If the payments are
at the beginning
of the periode, <var>ptStartOfPeriod</var> must be used.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FutureValue"/>
<link id="InterestRate"/>
<link id="Payment"/>
<link id="PresentValue"/>
<link id="TPaymentTime"/>
<link id="CashFlowFunctions"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Payment">
<short>Calculate the payment for an investment</short>
<descr>
<p>
<var>Payment</var> calculates the amount that must be payed (<var>PMT</var>)
during number of periods (<var>n</var>) needed to obtain future value of an 
investment in the cash flow formula (see <link id="CashFlowFunctions"/>).
The function result is the amount (<var>PMT</var>) that must be paid in order to obtain a
future value <var>AFutureValue</var> for an investment of a start value
<var>APresentValue</var> (<var>PV</var>), where the amount must be payed
<var>NPeriods</var> (<var>PMT</var>) and the interest rate is<var>ARate</var> (<var>q</var>).
</p>
<p>
The <var>APaymentTime</var> parameter determines whether the investment
(payment) is an ordinary annuity or an annuity due: <var>ptEndOfPeriod</var>
NumberOfPeriods must be used if payments are at the end of each period. If
the payments are
at the beginning
of the periode, <var>ptStartOfPeriod</var> must be used.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FutureValue"/>
<link id="InterestRate"/>
<link id="NumberOfPeriods"/>
<link id="PresentValue"/>
<link id="TPaymentTime"/>
<link id="CashFlowFunctions"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="PresentValue">
<short>Calculate the present value given the future value of an investment.</short>
<descr>
<p>
<var>PresentValue</var> calculates the present (start) value of an investment
(<var>PV</var>) in the cash flow formula (see <link id="CashFlowFunctions"/>)
The function result is the start value of an investment, when the future
value is <var>AFutureValue</var> (<var>FV</var>) and  <var>APayment</var>
(<var>PMT</var>) is invested for <var>NPeriods</var> (<var>n</var>) at the rate of
<var>ARate</var> (<var>q</var>) per period. 
</p>
<p>
The <var>APaymentTime</var> parameter determines whether the investment (payment) 
is an ordinary annuity or an annuity due: <var>ptEndOfPeriod</var> must be used if 
payments are at the end of each period. If the payments are at the beginning
of the periode, <var>ptStartOfPeriod</var> must be used. 
</p>
</descr>
<seealso>
<link id="FutureValue"/>
<link id="InterestRate"/>
<link id="NumberOfPeriods"/>
<link id="Payment"/>
<link id="TPaymentTime"/>
<link id="CashFlowFunctions"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DegNormalize">
<short>Normalize an angle measured in degrees</short>
<descr>
<var>DegNormalize</var> returns the angle <var>deg</var> as a positive angle between
<var>0</var> and <var>360</var> degrees.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="MinSingle">
<short>Minimum value for single values</short>
<descr>
<var>MinSingle</var> is the smallest value for single-type variables.
</descr>
<seealso>
<link id="MaxSingle"/>
<link id="MinDouble"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MaxSingle">
<short>Maximum value for single values</short>
<descr>
<var>MaxSingle</var> is the largest value for single-type variables.
</descr>
<seealso>
<link id="MinSingle"/>
<link id="MinDouble"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MinDouble">
<short>Minimum value for double values</short>
<descr>
<var>MinDouble</var> is the smallest value for double-type variables.
</descr>
<seealso>
<link id="MaxDouble"/>
<link id="MinSingle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MaxDouble">
<short>Maximum value for double values</short>
<descr>
<var>MaxDouble</var> is the largest value for double-type variables.     
</descr>
<seealso>
<link id="MinDouble"/>      
<link id="MaxSingle"/>  
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MinComp">
<short>Minimum value for comp values</short>
<descr>
<var>MinComp</var> is the smallest value for comp-type variables.
</descr>
<seealso>
<link id="MaxComp"/>
<link id="MinSingle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MaxComp">
<short>Maximum value for comp values</short>
<descr>
<var>MaxComp</var> is the largest value for comp-type variables.       
</descr>
<seealso>
<link id="MinComp"/>
<link id="MaxSingle"/>
</seealso>
</element>

<!-- operator Visibility: default -->
<element name="power(Float,Float):Float">
<short>Raise base to the power exponent</short>
<descr>
<var>Power</var> raises <var>base</var> to the power <var>exponent</var>,
i.e., it calculates <var>base^exponent</var>.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="power(Int64,Int64):Int64">
<short>Raise base to the power exponent</short>
<descr>
<var>Power</var> raises <var>base</var> to the power <var>exponent</var>,
i.e., it calculates <var>base^exponent</var>.
</descr>
</element>

<!-- function Visibility: default -->
<element name="ceil64">
<short>Round to the nearest bigger int64 value</short>
<descr>
<var>Ceil64</var> rounds the value <var>X</var>to the nearest bigger int64
value. The result is always bigger than <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ceil"/>
<link id="floor64"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="floor64">
<short>Round to the nearest smaller int64 value</short>
<descr>
<var>Floor64</var> rounds the value <var>X</var>to the nearest smaller int64  
value. The result is always smaller than <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="floor"/>
<link id="ceil64"/>
</seealso>
</element>

<element name="FMod">
<short>Floatin point modulo</short>
<descr>
<p>
<var>FMod</var> is the floating-point equivalent of the modulo operation <var>a mod b</var>.
It returns the result of
</p>
<p>
<var>
a-b * Int(a/b)
</var>
</p>
</descr>
<errors>
<var>b</var> may not be zero, but no check is performed.
</errors>
</element>

<!-- operator Visibility: default -->
<element name="modulus(Float,Float):Float">
<short>Floating point modulo</short>
<descr>
<p>
<var>Modulus</var> is the floating-point equivalent of the modulo operation <var>a mod b</var>.
It returns the result of
</p>
<p>
<var>
a-b * Int(a/b)
</var>
</p>
</descr>
<errors>
<var>b</var> may not be zero, but no check is performed.
</errors>
<seealso>
<link id="FMod"/>
</seealso>
</element>

</module>
</package>
</fpdoc-descriptions>
