<?xml version="1.0" encoding="ISO8859-1"?>
<fpdoc-descriptions>
<!--  

   $Id: system.xml,v 1.6 2005/05/07 09:41:09 michael Exp $ 
   This file is part of the FPC documentation. 
   Copyright (C) 1997, by Michael Van Canneyt 
 
   The FPC documentation is free text; you can redistribute it and/or 
   modify it under the terms of the GNU Library General Public License as 
   published by the Free Software Foundation; either version 2 of the 
   License, or (at your option) any later version. 
 
   The FPC Documentation is distributed in the hope that it will be useful, 
   but WITHOUT ANY WARRANTY; without even the implied warranty of 
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   Library General Public License for more details. 
 
   You should have received a copy of the GNU Library General Public 
   License along with the FPC documentation; see the file COPYING.LIB.  If not, 
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA. 
 -->
<package name="rtl">
<module name="system">
<short>The system unit</short>
<!-- \FPCexampledir{refex} -->
<descr>
<p>
The system unit contains the standard supported functions of Free Pascal. It is the
same for all platforms. Basically it is the same as the system unit provided
with Borland or Turbo Pascal.
</p>
<p>
Functions are listed in alphabetical order. Arguments of functions or
procedures that are optional are put between square brackets.
</p>
<p>
The pre-defined constants and variables are listed in the first section.
The second section contains an overview of all functions, grouped by
functionality, and the last section contains the supported functions
and procedures.
</p>
</descr>

<topic name="RuntimeErrors">
<short>Run-Time Error behaviour</short>
<descr>
<p>
The sytem unit handles errors by default by generating a run-time error, and
halting the program with an exit code equal to the run-time error number.
</p>
<p>
This behaviour changes when the <link id="#rtl.sysutils">SysUtils</link>
unit is used. In that case, all run-time errors are converted to exceptions:
most run-time errors have their own exception class.
</p>
<p>
If these exceptions are caught, the program code decides what to do with it.
If the exception is not caught, the program will exit through the default
exception handler.
</p>
<p>
When the system unit documentation refers to run-time errors, the above
should be kept in mind.
</p>
</descr>
</topic>

<topic name="FileFunctions">
<short>File handling functions</short>
<descr>
<p>
Functions concerning input and output from and to file.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Append"/></td><td>Open a file in append mode</td></tr>
<tr><td><link id="Assign"/></td><td>Assign a name to a file</td></tr>
<tr><td><link id="Blockread"/></td><td>Read data from a file into memory</td></tr>
<tr><td><link id="Blockwrite"/></td><td>Write data from memory to a file</td></tr>
<tr><td><link id="Close"/></td><td>Close a file</td></tr>
<tr><td><link id="Eof"/></td><td>Check for end of file</td></tr>
<tr><td><link id="Eoln"/></td><td>Check for end of line</td></tr>
<tr><td><link id="Erase"/></td><td>Delete  file from disk</td></tr>
<tr><td><link id="Filepos"/></td><td>Position in file</td></tr>
<tr><td><link id="Filesize"/></td><td>Size of file</td></tr>
<tr><td><link id="Flush"/></td><td>Write file buffers to disk</td></tr>
<tr><td><link id="IOresult"/></td><td>Return result of last file IO operation</td></tr>
<tr><td><link id="Read"/></td><td>Read from file into variable</td></tr>
<tr><td><link id="Readln"/></td><td>Read from file into variable and goto next line</td></tr>
<tr><td><link id="Rename"/></td><td>Rename file on disk</td></tr>
<tr><td><link id="Reset"/></td><td>Open file for reading</td></tr>
<tr><td><link id="Rewrite"/></td><td>Open file for writing</td></tr>
<tr><td><link id="Seek"/></td><td>Set file position</td></tr>
<tr><td><link id="SeekEof"/></td><td>Set file position to end of file</td></tr>
<tr><td><link id="SeekEoln"/></td><td>Set file position to end of line</td></tr>
<tr><td><link id="SetTextBuf"/></td><td>Set size of file buffer</td></tr>
<tr><td><link id="Truncate"/></td><td>Truncate the file at position</td></tr>
<tr><td><link id="Write"/></td><td>Write variable to file</td></tr>
<tr><td><link id="WriteLn"/></td><td>Write variable to file and append newline</td></tr>
</table>
</descr>
</topic>

<topic name="MemoryFunctions">
<short>Memory management functions</short>
<descr>
<p>
Functions concerning memory issues.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Addr"/></td><td>Return address of variable</td></tr>
<tr><td><link id="Assigned"/></td><td>Check if a pointer is valid</td></tr>
<tr><td><link id="CompareByte"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareChar"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareDWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CSeg"/></td><td>Return code segment</td></tr>
<tr><td><link id="Dispose"/></td><td>Free dynamically allocated memory</td></tr>
<tr><td><link id="DSeg"/></td><td>Return data segment</td></tr>
<tr><td><link id="FillByte"/></td><td>Fill memory region with 8-bit pattern</td></tr>
<tr><td><link id="FillChar"/></td><td>Fill memory region with certain character</td></tr>
<tr><td><link id="FillDWord"/></td><td>Fill memory region with 32-bit pattern</td></tr>
<tr><td><link id="FillQWord"/></td><td>Fill memory region with 64-bit pattern</td></tr>
<tr><td><link id="FillWord"/></td><td>Fill memory region with 16-bit pattern</td></tr>
<tr><td><link id="Freemem"/></td><td>Release allocated memory</td></tr>
<tr><td><link id="Getmem"/></td><td>Allocate new memory</td></tr>
<tr><td><link id="GetMemoryManager"/></td><td>Return current memory manager</td></tr>
<tr><td><link id="High"/></td><td>Return highest index of open array or enumerated</td></tr>
<tr><td><link id="IndexByte"/></td><td>Find byte-sized value in a memory range</td></tr>
<tr><td><link id="IndexChar"/></td><td>Find char-sized value in a memory range</td></tr>
<tr><td><link id="IndexDWord"/></td><td>Find DWord-sized (32-bit) value in a memory range</td></tr>
<tr><td><link id="IndexQWord"/></td><td>Find QWord-sized value in a memory range</td></tr>
<tr><td><link id="IndexWord"/></td><td>Find word-sized value in a memory range</td></tr>
<tr><td><link id="IsMemoryManagerSet"/></td><td>Is the memory manager set</td></tr>
<tr><td><link id="Low"/></td><td>Return lowest index of open array or enumerated</td></tr>
<tr><td><link id="Move"/></td><td>Move data from one location in memory to another</td></tr>
<tr><td><link id="MoveChar0">MoveChar0</link></td><td>Move data till first zero character</td></tr>
<tr><td><link id="New"/></td><td>Dynamically allocate memory for variable</td></tr>
<tr><td><link id="Ofs"/></td><td>Return offset of variable</td></tr>
<tr><td><link id="Ptr"/></td><td>Combine segment and offset to pointer</td></tr>
<tr><td><link id="ReAllocMem"/></td><td>Resize a memory block on the heap</td></tr>
<tr><td><link id="Seg"/></td><td>Return segment</td></tr>
<tr><td><link id="SetMemoryManager"/></td><td>Set a memory manager</td></tr>
<tr><td><link id="Sptr"/></td><td>Return current stack pointer</td></tr>
<tr><td><link id="SSeg"/></td><td>Return stack segment register value</td></tr>
</table>
</descr>
</topic>

<topic name="MathematicalFunctions">
<short>Mathematical routines</short>
<descr>
<p>
Functions connected to calculating and coverting numbers.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Abs"/></td><td>Calculate absolute value</td></tr>
<tr><td><link id="Arctan"/></td><td>Calculate inverse tangent</td></tr>
<tr><td><link id="Cos"/></td><td>Calculate cosine of angle</td></tr>
<tr><td><link id="Dec"/></td><td>Decrease value of variable</td></tr>
<tr><td><link id="Exp"/></td><td>Exponentiate</td></tr>
<tr><td><link id="Frac"/></td><td>Return fractional part of floating point value</td></tr>
<tr><td><link id="Hi"/></td><td>Return high byte/word of value</td></tr>
<tr><td><link id="Inc"/></td><td>Increase value of variable</td></tr>
<tr><td><link id="Int"/></td><td>Calculate integer part of floating point value</td></tr>
<tr><td><link id="Ln"/></td><td>Calculate logarithm</td></tr>
<tr><td><link id="Lo"/></td><td>Return low byte/word of value</td></tr>
<tr><td><link id="Odd"/></td><td>Is a value odd or even ?</td></tr>
<tr><td><link id="Pi"/></td><td>Return the value of pi</td></tr>
<tr><td><link id="Random"/></td><td>Generate random number</td></tr>
<tr><td><link id="Randomize"/></td><td>Initialize random number generator</td></tr>
<tr><td><link id="Round"/></td><td>Round floating point value to nearest integer number</td></tr>
<tr><td><link id="Sin"/></td><td>Calculate sine of angle</td></tr>
<tr><td><link id="Sqr"/></td><td>Calculate the square of a value</td></tr>
<tr><td><link id="Sqrt"/></td><td>Calculate the square root of a value</td></tr>
<tr><td><link id="Swap"/></td><td>Swap high and low bytes/words of a variable</td></tr>
<tr><td><link id="Trunc"/></td><td>Truncate a floating point value</td></tr>
</table>
</descr>
</topic>

<topic name="StringFunctions">
<short>String handling</short>
<descr>
<p>
All things connected to string handling.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="BinStr"/></td><td>Construct binary representation of integer</td></tr>
<tr><td><link id="Chr"/></td><td>Convert ASCII code to character</td></tr>
<tr><td><link id="Concat"/></td><td>Concatenate two strings</td></tr>
<tr><td><link id="Copy"/></td><td>Copy part of a string</td></tr>
<tr><td><link id="Delete"/></td><td>Delete part of a string</td></tr>
<tr><td><link id="HexStr"/></td><td>Construct hexadecimal representation of integer</td></tr>
<tr><td><link id="Insert"/></td><td>Insert one string in another</td></tr>
<tr><td><link id="Length"/></td><td>Return length of string</td></tr>
<tr><td><link id="Lowercase"/></td><td>Convert string to all-lowercase</td></tr>
<tr><td><link id="OctStr"/></td><td>Construct octal representation of integer</td></tr>
<tr><td><link id="Pos"/></td><td>Calculate position of one string in another</td></tr>
<tr><td><link id="SetLength"/></td><td>Set length of a string</td></tr>
<tr><td><link id="SetString"/></td><td>Set contents and length of a string</td></tr>
<tr><td><link id="Str"/></td><td>Convert number to string representation</td></tr>
<tr><td><link id="StringOfChar"/></td><td>Create string consisting of a number of characters</td></tr>
<tr><td><link id="Upcase"/></td><td>Convert string to all-uppercase</td></tr>
<tr><td><link id="Val"/></td><td>Convert string to number</td></tr>
</table>
</descr>
</topic>

<topic name="OSfunctions">
<short>Operating System functions</short>
<descr>
<p>
Functions that are connected to the operating system.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Chdir"/></td><td>Change working directory</td></tr>
<tr><td><link id="Getdir"/></td><td>Return current working directory</td></tr>
<tr><td><link id="Halt"/></td><td>Halt program execution</td></tr>
<tr><td><link id="Paramcount"/></td><td>Number of parameters with which program was called</td></tr>
<tr><td><link id="Paramstr"/></td><td>Retrieve parameters with which program was called</td></tr>
<tr><td><link id="Mkdir"/></td><td>Make a directory</td></tr>
<tr><td><link id="Rmdir"/></td><td>Remove a directory</td></tr>
<tr><td><link id="Runerror"/></td><td>Abort program execution with error condition</td></tr>
</table>
</descr>
</topic>

<topic name="MiscellaneousFunctions">
<short>Miscellaneous functions</short>
<descr>
<p>
Functions that do not belong in one of the other categories.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Assert"/></td><td>Conditionally abort program with error</td></tr>
<tr><td><link id="Break"/></td><td>Abort current loop</td></tr>
<tr><td><link id="Continue"/></td><td>Next cycle in current loop</td></tr>
<tr><td><link id="Exclude"/></td><td>Exclude an element from a set</td></tr>
<tr><td><link id="Exit"/></td><td>Exit current function or procedure</td></tr>
<tr><td><link id="Include"/></td><td>Include an element into a set</td></tr>
<tr><td><link id="LongJmp"/></td><td>Jump to execution point</td></tr>
<tr><td><link id="Ord"/></td><td>Return ordinal value of enumerated type</td></tr>
<tr><td><link id="Pred"/></td><td>Return previous value of ordinal type</td></tr>
<tr><td><link id="SetJmp"/></td><td>Mark execution point for jump</td></tr>
<tr><td><link id="SizeOf"/></td><td>Return size of variable or type</td></tr>
<tr><td><link id="Succ"/></td><td>Return next value of ordinal type</td></tr>
</table>
</descr>
</topic>

<topic name="UnicodeSupport">
<short>Unicode and codepage support</short>
<descr>
<p>
The system unit works with Short-, Ansi-, and UnicodeString routines for all
string related operations. 
</p>
<p>
Ansistrings are code-page aware, which means that code page information is associated
with them. For most routines, the support for converting these code pages is natural. 
For some routines, care must be taken when converting from codepage-aware
strings to widestring.
</p>
<p>
The codepage conversion support is influenced by the following variables:
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="DefaultSystemCodePage"/></td><td>Actual code page to use when <link id="CP_ACP"/> is encountered</td></tr>
<tr><td><link id="DefaultUnicodeCodePage"/></td><td>Code page for new unicode strings</td></tr>
<tr><td><link id="DefaultFileSystemCodePage"/></td><td>Codepage to use when sending strings to single-byte OS filesystem routines.</td></tr>
<tr><td><link id="DefaultRTLFileSystemCodePage"/></td><td>Codepage to use when receiving strings from single-byte OS filesystem routines.</td></tr>
</table>
<p>
The windows code page identifiers are used. There are 3 special codepage identifiers:
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="CP_ACP"/></td><td>Currently set default syststem cpdepage</td></tr>
<tr><td><link id="CP_OEMCP"/></td><td>OEM (console)  code page (only on windows)</td></tr>
<tr><td><link id="CP_NONE"/></td><td>Indicates absence of code page information for a string</td></tr>
<tr><td><link id="DefaultRTLFileSystemCodePage"/></td><td></td></tr>
</table>
<p>
The following routines may perform code page conversions:
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="LowerCase"/></td><td><printshort id="LowerCase"/></td></tr>
<tr><td><link id="UpCase"/></td><td><printshort id="UpCase"/></td></tr>
<tr><td><link id="GetDir"/></td><td><printshort id="GetDir"/></td></tr>
<tr><td><link id="MkDir"/></td><td><printshort id="MkDir"/></td></tr>
<tr><td><link id="ChDir"/></td><td><printshort id="ChDir"/></td></tr>
<tr><td><link id="RmDir"/></td><td><printshort id="RmDir"/></td></tr>
<tr><td><link id="Assign"/></td><td><printshort id="Assign"/></td></tr>
<tr><td><link id="Erase"/></td><td><printshort id="Erase"/></td></tr>
<tr><td><link id="Rename"/></td><td><printshort id="Rename"/></td></tr>
<tr><td><link id="Read"/></td><td><printshort id="Read"/></td></tr>
<tr><td><link id="ReadLn"/></td><td><printshort id="ReadLn"/></td></tr>
<tr><td><link id="Write"/></td><td><printshort id="Write"/></td></tr>
<tr><td><link id="WriteLn"/></td><td><printshort id="WriteLn"/></td></tr>
<tr><td><link id="ReadStr"/></td><td><printshort id="ReadStr"/></td></tr>
<tr><td><link id="WriteStr"/></td><td><printshort id="WriteStr"/></td></tr>
<tr><td><link id="Insert"/></td><td><printshort id="Insert"/></td></tr>
<tr><td><link id="Copy"/></td><td><printshort id="Copy"/></td></tr>
<tr><td><link id="Delete"/></td><td><printshort id="Delete"/></td></tr>
<tr><td><link id="SetString"/></td><td><printshort id="Setstring"/></td></tr>
</table>
<p>
All these routines exist also in Unicode versions.
</p>
<p>
Note that for conversion of codepages and unicode strings, a unicode manager
must be present. On windows, the system is used for this. On Unix, one of
the fpwidestring or cwstring units must be used. 
</p>
</descr>
</topic>

<element name="Abs">
<short>Calculate absolute value</short>
<descr>
<var>Abs</var> returns the absolute value of a variable. The result of the
function has the same type as its argument, which can be any numerical
type.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
</seealso>
<example file="refex/ex1"/>
</element>



<element name="Addr">
<short>Return address of a variable</short>
<descr>
<var>Addr</var> returns a pointer to its argument, which can be any type, or a
function or procedure name. The returned pointer isn't typed.
The same result can be obtained by the <var>@</var> operator, which can return a
typed pointer (see the programmer's guide).
</descr>
<errors>
None
</errors>
<seealso>
<link id="SizeOf"/>
</seealso>
<example file="refex/ex2"/>
</element>



<element name="Append">
<short>Open a file in append mode</short>
<descr>
<var>Append</var> opens an existing file in append mode. Any data written to
<var>F</var> will be appended to the file. Only text files can be opened in
append mode. After a call to <var>Append</var>, the file <var>F</var> becomes
write-only.

File sharing is not taken into account when calling <var>Append</var>.

</descr>
<errors>
If the file doesn't exist when appending, a run-time error will be generated.
This behaviour has changed on Windows and Linux platforms, where in versions
prior to 1.0.6, the file would be created in append mode.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Close"/>
<link id="Reset"/>
</seealso>
<example file="refex/ex3"/>
</element>



<element name="Arctan">
<short>Calculate inverse tangent</short>
<descr>
<var>Arctan</var> returns the Arctangent of <var>X</var>, which can be any Real type.
The resulting angle is in radial units.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Sin"/>
<link id="Cos"/>
</seealso>
<example file="refex/ex4"/>
</element>



<element name="Assert">
<short>Check validity of a given condition.</short>
<descr>
With assertions on, <var>Assert</var> tests if <var>expr</var> is 
false, and if so, aborts the application with a Runtime error 
227 and an optional error message in <var>msg</var>.
If <var>expr</var> is true, program execution continues normally. 

If assertions are not enabled at compile time, this routine does 
nothing, and no code is generated for the <var>Assert</var> call. 

Enabling and disabling assertions at compile time is done via
the <var>\$C</var> or <var>\$ASSERTIONS</var> compiler switches. These are
global switches.

The default behavior of the assert call can be changed by 
setting a new handler in the <var>AssertErrorProc</var> variable.
Sysutils overrides the default handler to raise a <var>EAssertionFailed</var> 
exception.


</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
<link id="Runerror"/>
</seealso>
</element>


<element name="Assign">
<short>Assign a name to a file</short>
<descr>
<var>Assign</var> assigns a name to <var>F</var>, which can be any file type.
This call doesn't open the file, it just assigns a name to a file variable,
and marks the file as closed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex5"/>
</element>



<element name="Assigned">
<short>Check if a pointer is valid</short>
<descr>
<var>Assigned</var> returns <var>True</var> if <var>P</var> is non-nil
and retuns <var>False</var> of <var>P</var> is nil.
The main use of Assigned is that Procedural variables, method variables and
class-type variables also can be passed to <var>Assigned</var>.
</descr>
<errors>
None
</errors>
<seealso>
<link id="New"/>
</seealso>
<example file="refex/ex96"/>
</element>



<element name="BinStr">
<short>Convert integer to string with binary representation.</short>
<descr>
<var>BinStr</var> returns a string with the binary representation
of <var>Value</var>. The string has at most <var>cnt</var> characters.
(i.e. only the <var>cnt</var> rightmost bits are taken into account)
To have a complete representation of any longint-type value, 32
bits are needed, i.e. <var>cnt=32</var>

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="HexStr"/>
<link id="OctStr"/>
</seealso>
<example file="refex/ex82"/>
</element>



<element name="Blockread">
<short>Read data from an untyped file into memory</short>
<descr>
<var>Blockread</var> reads <var>count</var> or less records from file <var>F</var>. A
record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

The result is placed in <var>Buffer</var>, which must contain enough room for
<var>Count</var> records. The function cannot read partial records.
If <var>Result</var> is specified, it contains the number of records actually
read. If <var>Result</var> isn't specified, and less than <var>Count</var> records were
read, a run-time error is generated. This behavior can be controlled by the
<var>{$I}</var> switch.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockwrite"/>
<link id="Close"/>
<link id="Reset"/>
<link id="Assign"/>
</seealso>
<example file="refex/ex6"/>
</element>



<element name="Blockwrite">
<short>Write data from memory to an untyped file</short>
<descr>
<var>BlockWrite</var> writes <var>count</var> records from <var>buffer</var> to the file
 <var>F</var>.A record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

If the records couldn't be written to disk, a run-time error is generated.
This behavior can be controlled by the <var>{$I}</var> switch.

</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockread"/>
<link id="Close"/>
<link id="Rewrite"/>
<link id="Assign"/>
</seealso>
</element>

For the example, see <link id="Blockread"/>.

<element name="Break">
<short>Exit current loop construct.</short>
<descr>
<p>
<var>Break</var> jumps to the statement following the end of the current
repetitive statement. The code between the <var>Break</var> call and
the end of the repetitive statement is skipped.
The condition of the repetitive statement is NOT evaluated.
</p>
<p>
This can be used with <var>For</var>, var{repeat} and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Break</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Continue"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex87"/>
</element>



<element name="Chdir">
<short>Change current working directory.</short>
<descr>
<var>Chdir</var> changes the working directory of the process to <var>S</var>.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Mkdir"/>
<link id="Rmdir"/>
</seealso>
<example file="refex/ex7"/>
</element>



<element name="Chr">
<short>Convert byte value to character value</short>
<descr>
<p>
<var>Chr</var> returns the character which has ASCII value <var>X</var>.
</p>
<p>
Historical note:
</p>
<p>
Originally, Pascal did not have typecasts and chr was a necessary function in
order to do certain operations on ASCII values of characters. With the arrival of
typecasting a generic approach became possible, making chr mostly obselete.
However, chr is not considered deprecated and remains in wide use today.
</p></descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Str"/>
</seealso>
<example file="refex/ex8"/>
</element>



<element name="Close">
<short>Close a file</short>
<descr>
<var>Close</var> flushes the buffer of the file <var>F</var> and closes <var>F</var>.
After a call to <var>Close</var>, data can no longer be read from or written to
<var>F</var>.
To reopen a file closed with <var>Close</var>, it isn't necessary to assign the
file again. A call to <link id="Reset"/> or <link id="Rewrite"/> is sufficient.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Flush"/>
</seealso>
<example file="refex/ex9"/>
</element>

<element name="CompareByte">
<short>Compare 2 memory buffers byte per byte</short>
<descr>
<p><var>CompareByte</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
byte-per-byte basis for a total of <var>len</var> bytes.
</p>
<p>The function returns one of the following values:</p>
<dl><dt>less than 0</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is smaller in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.</dd>
<dt>0</dt><dd>if the first <var>len</var> bytes in <var>buf1</var> and <var>buf2</var> are
equal.</dd>
<dt>greater than 0</dt><dd>if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is larger in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.</dd></dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareChar0"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex99"/>
</element>



<element name="CompareChar">
<short>ompare 2 memory buffers character per character</short>
<descr>
<p>
<var>CompareChar</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
character-per-character basis for a total of <var>len</var> characters.
</p>
<p>
The <var>CompareChar0</var> variant compares <var>len</var> bytes, or until
a zero character is found.
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is smaller in <var>buf1</var>
than the character at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>if the first <var>len</var> characters in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is larger in
<var>buf1</var> than the character at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareChar0"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex100"/>
</element>



<element name="CompareDWord">
<short>Compare 2 memory buffers DWord per DWord</short>
<descr>
<p>
<var>CompareDWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
DWord-per-DWord basis for a total of <var>len</var> DWords. (A DWord is 4 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is smaller in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>if the first <var>len</var> DWords in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is larger in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareWord"/>,
</seealso>
<example file="refex/ex101"/>
</element>



<element name="CompareWord">
<short>Compare 2 memory buffers word per word</short>
<descr>
<p>
<var>CompareWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
Word-per-Word basis for a total of <var>len</var> Words. (A Word is 2 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is smaller in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>if the first <var>len</var> Words in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>
if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is larger in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareDWord"/>,
</seealso>
<example file="refex/ex102"/>
</element>



<element name="Concat">
<short>Append one string to another.</short>
<descr>
<var>Concat</var> concatenates the strings <var>S1</var>,<var>S2</var> etc. to one long
string. The resulting string is truncated at a length of 255 bytes.
The same operation can be performed with the <var>+</var> operation.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
<link id="Length"/>
</seealso>
<example file="refex/ex10"/>
</element>



<element name="Continue">
<short>Continue with next loop cycle.</short>
<descr>
<p>
<var>Continue</var> jumps to the end of the current repetitive statement.
The code between the <var>Continue</var> call and the end of the repetitive
statement is skipped. The condition of the repetitive statement is then
checked again.
</p>
<p>
This can be used with <var>For</var>, <var>repeat</var> and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Continue</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Break"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex86"/>
</element>




<element name="Copy">
<short>Copy part of a string.</short>
<descr>
<p>
<var>Copy</var> returns a string which is a copy if the <var>Count</var> characters
in <var>S</var>, starting at position <var>Index</var>. If <var>Count</var> is larger than
the length of the string <var>S</var>, the result is truncated.
If <var>Index</var> is larger than the length of the string <var>S</var>, then an
empty string is returned. <var>Index</var> is 1-based.
</p>
<p>
For dynamical arrays, Copy returns a new dynamical array of the same type as
the original one, and copies <var>Count</var> elements from the old array,
starting at position <var>Index</var>. 
</p>
<p>
In Delphi mode, the <var>Count</var> argument can be omitted. In that case, the string (or dynamic
array) is copied from the position <var>Index</var> till the end of the string or array.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex11"/>
</element>



<element name="Cos">
<short>Calculate cosine of angle</short>
<descr>
<var>Cos</var> returns the cosine of <var>X</var>, where X is an angle, in radians.

If the absolute value of the argument is larger than 2^63, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Arctan"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex12"/>
</element>



<element name="CSeg">
<short>Return code segment</short>
<descr>
<var>CSeg</var> returns the Code segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32/64 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex13"/>
</element>



<element name="Dec">
<short>Decrease value of variable</short>
<descr>
<var>Dec</var> decreases the value of <var>X</var> with <var>Decrement</var>.
If <var>Decrement</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
A range check can occur, or an underflow error, if an attempt is made
to decrease <var>X</var> below its minimum value.
</errors>
<seealso>
<link id="Inc"/>
</seealso>
<example file="refex/ex14"/>
</element>



<element name="Delete">
<short>Delete part of a string.</short>
<descr>
<var>Delete</var> removes <var>Count</var> characters from string <var>S</var>, starting
at position <var>Index</var>. All characters after the deleted characters are
shifted <var>Count</var> positions to the left, and the length of the string is adjusted.
</descr>
If sum of <var>Index</var> and <var>Size</var> exceeds length of the string, <var>Delete</var>
removes the end of string starting from <var>Index</var>. If <var>Index</var> is less than 1
or greater than length of the string, or if <var>Size</var> is negative or zero,
<var>Delete</var> does nothing.
<errors>
Shortstring variant's third parameter is called <var>Count</var>, in other overloaded
variants it is called <var>Index</var>
</errors>
<seealso>
<link id="Copy"/>
<link id="Pos"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex15"/>
</element>



<element name="Dispose">
<short>Free dynamically allocated memory</short>
<descr>
<p>
The first form <var>Dispose</var> releases the memory allocated with a call to
<link id="New"/>. The pointer <var>P</var> must be typed. The released memory is
returned to the heap.
</p>
<p>
The second form of <var>Dispose</var> accepts as a first parameter a pointer
to an object type, and as a second parameter the name of a destructor
of this object. The destructor will be called, and the memory allocated
for the object will be freed.
</p>
</descr>
<errors>
An runtime error will occur if the pointer doesn't point to a location in the
heap.
</errors>
<seealso>
<link id="New"/>
<link id="Getmem"/>
<link id="Freemem"/>
</seealso>
<example file="refex/ex16"/>
</element>



<element name="DSeg">
<short>Return data segment</short>
<descr>
<var>DSeg</var> returns the data segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32/64 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex17"/>
</element>



<element name="Eof">
<short>Check for end of file</short>
<descr>
<p>
<var>Eof</var> returns <var>True</var> if the file-pointer has reached the end of the
file, or if the file is empty. In all other cases <var>Eof</var> returns
<var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
</p>
<p>
Note that calling this function may cause your program to wait: to determine
whether you are at EOF, it is necessary to read data. If the file descriptor
is not a real file (for instance for standard input or sockets), then this 
call may seem to hang the program while it is waiting for data to appear or
for the file descriptor to be closed.
</p>
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eoln"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex18"/>
</element>



<element name="Eoln">
<short>Check for end of line</short>
<descr>
<var>EoLn</var> returns <var>True</var> if the file pointer has reached the end of a
line, which is demarcated by a line-feed character (ASCII value 10), or if
the end of the file is reached.
In all other cases <var>EoLn</var> returns <var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
It can only be used on files of type <var>Text</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Eof"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex19"/>
</element>



<element name="Erase">
<short>Delete a file from disk</short>
<descr>
<var>Erase</var> removes an unopened file from disk. The file should be
assigned with <var>Assign</var>, but not opened with <var>Reset</var> or <var>Rewrite</var>
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
</seealso>
<example file="refex/ex20"/>
</element>



<element name="Exclude">
<short>Exlude element from a set if it is present.</short>
<descr>
<p>
<var>Exclude</var> removes <var>E</var> from the set <var>S</var> if it is
included inthe set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S-[E];
Exclude(S,E);
</code>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Include"/>
</seealso>
<example file="refex/ex111"/>
</element>



<element name="Exit">
<short>Exit current subroutine.</short>
<descr>
<p>
<var>Exit</var> exits the current subroutine, and returns control to the calling
routine. If invoked in the main program routine, exit stops the program.
The optional argument <var>X</var> allows to specify a return value, in the case
<var>Exit</var> is invoked in a function. The function result will then be
equal to <var>X</var>.
</p>
<p>
In Object Pascal or Delphi modes, if the <var>Exit</var> statement is
surrounded by one or more <var>Try .. Finally</var> constructs, the
 <var>Finally</var> blocks are
executed, which means that if the finally blocks are used to free resources,
then these resources will also be freed when <var>Exit</var> is called.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
</seealso>
<example file="refex/ex21"/>
</element>


<element name="Exp">
<short>Exponentiate</short>
<descr>
<var>Exp</var> returns the exponent of <var>X</var>, i.e. the number <var>e</var> to the
power <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ln"/>
</seealso>
<example file="refex/ex22"/>
</element>



<element name="Filepos">
<short>Get position in file</short>
<descr>
<var>Filepos</var> returns the current record position of the file-pointer in file
<var>F</var>. It cannot be invoked with a file of type <var>Text</var>. A compiler error
will be generated if this is attempted. Untyped files have a default record
size of 128, if the second parameter to <link id="Reset"/> isn't specified.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filesize"/>
</seealso>
<example file="refex/ex23"/>
</element>



<element name="Filesize">
<short>Size of file</short>
<descr>
<var>Filesize</var> returns the total number of records in file <var>F</var>.
It cannot be invoked with a file of type <var>Text</var>. (under Linux and Unix, this
also means that it cannot be invoked on pipes).
If <var>F</var> is empty, 0 is returned. Untyped files have a default record
size of 128, if the second parameter to <link id="Reset"/> isn't specified.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filepos"/>
</seealso>
<example file="refex/ex24"/>
</element>



<element name="FillByte">
<short>Fill memory region with 8-bit pattern</short>
<descr>
<var>FillByte</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
with value equal to <var>Value</var>.

This is useful for quickly zeroing out a memory location. When the size of
the memory location to be filled out is a multiple of 2 bytes, it is better
 to use <link id="Fillword"/>, and if it is a multiple of 4 bytes it is better
to use <link id="FillDWord"/>, these routines are optimized for their respective sizes.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="FillDWord"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex103"/>
</element>



<element name="Fillchar">
<short>Fill memory region with certain character</short>
<descr>
<var>Fillchar</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
or characters with value equal to <var>Value</var>.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Move"/>
<link id="FillByte"/>
<link id="FillDWord"/>
</seealso>
<example file="refex/ex25"/>
</element>



<element name="FillDWord">
<short>Fill memory region with 32-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> DWords
with value equal to <var>Value</var>. A DWord is 4 bytes in size.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="FillByte"/>
<link id="Fillchar"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex104"/>
</element>



<element name="Fillword">
<short>Fill memory region with 16-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> words
with value equal to <var>Value</var>. A word is 2 bytes in size.
</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="Move"/>
</seealso>
<example file="refex/ex76"/>
</element>



<element name="Flush">
<short>Write file buffers to disk</short>
<descr>
<var>Flush</var> empties the internal buffer of an opened file <var>F</var> and writes the
contents to disk. The file is \textit{not} closed as a result of this call.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Close"/>
</seealso>
<example file="refex/ex26"/>
</element>



<element name="Frac">
<short>Return fractional part of floating point value.</short>
<descr>
<var>Frac</var> returns the non-integer part of <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
<link id="Int"/>
</seealso>
<example file="refex/ex27"/>
</element>



<element name="Freemem">
<short>Release allocated memory</short>
<descr>
<var>Freemem</var> releases the memory occupied by the pointer <var>P</var>, of size
<var>Count</var> (in bytes), and returns it to the heap. <var>P</var> should point to the memory
allocated to a dynamic variable.
</descr>
<errors>
An error will occur when <var>P</var> doesn't point to the heap.
</errors>
<seealso>
<link id="Getmem"/>
<link id="New"/>
<link id="Dispose"/>
</seealso>
<example file="refex/ex28"/>
</element>


<element name="Getdir">
<short>Return the current directory</short>
<descr>
<var>Getdir</var> returns in <var>dir</var> the current directory on the drive
<var>drivenr</var>, where {drivenr} is 1 for the first floppy drive, 3 for the
first hard disk etc. A value of 0 returns the directory on the current disk.
On Linux and Unix systems, <var>drivenr</var> is ignored, as there is only one
directory tree.
</descr>
<errors>
An error is returned under dos, if the drive requested isn't ready.
</errors>
<seealso>
<link id="Chdir"/>
</seealso>
<example file="refex/ex29"/>
</element>



<element name="Getmem">
<short>Allocate new memory on the heap</short>
<descr>
<p>
<var>Getmem</var> reserves <var>Size</var> bytes memory on the heap, and returns a
pointer to this memory in <var>p</var>. What happens if no more memory is available, 
depends on the value of the variable <link id="ReturnNilIfGrowHeapfails"/>:
if the variable is <var>True</var> then <var>Nil</var> is returned. If the
variable is <var>False</var>, a run-time error is generated. The default
value is <var>False</var>, so by default an error is generated.
</p>
<p>
The newly allocated memory is not initialized in any way, and may contain garbage data. It
must be cleared with a call to <link id="FillChar"/> or <link
id="FillWord"/>.
</p>
<p>
For an example, see <link id="Freemem"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Freemem"/>
<link id="Dispose"/>
<link id="New"/>
<link id="returnnilifgrowheapfails"/>
</seealso>
</element>

<element name="GetMemoryManager">
<short>Return current memory manager</short>
<descr>
<p>
<var>GetMemoryManager</var> stores the current Memory Manager record in
<var>MemMgr</var>.
</p>
<p>
For an example, see the programmer's guide.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="IsMemoryManagerSet"/>.
</seealso>
</element>


<element name="Halt">
<short>Stop program execution.</short>
<descr>
<var>Halt</var> stops program execution and returns control to the calling
program. The optional argument <var>Errnum</var> specifies an exit value. If
omitted, zero is returned.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
</seealso>
<example file="refex/ex30"/>
</element>



<element name="HexStr">
<short>Convert integer value to string with hexadecimal representation.</short>
<descr>
<var>HexStr</var> returns a string with the hexadecimal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
 (i.e. only the <var>cnt</var> rightmost nibbles are taken into account)
To have a complete representation of a Longint-type value, 8
nibbles are needed, i.e. <var>cnt=8</var>.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
</seealso>
<example file="refex/ex81"/>
</element>



<element name="Hi">
<short>Return high byte/word/nibble of value.</short>
<descr>
<var>Hi</var> returns the high nibble, byte or word from <var>X</var>, depending on the size
of X. If the size of X is 4, then the high word is returned. If the size is
2 then the high byte is returned. If the size is 1, the high nibble is returned.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Lo"/>
</seealso>
<example file="refex/ex31"/>
</element>



<element name="High">
<short>Return highest index of open array or enumerated</short>
<descr>
<p>
The return value of <var>High</var> depends on it's argument:
</p>
<ol>
<li>If the argument is an ordinal type, <var>High</var> returns the highest
 value in the range of the given ordinal type.
</li>
<li>If the argument is an array type or an array type variable then
<var>High</var> returns the highest possible value of it's index. For
dynamic arrays, it returns the same as <var>Length -1</var>, meaning that it
reports -1 for empty arrays.
</li>
<li>If the argument is an open array identifier in a function or
procedure, then <var>High</var> returns the highest index of the array, as if the
array has a zero-based index. If the array is empty, then -1 is returned.
</li>
<li>If the argument is a set type then it returns the highest value of
the underlying ordinal type.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument
(This can lead to some nasty surprises !).
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Low"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
<example file="refex/ex80"/>
</element>



<element name="Inc">
<short>Increase value of integer variable</short>
<descr>
<var>Inc</var> increases the value of <var>X</var> with <var>Increment</var>.
If <var>Increment</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
If range checking is on, then A range check can occur, or an overflow
error, when an attempt is made to increase <var>X</var> over its maximum value.
</errors>
<seealso>
<link id="Dec"/>
</seealso>
<example file="refex/ex32"/>
</element>



<element name="Include">
<short>Include element in set if it was not yet present.</short>
<descr>
<p>
<var>Include</var> includes <var>E</var> in the set <var>S</var> if it is
not yet part of the set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S+[E];
Include(S,E);
</code>
<p>
For an example, see <link id="Exclude"/>
</p>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Exclude"/>
</seealso>
</element>


<element name="IndexByte">
<short>Search for a byte in a memory range.</short>
<descr>
<var>IndexByte</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the byte <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexChar"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareByte"/>
</seealso>
<example file="refex/ex105"/>
</element>



<element name="IndexChar">
<short>Search for a character in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the character <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based. The <var>IndexChar0</var> variant stops looking if
a null character is found, and returns -1 in that case.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareChar"/>
</seealso>
<example file="refex/ex108"/>
</element>



<element name="IndexDWord">
<short>Search for a DWord value in a memory range.</short>
<descr>
<var>IndexDWord</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the DWord <var>DW</var> and returns it's position if it found one.
If <var>DW</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex106"/>
</element>



<element name="IndexWord">
<short>Search for a WORD value in a memory range.</short>
<descr>
<var>IndexWord</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the Word <var>W</var> and returns it's position if it found one.
If <var>W</var> is not found then -1 is returned.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexChar"/>
<link id="CompareWord"/>
</seealso>
<example file="refex/ex107"/>
</element>



<element name="Insert">
<short>Insert one string in another.</short>
<descr>
<var>Insert</var> inserts string <var>Source</var> in string <var>S</var>, at position
<var>Index</var>, shifting all characters after <var>Index</var> to the right. The
resulting string is truncated at 255 characters, if needed. (i.e. for
shortstrings)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Copy"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex33"/>
</element>



<element name="IsMemoryManagerSet">
<short>Is the memory manager set</short>
<descr>
<var>IsMemoryManagerSet</var> will return <var>True</var> if the memory manager has
been set to another value than the system heap manager, it will return
<var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="GetMemoryManager"/>
</seealso>
</element>

<element name="Int">
<short>Calculate integer part of floating point value.</short>
<descr>
<var>Int</var> returns the integer part of any Real <var>X</var>, as a Real.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Round"/>
</seealso>
<example file="refex/ex34"/>
</element>



<element name="IOresult">
<short>Return result of last file IO operation</short>
<descr>
<p>
IOresult contains the result of any input/output call, when the
<var>{\$i-}</var> compiler directive is active, disabling IO checking.
When the flag is read, it is reset to zero.
If <var>IOresult</var> is zero, the operation completed successfully. If
non-zero, an error occurred. The following errors can occur:
</p>
<p>
dos errors :
</p>
<dl><dt>2</dt><dd>File not found.</dd>
<dt>3</dt><dd>Path not found.</dd>
<dt>4</dt><dd>Too many open files.</dd>
<dt>5</dt><dd>Access denied.</dd>
<dt>6</dt><dd>Invalid file handle.</dd>
<dt>12</dt><dd>Invalid file-access mode.</dd>
<dt>15</dt><dd>Invalid disk number.</dd>
<dt>16</dt><dd>Cannot remove current directory.</dd>
<dt>17</dt><dd>Cannot rename across volumes.</dd>
</dl>
<p>
I/O errors :
</p>
<dl>
<dt>100</dt><dd>Error when reading from disk.</dd>
<dt>101</dt><dd>Error when writing to disk.</dd>
<dt>102</dt><dd>File not assigned.</dd>
<dt>103</dt><dd>File not open.</dd>
<dt>104</dt><dd>File not opened for input.</dd>
<dt>105</dt><dd>File not opened for output.</dd>
<dt>106</dt><dd>Invalid number.</dd>
</dl>
<p>
Fatal errors :
</p>
<dl>
<dt>150</dt><dd>Disk is write protected.</dd>
<dt>151</dt><dd>Unknown device.</dd>
<dt>152</dt><dd>Drive not ready.</dd>
<dt>153</dt><dd>Unknown command.</dd>
<dt>154</dt><dd>CRC check failed.</dd>
<dt>155</dt><dd>Invalid drive specified..</dd>
<dt>156</dt><dd>Seek error on disk.</dd>
<dt>157</dt><dd>Invalid media type.</dd>
<dt>158</dt><dd>Sector not found.</dd>
<dt>159</dt><dd>Printer out of paper.</dd>
<dt>160</dt><dd>Error when writing to device.</dd>
<dt>161</dt><dd>Error when reading from device.</dd>
<dt>162</dt><dd>Hardware failure.</dd>
</dl>
</descr>
<p>
Other errors (run-time errors):
</p>
<dl>
<dt>218</dt><dd>Invalid value specified.</dd>
</dl>
<errors>
None.
</errors>
<seealso>
All I/O functions.
</seealso>
<example file="refex/ex35"/>
</element>



<element name="Length">
<short>Returns length of a string or array.</short>
<descr>
<p>
<var>Length</var> returns the length of the string or array <var>S</var>, which is limited
to 255 for shortstrings. If the string <var>S</var> is empty, 0 is returned.
</p>
<p>
<em>Note:</em> The length of the string <var>S</var> is stored in <var>S[0]</var> for
shortstrings only. The <var>Length</var> function should always be used on 
ansistrings and widestrings.
</p>
<p>
For dynamical or statical arrays, the function returns the number of elements in the
array.
</p>
<p>
<var>Length</var> also supports arguments of type <var>PChar</var>and <var>PWideChar</var>,
in which case it is identical to the <var>StrLen</var> and <var>WStrLen</var> functions, 
respectively. In this case, the function actually calculates the length of
the null-terminated string, and its execution time is proportional to the 
string length because the terminating null character is searched through a linear scan.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Pos"/>
<link id="SetLength"/>
</seealso>
<example file="refex/ex36"/>
</element>



<element name="Ln">
<short>Calculate logarithm</short>
<descr>
<var>Ln</var> returns the natural logarithm of the Real parameter <var>X</var>.
<var>X</var> must be positive.
</descr>
<errors>
An run-time error will occur when <var>X</var> is negative.
</errors>
<seealso>
<link id="Exp"/>
</seealso>
<example file="refex/ex37"/>
</element>



<element name="Lo">
<short>Return low nibble/byte/word of value.</short>
<descr>
<var>Lo</var> returns the low byte of its argument if this is of size 2
(such as <var>Word</var> or <var>SmallInt</var>), or the low nibble if the
size is 1 (such as byte). 
It returns the low word of its argument if this is of type
<var>Longint</var> or <var>Cardinal</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Chr"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex38"/>
</element>



<element name="LongJmp">
<short>Jump to address.</short>
<descr>
<p>
<var>LongJmp</var> jumps to the adress in the <var>env</var> <var>jmp_buf</var>,
and restores the registers that were stored in it at the corresponding
<link id="SetJmp"/> call.
In effect, program flow will continue at the <var>SetJmp</var> call, which will
return <var>value</var> instead of 0. If a <var>value</var> equal to zero is passed,
it will be converted to 1 before passing it on. The call will not return, so it must be
used with extreme care.
This can be used for error recovery, for instance when a segmentation fault
occurred.
</p>
<p>
For an example, see <link id="SetJmp"/>
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetJmp"/>
</seealso>
</element>

<element name="Low">
<short>Return lowest index of open array or enumerated</short>
<descr>
<p>
 The return value of <var>Low</var> depends on it's argument:
</p>
<ol>
<li>If the argument is an ordinal type, <var>Low</var> returns the lowest
value in the range of the given ordinal type.
</li>
<li>If the argument is an array type or an array type variable then
<var>Low</var> returns the lowest possible value of it's index.
</li>
<li>If the argument is an open array identifier in a function or
procedure, then <var>Low</var> returns the lowest element of the array,
which is always zero.
</li>
<li>If the argument is a set type then it returns the lowest value of
the underlying ordinal type.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument.
</p>
<p>
for an example, see <link id="High"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="High"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
</element>

<element name="LowerCase">
<short>Return lowercase version of a string.</short>
<descr>
<p>
<var>Lowercase</var> returns the lowercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
lowercase. The type of the returned value is the same as the type of the
argument.
</p>
<p>
<var>Lowercase</var> does not change the number of characters (or bytes) in
an ansistring.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Upcase"/>
</seealso>
<example file="refex/ex73"/>
</element>




<element name="Mkdir">
<short>Create a new directory.</short>
<descr>
<p>
<var>Mkdir</var> creates a new  directory <var>S</var>.
</p>
<p>
For an example, see <link id="Rmdir"/>.
</p>
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Rmdir"/>
</seealso>
</element>

<element name="Move">
<short>Move data from one location in memory to another</short>
<descr>
<var>Move</var> moves <var>Count</var> bytes from <var>Source</var> to <var>Dest</var>.
</descr>
<errors>
If either <var>Dest</var> or <var>Source</var> is outside the accessible memory for
the process, then a run-time error will be generated.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Fillchar"/>
</seealso>
<example file="refex/ex42"/>
</element>



<element name="MoveChar0">
<short>Move data till first zero character</short>
<descr>
<var>MoveChar0</var> moves <var>Count</var> bytes from <var>buf1</var> to <var>buf2</var>, and
stops moving if a zero character is found.
</descr>
<errors>
No checking is done to see if <var>Count</var> stays within the memory allocated
to the process.
</errors>
<seealso>
<link id="Move"/>
</seealso>
<example file="refex/ex109"/>
</element>



<element name="New">
<short>Dynamically allocate memory for variable</short>
<descr>
<p>
<var>New</var> allocates a new instance of the type pointed to by <var>P</var>, and
puts the address in <var>P</var>.
If P is an object, then it is possible to
specify the name of the constructor with which the instance will be created.
</p>
<p>
The newly allocated memory is not initialized in any way, and may contain garbage data. 
It must be cleared with a call to <link id="FillChar"/> or <link id="FillWord"/>.
</p>
<p>
For an example, see <link id="Dispose"/>.
</p>
</descr>
<errors>
What happens if no more memory is available,
depends on the value of the variable <link id="ReturnNilIfGrowHeapfails"/>:
if the variable is <var>True</var> then <var>Nil</var> is returned. If the
variable is <var>False</var>, a run-time error is generated. 
</errors>
<seealso>
<link id="Dispose"/>
<link id="Freemem"/>
<link id="Getmem"/>
<link id="ReturnNilIfGrowHeapfails"/>
</seealso>
</element>

<element name="Odd">
<short>Is a value odd or even ?</short>
<descr>
<var>Odd</var> returns <var>True</var> if <var>X</var> is odd, or <var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Abs"/>
<link id="Ord"/>
</seealso>
<example file="refex/ex43"/>
</element>



<element name="OctStr">
<short>Convert integer to a string with octal representation.</short>
<descr>
<var>OctStr</var> returns a string with the octal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
<link id="HexStr"/>
</seealso>
<example file="refex/ex112"/>
</element>



<element name="Ofs">
<short>Return offset of a variable.</short>
<descr>
<var>Ofs</var> returns the offset of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always the complete address of the variable, since Free Pascal is a 32/64 bit
compiler.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex44"/>
</element>



<element name="Ord">
<short>Return ordinal value of an ordinal type.</short>
<descr>
<p>
<var>Ord</var> returns the Ordinal value of a ordinal-type variable <var>X</var>.
</p>
<p>
Historical note:
</p><p>
Originally, Pascal did not have typecasts and ord was a necessary function in
order to do certain operations on non-integer ordinal types. With the arrival of
typecasting a generic approach became possible, making ord mostly obselete.
However ord is not considered deprecated and remains in wide use today.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Chr"/>
<link id="Succ"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
<example file="refex/ex45"/>
</element>



<element name="Paramcount">
<short>Return number of command-line parameters passed to the program.</short>
<descr>
<var>Paramcount</var> returns the number of command-line arguments. If no
arguments were given to the running program, <var>0</var> is returned.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramstr"/>
</seealso>
<example file="refex/ex46"/>
</element>



<element name="Paramstr">
<short>Return value of a command-line argument.</short>
<descr>
<p>
<var>Paramstr</var> returns the <var>L</var>-th command-line argument. 
<var>L</var> must be between <var>0</var> and <var>Paramcount</var>, 
these values included. The zeroth argument is the path and file name 
with which the program was started.
</p>
<p>
The command-line parameters will be truncated to a length of 255,
even though the operating system may support bigger command-lines.
The <var>Objpas</var> unit (used in <var>objfpc</var> or <var>delphi</var> mode)
defines versions of <var>Paramstr</var> which return the full-length command-line 
arguments, using ansistrings.
</p>
<p>
In the interest of portability, the <var>ParamStr</var> function tries to behave 
the same on all operating systems: like the original <var>ParamStr</var> function 
in Turbo Pascal. This means even on Unix, paramstr(0) returns the full 
path to the program executable. A notable exception is Mac OS X, where
the return value depends on how the application was started. It may be that 
just the name of the application is returned (in case of a command-line
launch)
</p>
<p>
In general, it's a bad idea to rely on the location of the binary. Often,
this goes against best OS practices. Configuration data should (or can) not
be stored next to the binary, but on designated locations. What locations
these are, is very much operating system dependent. Therefore, 
<var>ParamStr(0)</var> should be used with care.
</p>
<p>
For an example, see <link id="Paramcount"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramcount"/>
</seealso>
</element>

<element name="Pi">
<short>Return the value of PI.</short>
<descr>
<var>Pi</var> returns the value of Pi (3.1415926535897932385).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex47"/>
</element>



<element name="Pos">
<short>Search for substring in a string.</short>
<descr>
<var>Pos</var> returns the index of <var>Substr</var> in <var>S</var>, if <var>S</var> contains
<var>Substr</var>. In case <var>Substr</var> isn't found, <var>0</var> is returned.
The search is case-sensitive.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Length"/>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex48"/>
</element>




<element name="Pred">
<short>Return previous element for an ordinal type.</short>
<descr>
<p>
<var>Pred</var> returns the element that precedes the element that was passed
to it. If it is applied to the first value of the ordinal type, and the
program was compiled with range checking on (<var>{$R+}</var>), then a run-time
error will be generated.
</p>
<p>
For an example, see <link id="Ord"/>
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Succ"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>


<element name="Ptr">
<short>Combine segment and offset to pointer</short>
<descr>
<p>
<var>Ptr</var> returns a pointer, pointing to the address specified by
segment <var>Sel</var> and offset <var>Off</var>.
</p>
<remark>
<ol>
<li>In the 32/64-bit flat-memory model supported by Free Pascal, this
function is obsolete.
</li>
<li>The returned address is simply the offset.
</li>
</ol>
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex59"/>
</element>



<element name="Random">
<short>Generate random number</short>
<descr>
<p>
<var>Random</var> returns a random number larger or equal to <var>0</var> and
strictly less than <var>L</var>.
If the argument <var>L</var> is omitted, a Real number between 0 and 1 is returned
(0 included, 1 excluded).
</p>
<remark>
The Free Pascal implementation of the <var>Random</var> routine uses the
Mersenne Twister to simulate randomness. This implementation has a better
statistical distribution than for example a Linear Congruential generator
algorithm, but is considerably slower than the latter. If speed is an issue, 
then alternate random number generators should be considered. 
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Randomize"/>
</seealso>
<example file="refex/ex49"/>
</element>



<element name="Randomize">
<short>Initialize random number generator</short>
<descr>
<p>
<var>Randomize</var> initializes the random number generator of Free Pascal, by giving
a value to <var>Randseed</var>, calculated with the system clock.
</p>
<p>
For an example, see <link id="Random"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Random"/>
</seealso>
</element>

<element name="Read">
<short>Read from a text file into variable</short>
<descr>
<p>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc.; If no file <var>F</var> is specified, then
standard input is read.
If <var>F</var> is of type <var>Text</var>, then the variables <var>V1, V2</var> etc. must be
of type <var>Char</var>, <var>Integer</var>, <var>Real</var>, <var>String</var>.
If <var>F</var> is a typed file, then each of the variables must be of the type
specified in the declaration of <var>F</var>. Untyped files are not allowed as an
argument.
</p>
<p>
In earlier versions of FPC, it was also allowed to read <var>Pchar</var>
null-terminated strings, but this has been removed, since there is no buffer
checking possible.
</p>
</descr>
<errors>
If no data is available, empty values are returned (0 for ordinal values,
empty strings for string values)
</errors>
<seealso>
<link id="Readln"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
<example file="refex/ex50"/>
</element>



<element name="Readln">
<short>Read from a text file into variable and goto next line</short>
<descr>
<p>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc. After that it goes to the next line in
the file. The end of the line is marked by any of the supported line ending styles,
independent of the platform on which the code is running (supported line
ending styles are CRLF, LF or CR). The end-of-line marker is
not considered part of the line and is ignored.
</p>
<p>
If no file <var>F</var> is specified, then standard input is read.
The variables <var>V1, V2</var> etc. must be of type <var>Char</var>, <var>Integer</var>,
<var>Real</var>, <var>String</var> or <var>PChar</var>.
</p>
<p>
For an example, see <link id="Read"/>.
</p>
</descr>
<errors>
If no data is available, empty values are returned (0 for ordinal values,
empty strings for string values)
</errors>
<seealso>
<link id="Read"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
</element>


<element name="Real2Double">
<short>Convert Turbo Pascal style real to double.</short>
<descr>
<p>
The <var>Real2Double</var> function converts a Turbo Pascal style real (6 bytes long) to
a native Free Pascal double type. It can be used e.g. to read old binary TP files with
FPC and convert them to Free Pacal binary files.
</p>
<p>
Note that the assignment operator has been overloaded so a <var>Real48</var> type
can be assigned directly to a double or extended.
</p>
</descr>
<errors>
None.
</errors>
<seealso></seealso>
<example file="refex/ex110"/>
</element>



<element name="Rename">
<short>Rename file on disk</short>
<descr>
<var>Rename</var> changes the name of the assigned file <var>F</var> to <var>S</var>.
<var>F</var>
must be assigned, but not opened.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Erase"/>
</seealso>
<example file="refex/ex77"/>
</element>



<element name="Reset">
<short>Open file for reading</short>
<descr>
<var>Reset</var> opens a file <var>F</var> for reading. <var>F</var> can be any file type.
If <var>F</var> is a text file, or refers to standard I/O (e.g : '') then it is 
opened read-only, otherwise it is opened using the mode specified in 
<var>filemode</var>.

If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. A default value of 128 is used.

File sharing is not taken into account when calling <var>Reset</var>.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Append"/>
</seealso>
<example file="refex/ex51"/>
</element>



<element name="Rewrite">
<short>Open file for writing</short>
<descr>
<var>Rewrite</var> opens a file <var>F</var> for writing. <var>F</var> can be any file type.
If <var>F</var> is an untyped or typed file, then it is opened for reading and
writing. If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. Default a value of 128 is used.
if <var>Rewrite</var> finds a file with the same name as <var>F</var>, this file is
truncated to length <var>0</var>. If it doesn't find such a file, a new file is
created.

Contrary to Turbo Pascal, Free Pascal opens the file with mode <var>fmoutput</var>. If it should
be opened in <var>fminout</var> mode, an extra call to <link id="Reset"/> is needed.

File sharing is not taken into account when calling <var>Rewrite</var>.

</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Reset"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Flush"/>
<link id="Append"/>
</seealso>
<example file="refex/ex52"/>
</element>



<element name="Rmdir">
<short>Remove directory when empty.</short>
<descr>
<var>Rmdir</var> removes the directory <var>S</var>.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Mkdir"/>
</seealso>
<example file="refex/ex53"/>
</element>



<element name="Round">
<short>Round floating point value to nearest integer number.</short>
<descr>
<p>
<var>Round</var> rounds <var>X</var> to the closest integer, which may be bigger or
smaller than <var>X</var>.
</p>
<p>
In the case of <var>.5</var>, the algorithm uses "banker's rounding": 
<var>.5</var> values are always rounded towards the even number.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Trunc"/>
</seealso>
<example file="refex/ex54"/>
</element>



<element name="Runerror">
<short>Generate a run-time error.</short>
<descr>
<var>Runerror</var> stops the execution of the program, and generates a
run-time error <var>ErrorCode</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
<link id="Halt"/>
</seealso>
<example file="refex/ex55"/>
</element>



<element name="Seek">
<short>Set file position</short>
<descr>
<var>Seek</var> sets the file-pointer for file <var>F</var> to record Nr. <var>Count</var>.
The first record in a file has <var>Count=0</var>. F can be any file type, except
<var>Text</var>. If <var>F</var> is an untyped file, with no record size specified in
<link id="Reset"/> or <link id="Rewrite"/>, 128 is assumed.
</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="SeekEoln"/>
</seealso>
<example file="refex/ex56"/>
</element>



<element name="SeekEof">
<short>Set file position to end of file</short>
<descr>
<p>
<var>SeekEof</var> returns <var>True</var> is the file-pointer is at the end of the
file. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-file marker is
reached.
</p>
<p>
If the end-of-file marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
</p>
<p>
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.
</p>
<remark>
The SeekEOF function can only be used on real textfiles: when assigning the
file to other kinds of (virtual) text files, the function may fail, although
it will perform a number of tests to guard against wrong usage.
</remark>
</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEoln"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex57"/>
</element>



<element name="SeekEoln">
<short>Set file position to end of line</short>
<descr>
<var>SeekEoln</var> returns <var>True</var> is the file-pointer is at the end of the
current line. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-line marker is
reached.
If the end-of-line marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
The end-of-line marker is defined as <var>#10</var>, the LineFeed character.
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.
</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex58"/>
</element>



<element name="Seg">
<short>Return segment</short>
<descr>
<var>Seg</var> returns the segment of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always 0, since Free Pascal uses a flat 32/64 bit
memory model. In such a memory model segments have no meaning.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex60"/>
</element>



<element name="SetMemoryManager">
<short>Set a memory manager</short>
<descr>
<p>
<var>SetMemoryManager</var> sets the current memory manager record to
<var>MemMgr</var>.
</p>
<p>
For an example, see the programmer's guide.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetMemoryManager"/>
<link id="IsMemoryManagerSet"/>
</seealso>
</element>


<element name="SetJmp">
<short>Save current execution point.</short>
<descr>
<var>SetJmp</var> fills <var>env</var> with the necessary data for a jump back to the
point where it was called. It returns zero if called in this way.
If the function returns nonzero, then it means that a call to <link id="LongJmp"/>
with <var>env</var> as an argument was made somewhere in the program.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="LongJmp"/>
</seealso>
<example file="refex/ex79"/>
</element>




<element name="SetLength">
<short>Set length of a string.</short>
<descr>
<p>
<var>SetLength</var> sets the length of the string <var>S</var> to <var>Len</var>. <var>S</var>
can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. For <var>AnsiStrings</var>
it can have any value. For <var>AnsiString</var> strings, <var>SetLength</var>
\emph{must} be used to set the length of the string.
</p>
<p>In the case of a dynamical array <var>A</var>, setlength sets the number
of elements. The elements are numbered from index 0, so the count runs from
0 to <var>Len-1</var>. If Zero is specified, the array is cleared.
</p>
<p>
In case the length is set to a smaller length than the current one, the existing elements
(characters in case of a string) are kept.
</p>
<p>
In case the length is set to a larger length than the current one, the new
elements are zeroed out for a dynamic array. For a string, the string is
zero-terminated at the correct length.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Length"/>
</seealso>
<example file="refex/ex85"/>
</element>



<element name="SetString">
<short>Set length of a string and copy buffer.</short>
<descr>
<var>SetString</var> sets the length of the string <var>S</var> to <var>Len</var> and
if <var>Buf</var> is non-nil, copies <var>Len</var> characters from <var>Buf</var> 
into <var>S</var>.  <var>S</var> can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
</element>



<element name="SetTextBuf">
<short>Set size of text file internal buffer</short>
<descr>
<p>
<var>SetTextBuf</var> assigns an I/O buffer to a text file. The new buffer is
located at <var>Buf</var> and is <var>Size</var> bytes long. If <var>Size</var> is omitted,
then <var>SizeOf(Buf)</var> is assumed.
The standard buffer of any text file is 128 bytes long. For heavy I/O
operations this may prove too slow. The <var>SetTextBuf</var> procedure allows
to set a bigger buffer for the I/O of the application, thus reducing the number of
system calls, and thus reducing the load on the system resources.
The maximum size of the newly assigned buffer is 65355 bytes.
</p>
<remark>
<ul>
<li>Never assign a new buffer to an opened file. A
new buffer can be assigned immediately after a call
to <link id="Rewrite"/>, <link id="Reset"/> or
<var>Append</var>, but not after the file was read from/written to. This may cause
loss of data. If a new buffer must be assigned after read/write
operations have been performed, the file should be flushed first.
This will ensure that the current buffer is emptied.
</li>
<li>Take care that the assigned buffer is always valid. If a local variable is
assigned as a buffer, then after the program exits the local program block,
the buffer will no longer be valid, and stack problems may occur.
</li>
</ul>
</remark>
</descr>
<errors>
No checking on <var>Size</var> is done.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex61"/>
</element>



<element name="Sin">
<short>Calculate sine of angle</short>
<descr>
<var>Sin</var> returns the sine of its argument <var>X</var>, where <var>X</var> is an
angle in radians.

If the absolute value of the argument is larger than 2^63, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Pi"/>
<link id="Exp"/>
<link id="Ln"/>
</seealso>
<example file="refex/ex62"/>
</element>



<element name="SizeOf">
<short>Return size of a variable or type.</short>
<descr>
<p>
<var>SizeOf</var> returns the size, in bytes, of any variable or type-identifier.
</p>
<remark>
This isn't really a RTL function. Its result is calculated at
compile-time, and hard-coded in the executable.
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex63"/>
</element>



<element name="Sptr">
<short>Return current stack pointer</short>
<descr>
<var>Sptr</var> returns the current stack pointer.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="SSeg"/>
</seealso>
<example file="refex/ex64"/>
</element>



<element name="Sqr">
<short>Calculate the square of a value.</short>
<descr>
<var>Sqr</var> returns the square of its argument <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sqrt"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex65"/>
</element>



<element name="Sqrt">
<short>Calculate the square root of a value</short>
<descr>
<var>Sqrt</var> returns the square root of its argument <var>X</var>, which must be
positive.
</descr>
<errors>
If <var>X</var> is negative, then a run-time error is generated.
</errors>
<seealso>
<link id="Sqr"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex66"/>
</element>



<element name="SSeg">
<short>Return stack segment register value.</short>
<descr>
 <var>SSeg</var> returns the Stack Segment. This function is only
 supported for compatibility reasons, as <var>Sptr</var> returns the
correct contents of the stackpointer.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sptr"/>
</seealso>
<example file="refex/ex67"/>
</element>



<element name="Str">
<short>Convert a numerical or enumeration value to a string.</short>
<descr>
<p>
<var>Str</var> returns a string which represents the value of X. X can be any
numerical or enumerated type. The actual declaration of <var>Str</var> is not 
according to pascal syntax, and should be
</p>
<code>
procedure Str(var X: TNumericType[:NumPlaces[:Decimals]];var S: String)
</code>
<p>
Where the optional <var>NumPlaces</var> and <var>Decimals</var> specifiers control the
formatting of the string: <var>NumPlaces</var> gives the total width of the
string, and <var>Decimals</var> the number of decimals after the decimal
separator char.
</p>
<p>
<var>Str</var> can also be used to convert an enumerated type value to a string
representation of the declared enumeration value. That means that the following will work:
</p>
<code>
Type
  TMyEnum = (OnE);

Var
  S : String;
begin
  Str(one, s); 
  Writeln(S);
end.        
</code>
<p>
This will write <var>OnE</var> on the screen, which is consistent with the
following - equivalent - program:
</p>
<code>
Type
  TMyEnum = (OnE);
     
Var
  S : String;
  E : TMyEnum;
begin
  E:=one;
  Str(E,s);
  Writeln(S);
end.   
</code>
<p>
For scoped enumerated types, only the value is written, which means the
following program will have the same output:
</p>
<code>
{$SCOPEDENUMS+}
Type  
  TMyEnum = (OnE);
  
Var
  S : String;
  
begin
  Str(one, s);
  Writeln(S); 
end.          
</code>
</descr>        
<errors>
None.
</errors>
<seealso>
<link id="Val"/>
</seealso>
<example file="refex/ex68"/>
</element>



<element name="StringOfChar">
<short>Return a string consisting of 1 character repeated N times.</short>
<descr>
<p>
<var>StringOfChar</var> creates a new String of length <var>l</var> and fills
it with the character <var>c</var>.
</p>
<p>
It is equivalent to  the following calls:
</p>
<code>
SetLength(StringOfChar,l);
FillChar(Pointer(StringOfChar)^,Length(StringOfChar),c);
</code>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
<example file="refex/ex97"/>
</element>



<element name="Succ">
<short>Return next element of ordinal type.</short>
<descr>
<p>
<var>Succ</var> returns the element that succeeds the element that was passed
to it. If it is applied to the last value of the ordinal type, and the
program was compiled with range checking on (<var>{$R+}</var>), then a run-time
error will be generated.
</p>
<p>
for an example, see <link id="Ord"/>.
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>

<element name="Swap">
<short>Swap high and low bytes/words of a variable</short>
<descr>
<var>Swap</var> swaps the high and low order bytes of <var>X</var> if <var>X</var> is of
type <var>Word</var> or <var>Integer</var>, or swaps the high and low order words of
<var>X</var> if <var>X</var> is of type <var>Longint</var> or <var>Cardinal</var>.
The return type is the type of <var>X</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lo"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex69"/>
</element>



<element name="Trunc">
<short>Truncate a floating point value.</short>
<descr>
<var>Trunc</var> returns the integer part of <var>X</var>,
which is always smaller than (or equal to) <var>X</var> in absolute value.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Round"/>
</seealso>
<example file="refex/ex70"/>
</element>



<element name="Truncate">
<short>Truncate the file at position</short>
<descr>
<var>Truncate</var> truncates the (opened) file <var>F</var> at the current file
position.

</descr>
<errors>
Depending on the state of the <var>{$I}</var> switch, a runtime error can be 
generated if there is an error. In the <var>{$I-}</var> state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Append"/>
<link id="Filepos"/>,
<link id="Seek"/>
</seealso>
<example file="refex/ex71"/>
</element>



<element name="Upcase">
<short>Convert a string to all uppercase.</short>
<descr>
<p>
<var>Upcase</var> returns the uppercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
uppercase. The type of the returned value is the same as the type of the
argument.
</p>
<p>
<var>UpCase</var> does not change the number of characters in the string.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lowercase"/>
</seealso>
<example file="refex/ex72"/>
</element>



<element name="Val">
<short>Calculate numerical/enumerated value of a string.</short>
<descr>
<p>
<var>Val</var> converts the value represented in the string <var>S</var> to a numerical
value or an enumerated value, and stores this value in the variable <var>V</var>, which
can be of type <var>Longint</var>, <var>Real</var> and <var>Byte</var> or
any enumerated type. If the conversion isn't succesfull, then the parameter 
<var>Code</var> contains the index of the character in <var>S</var> which 
prevented the conversion. 
The string <var>S</var> is allowed to contain spaces in the beginning.
</p>
<p>
The string <var>S</var> can contain a number in decimal, hexadecimal, binary
or octal format, as described in the language reference. For enumerated
values, the string must be the name of the enumerated value. The name is
searched case insensitively.
</p>
<p>
For hexadecimal values, the prefix '0x' or 'x' (case insensitive) may be
used as well. 
</p>
<p>
The conversion to enumerated exists only as of version 2.3.1 (or later) of the compiler.
</p>
</descr>
<errors>
If the conversion doesn't succeed, the value of <var>Code</var> indicates the
position where the conversion went wrong. The value of <var>V</var> is then
undefined.
</errors>
<seealso>
<link id="Str"/>
</seealso>
<example file="refex/ex74"/>
</element>



<element name="Write">
<short>Write variable to a text file</short>
<descr>
<p>
<var>Write</var> writes the contents of the variables <var>V1</var>, <var>V2</var> etc. to
the file <var>F</var>. <var>F</var> can be a typed file, or a <var>Text</var> file.
If <var>F</var> is a typed file, then the variables <var>V1</var>, <var>V2</var> etc. must
be of the same type as the type in the declaration of <var>F</var>. Untyped files
are not allowed.
</p>
<p>
If the parameter <var>F</var> is omitted, standard output is assumed.
If <var>F</var> is of type <var>Text</var>, then the necessary conversions are done
such that the output of the variables is in human-readable format.
This conversion is done for all numerical types. Strings are printed exactly
as they are in memory, as well as <var>PChar</var> types.
</p>
<p>
The format of the numerical conversions can be influenced through
the following modifiers:
<var>OutputVariable: NumChars [: Decimals ]</var>
This will print the value of <var>OutputVariable</var> with a minimum of
<var>NumChars</var> characters, from which <var>Decimals</var> are reserved for the
decimals. If the number cannot be represented with <var>NumChars</var> characters,
<var>NumChars</var> will be increased, until the representation fits. If the
representation requires less than <var>NumChars</var> characters then the output
is filled up with spaces, to the left of the generated string, thus
resulting in a right-aligned representation.
If no formatting is specified, then the number is written using its natural
length, with nothing in front of it if it's positive, and a minus sign if
it's negative.
Real numbers are, by default, written in scientific notation.
</p>
<remark>
When writing string variables, no codepage conversions are done. 
The string is copied as-is to the file descriptor. 
In particular, for console output, it is the programmer's responsibility 
to make sure that the codepage of the string matches the codepage of the
console.
</remark>
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the <var>{$I}</var> switch.
</errors>
<seealso>
<link id="WriteLn"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
</seealso>
</element>

<element name="WriteLn">
<short>Write variable to a text file and append newline</short>
<descr>
<p>
<var>WriteLn</var> does the same as <link id="Write"/> for text files, and emits a
Carriage Return - LineFeed character pair after that.
If the parameter <var>F</var> is omitted, standard output is assumed.
If no variables are specified, a newline character sequence is emitted, 
resulting in a new line in the file <var>F</var>.
</p>
<remark>
The newline character is determined by the <link id="slinebreak"/>
constant.
</remark>
<remark>
When writing string variables, no codepage conversions are done. 
The string is copied as-is to the file descriptor. 
In particular, for console output, it is the programmer's responsibility 
to make sure that the codepage of the string matches the codepage of the
console.
</remark>
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the <var>{$I}</var> switch.
</errors>
<seealso>
<link id="Write"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
<link id="slinebreak"/>
</seealso>
<example file="refex/ex75"/>
</element>

<!-- range type Visibility: default -->
<element name="ShortInt">
<short>A signed 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="SmallInt">
<short>A signed 16-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Longint">
<short>A signed 32-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Byte">
<short>An unsigned 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Word">
<short>An unsigned 16-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="DWord">
<short>An unsigned 32-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="Cardinal">
<short>An unsigned 32-bits integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="Integer">
<short>A signed 16-bits integer</short>
<descr>
The system unit defines <var>Integer</var> as a signed 16-bit integer.
But when <var>DELPHI</var> or <var>OBJFPC</var> mode are active, then
the <file>objpas</file> unit redefines <var>Integer</var> as a 32-bit
integer.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PChar">
<short>Pointer to null-terminated string.</short>
<descr>
Or the same as a pointer to an array of char. See the reference manual for
more information about this type.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PPChar">
<short>Pointer to an array of pointers to null-terminated strings.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TAnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="AnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PAnsiChar">
<short>Alias for <link id="PChar"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PPAnsiChar">
<short>Alias for <link id="PPChar"/> type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UCS4Char">
<short>UCS unicode character (unsigned 32 bit word)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4Char">
<short>Pointer to <link id="UCS4Char"/></short>
</element>

<!-- array type Visibility: default -->
<element name="TUCS4CharArray">
<short>Array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4CharArray">
<short>Pointer to array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- array type Visibility: default -->
<element name="UCS4String">
<short>String of <link id="UCS4Char"/> characters.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UTF8String">
<short>UTF-8 unicode (ansi) string.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUTF8String">
<short>Pointer to <link id="UTF8String"/></short>
</element>

<!-- alias type Visibility: default -->
<element name="Currency">
<short>Currency type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="HRESULT">
<short>32-Bit signed integer.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="TDateTime">
<short>Encoded Date-Time type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="Error">
<short>Generate run-time error</short>
<descr>
<var>Error</var> generates a run-time error with an exit code corresponding
to <var>RunTimeError</var>. This function is implemented for Delphi
compatibility, and is not used by the Free Pascal Run-Time Library.
</descr>
<seealso>
<link id="RunError"/>
<link id="Halt"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PSingle">
<short>Pointer to single-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDouble">
<short>Pointer to double-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCurrency">
<short>Pointer to currency type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtended">
<short>Pointer to extended-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSmallInt">
<short>Pointer to <link id="smallint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortInt">
<short>Pointer to <link id="shortint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInteger">
<short>Pointer to <link id="integer"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PByte">
<short>Pointer to <link id="byte"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWord">
<short>Pointer to <link id="word"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDWord">
<short>Pointer to <link id="DWord"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongWord">
<short>Pointer to <var>LongWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongint">
<short>Pointer to <link id="Longint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCardinal">
<short>Pointer to <link id="Cardinal"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PQWord">
<short>Pointer to <var>QWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInt64">
<short>Pointer to <var>Int64</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPtrInt">
<short>Pointer to <link id="PtrInt"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSizeInt">
<short>Pointer to a <link id="SizeInt"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointer">
<short>Pointer to a pointer type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPPointer">
<short>Pointer to a <link id="PPointer"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PBoolean">
<short>Pointer to a Boolean type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWordBool">
<short>Pointer to a <var>WordBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongBool">
<short>Pointer to a <var>LongBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortString">
<short>Pointer to a shortstring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PAnsiString">
<short>Pointer to an ansistring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDate">
<short>Pointer to a <link id="TDateTime"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PError">
<short>Pointer to an <link id="Error"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="WChar">
<short>Wide char (16-bit sized char)</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTextLineBreakStyle">
<short>Text line break style. (end of line character)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsLF">
<short>Line-feed only (#10, Unix style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCRLF">
<short>Carriage-return, line-feed (#13#30, Windows style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCR">
<short>Carriage-return (#13, Mac-OS style)</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TProcedure">
<short>Simple procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxSIntValue">
<short>Maximum String-size value.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxUIntValue">
<short>Maximum unsigned integer value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxLongint">
<short>Maximum longint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxSmallint">
<short>Maximum smallint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxint">
<short>Maximum integer value.</short>
</element>

<!-- array type Visibility: default -->
<element name="IntegerArray">
<short>Generic array of integer.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntegerArray">
<short>Pointer to <link id="IntegerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="PointerArray">
<short>Generic pointer array.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointerArray">
<short>Pointer to <link id="PointerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="TBoundArray">
<short>Dynamic array of integer.</short>
</element>

<!-- array type Visibility: default -->
<element name="TPCharArray">
<short>Array of PChar</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPCharArray">
<short>Pointer to <link id="TPCharArray"/> type.</short>
</element>

<!-- constant Visibility: default -->
<element name="Max_Frame_Dump">
<short>Maximum number of frames to show in error frame dump.</short>
</element>

<!-- constant Visibility: default -->
<element name="ExitProc">
<short>Exit procedure pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="Erroraddr">
<short>Address where the last error occurred.</short>
</element>

<!-- constant Visibility: default -->
<element name="Errorcode">
<short>Last error code.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmClosed">
<short>File mode: File is closed.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInput">
<short>File mode: File is open for reading.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmOutput">
<short>File mode: File is open for writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInOut">
<short>File mode: File is open for reading and writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmAppend">
<short>File mode: File is open for writing, appending to the end.</short>
</element>

<!-- constant Visibility: default -->
<element name="ProcessID">
<short>Current process ID.</short>
</element>

<!-- constant Visibility: default -->
<element name="Filemode">
<short>Default file mode for untyped files.</short>
</element>

<!-- constant Visibility: default -->
<element name="CmdLine">
<short>Current command-line.</short>
<p>
<var>Cmdline</var> returns a pointer to the current command line. The
null-terminated string <var>cmdline</var> points to the binary name,
followed by the command line arguments, separated by spaces. 
</p>
<p>
Basically, this is the DOS/Windows convention. <var>Cmdline</var> can 
be used under the Unix flavours. However, command line arguments containing 
spaces will be surrounded by double  quotes, as is done in the Dos/Windows 
tradition. 
Because of this, the use of <var>cmdline</var> might be undesired under Unix.</p>
<p>
Not all Unix flavours allow retrieving the binary filename (e.g. BSD), so in
these cases the binary name will not be the exact binary name, just what the
user typed on the command-line.
</p>
<p>
<var>Cmdline</var> can be implemented either by a variable, typed constant,
function or property. Because of this, you should not to write to it, or make
a pointer point to it.
</p>
<p>
In general, portable code should use <link id="paramcount"/> and <link
id="paramstr"/> instead of cmdline.
</p>
<seealso>
<link id="paramcount"/> 
<link id="paramstr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IsMultiThread">
<short>Indicates whether more than one thread is running in the application.</short>
</element>

<!-- constant Visibility: default -->
<element name="StackError">
<short>Indicate whether there was a stack error.</short>
</element>

<!-- variable Visibility: default -->
<element name="ExitCode">
<short>Exit code for the program, will be communicated to the OS on exit.</short>
</element>

<!-- variable Visibility: default -->
<element name="RandSeed">
<short>Seed for <link id="Random"/> function.</short>
</element>

<!-- variable Visibility: default -->
<element name="IsLibrary">
<short><var>True</var> if the current module is a library. Otherwise module
is an excutable</short>
</element>

<!-- variable Visibility: default -->
<element name="IsConsole">
<short><var>True</var> for console applications, <var>False</var> for GUI applications.</short>
</element>

<!-- variable Visibility: default -->
<element name="fpc_threadvar_relocate_proc" skip="1">
</element>

<!-- variable Visibility: default -->
<element name="ThreadID">
<short>Current Thread ID.</short>
</element>

<!-- variable Visibility: default -->
<element name="Output">
<short>Standard output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="Input">
<short>Standard input text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdOut">
<short>Alias for <link id="Output"/>.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdErr">
<short>Standard diagnostic output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="InOutRes">
<short>Result of last I/O operation. Read-Only.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackBottom">
<short>Current stack bottom.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackLength">
<short>Maximum stack length.</short>
</element>

<!-- function Visibility: default -->
<element name="IndexChar0">
<short>Return index of a character in null-terminated array of char.</short>
<descr> 
<var>IndexChar0</var> returns the index of the character <var>b</var> in the
null-terminated array <var>Buf</var>. At most <var>len</var> characters will
be searched, or the null character if it is encountered first. If the
character is not found, -1 is returned.
</descr>
<errors>
On error, -1 is returned.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="IndexDWord"/>
<link id="CompareChar0"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CompareChar0">
<short>Compare two buffers character by character till a null-character is reached.</short>
<descr>
<p>
<var>CompareChar0</var> compares 2 buffers <var>buf1</var> and <var>buf2</var>
for a maximum length of <var>len</var> or till a null character is reached
in either buffer. The result depends on the contents of the buffers:
</p>
<dl>
<dt>&lt; 0</dt><dd>If <var>buf1</var> contains a character less than the
corresponding character in <var>buf2</var>.</dd>
<dt>0</dt><dd>If both buffers are equal</dd>
<dt>&gt; 0</dt><dd>If <var>buf1</var> contains a character greater than the
corresponding character in <var>buf2</var>.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareChar"/>
<link id="CompareDWord"/>
<link id="CompareWord"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="prefetch">
<short>Prefetch a memory location</short>
<descr>
<var>Prefetch</var> can be used to optimize the CPU behaviour by already
loading a memory location. It is mainly used as a hint for those processors
that support it.
</descr>
<errors>
None.
</errors>
</element>

<!-- array type Visibility: default -->
<element name="real48">
<short>TP compatible real type (6 bytes) definition</short>
</element>

<!-- function Visibility: default -->
<element name="strpas">
<short>Convert a null-terminated string to a shortstring.</short>
<descr>
Converts a null terminated string in <var>P</var> to a Pascal string, and
returns
this string. The string is truncated at 255 characters.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="strlen">
<short>Length of a null-terminated string.</short>
<descr>
Returns the length of the null-terminated string <var>P</var>.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="Utf8CodePointLen">
<short>Length of an UTF-8 codepoint.</short>
<descr>
<p>
<var>Utf8CodePointLen</var> returns the length of the UTF-8 codepoint
starting at the beginning of <var>P</var>. It will look at at most
<var>MaxLookAhead</var> bytes to do create this codepoint. If
<var>IncludeCombiningDiacriticalMarks</var> is true, combining
diacritical marks trailing the first codepoint (which itself can
also be such a mark) will be considered to be part of the codepoint.
</p>
<p>If the function returns a value > 0, then this is the number of
bytes occupied by the codepoint and, if requested, the trailing
combining diacritical marks. If the result = 0, this means that all
bytes within the requested <var>MaxLookAhead</var> could be part of
a single valid codepoint and, if requested, its trailing diacritical
marks, but that the codepoint is incomplete and more bytes need to
be looked at. If the result is &lt; 0, then the function determined that
the codepoint was invalid after processing the number of bytes equal
to the absolute value of the function result.
</p>
<p>
If <var>IncludeCombiningDiacriticalMarks</var> is <var>True</var>, then
</p>
<ul>
<li>
If the function processes all <var>MaxLookAhead</var> bytes, it will
return the value <var>MaxLookAhead</var> rather than 0, even though
in theory more combining diacritical marks might follow if more bytes
would be looked at. Therefore, in order to ascertain that all combining
diacritical marks are processed, pass all bytes at once to this function.
</li>
<li>
If an invalid sequence is detected while processing a potential
combining diacritical mark after a valid codepoint has been found
already, the function will return the length of this valid codepoint
(plus that of any preceding valid combining diacritical marks) as
a positive value. The idea is that this invalid sequence at the end
is by definition not a combining diacritical mark (since all of those
are valid sequences) and hence should not render the preceding
codepoint invalid.
</li>
</ul>
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="Space">
<short>Return a string of spaces</short>
<descr>
<var>Space</var> returns a shortstring with length <var>B</var>, consisting
of spaces.
</descr>
<seealso>
<link id="StringOfChar"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UniqueString">
<short>Make sure reference count of string is 1</short>
<descr>
<var>UniqueString</var> ensures that the ansistring <var>S</var> has
reference count 1. It makes a copy of <var>S</var> if this is necesary, and
returns the copy in <var>S</var>
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SetTextLineEnding">
<short>Set the end-of-line character for the given text file.</short>
<descr>
<var>SetTextLineEnding</var> sets the end-of-line character for the text
file <var>F</var> to <var>Ending</var>. By default, this is the string
indicated by <link id="DefaultTextLineBreakStyle"/>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultTextLineBreakStyle"/>
<link id="TTextLineBreakStyle"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_frame">
<short>Return the current frame</short>
<descr>
<var>get_frame</var> returns a pointer to the current stack frame.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_addr">
<short>Return the address of the caller.</short>
<descr>
<var>get_caller_frame</var> returns a pointer to address ( the return
address)  of the caller  of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_frame"/>
<link id="get_caller_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_frame">
<short>Return the frame pointer of the caller</short>
<descr>
<var>get_caller_frame</var> returns a pointer to the frame of the caller 
of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Dump_Stack">
<short>Dump stack to the given text file.</short>
<descr>
<var>Dump_Stack</var> prints a stack dump to the file <var>f</var>, with
base frame pointer <var>bp</var>
</descr>
<errors>
The file <var>f</var> must be opened for writing or an error will occur.
</errors>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
<link id="get_frame"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AddExitProc">
<short>Add an exit procedure to the exit procedure chain.</short>
<descr>
<var>AddExitProc</var> adds <var>Proc</var> to the exit procedure chain. At
program exit, all procedures added in this way will be called in reverse
order.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ExitProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitExceptions">
<short>Initialize exceptions.</short>
<descr>
<var>SysInitExceptions</var> initializes the exception system. This
procedure should never be called directly, it is taken care of by the RTL.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitStdIO">
<short>Initialize standard input and output.</short>
<descr>
<var>SysInitStdIO</var> initializes the standard input and output files:
<link id="Output"/>, <link id="Input"/> and <link id="StdErr"/>. This
routine is called by the initialization code of the system unit, there
should be no need to call it directly.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysResetFPU">
<short>Reset the floating point unit.</short>
<descr>
<var>SysResetFPU</var> resets the floating point unit. There should normally
be no need to call this unit; the compiler itself takes care of this.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="AbstractError">
<short>Generate an abstract error.</short>
<descr>
<var>AbstractError</var> generates an abstract error (run-time error 211).
If the <link id="AbstractErrorProc"/> constant is set, it will be called
instead.
</descr>
<errors>
This routine causes a run-time error 211.
</errors>
<seealso>
<link id="AbstractErrorProc"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysBackTraceStr">
<short>Format an address suitable for inclusion in a backtrace</short>
<descr>
<var>SysBackTraceStr</var> will create a string representation of the 
address <var>Addr</var>, suitable for inclusion in a stack backtrace.
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SysAssert">
<short>Standard Assert failure implementation</short>
<descr>
<var>SysAssert</var> is the standard implementation of the assertion failed
code. It is the default value of the <var>AssertErrorProc</var> constant.
It will print the assert message <var>Msg</var> together with the filename
<var>FName</var> and linenumber <var>LineNo</var> to standard error output
(<var>StdErr</var>) and will halt the program with exit code 227.
The error address <var>ErrorAddr</var> is ignored.
</descr>
<seealso>
<link id="AssertErrorProc"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TBackTraceStrFunc">
<short>Type for formatting of backtrace dump.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TErrorProc">
<short>Standard error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAbstractErrorProc">
<short>Abstract error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAssertErrorProc">
<short>Assert error handler procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="BackTraceStrFunc">
<short>Standard backtrace formatting routine</short>
<descr>
This handler is called to get a standard format for the backtrace routine.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ErrorProc">
<short>Custom error handling procedure.</short>
<descr>
<p>
If set, the <var>ErrorProc</var> constant is used when a run-time error
occurs. If it is not set, then the standard error handling is done: a stack
dump is performed, and the program exits with the indicated error code.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TErrorProc"/>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AbstractErrorProc">
<short>Custom abstract error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an abstract
error occurs. If it is not set, then the standard error handling is done:
A stack dump is performed, and the program exits with error code 211.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TAbstractErrorProc"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AssertErrorProc">
<short>Custom assert error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an assert
error occurs. If it is not set, then the standard error handling is done:
The assertion error message is printed, together with the location of the
assertion, and A stack dump is performed, and the program exits with error code
227.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="jmp_buf">
<short>Record type to store processor information.</short>
<seealso>
<link id="setjmp"/>
<link id="longjmp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.ebx">
<short>EBX register.</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.esi">
<short>ESI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.edi">
<short>EDI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.bp">
<short>BP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.sp">
<short>SP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.pc">
<short>PC register</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PJmp_buf">
<short>Pointer to <link id="jmp_buf"/> record</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInstanceSize">
<short>VMT Layout: Location of class instance size in VMT</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtParent">
<short>VMT Layout: location of pointer to parent VMT.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtClassName">
<short>VMT Layout: location of class name.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDynamicTable">
<short>VMT Layout: location of dynamic methods table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodTable">
<short>VMT Layout: Method table start.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFieldTable">
<short>VMT Layout: Location of fields table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtTypeInfo">
<short>VMT Layout: Location of class type information.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInitTable">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAutoTable">
<short>VMT layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtIntfTable">
<short>VMT layout: Interface table</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMsgStrPtr">
<short>VMT layout: message strings table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodStart">
<short>VMT layout: start of method table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDestroy">
<short>VMT Layout: Location of destructor pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtNewInstance">
<short>VMT Layout: location of NewInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFreeInstance">
<short>VMT Layout: location of FreeInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtSafeCallException">
<short>VMT  Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandler">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAfterConstruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtBeforeDestruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandlerStr">
<short>VMT Layout: ?</short>
</element>

<!-- alias type Visibility: default -->
<element name="TextFile">
<short>Alias for <var>Text</var> file type.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Parent class for all classes.</short>
<descr>
<var>TObject</var> is used as the parent class for all class definitions.
It contains some standard methods that are available in all classes.
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TClass">
<short>Class of <link id="TObject"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PClass">
<short>Pointer to <link id="TClass"/></short>
</element>

<!-- record type Visibility: default -->
<element name="TMsgStrTable">
<short>Record used in string message handler table.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.name">
<short>Message name</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.method">
<short>Method to call</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMsgStrTable">
<short>Pointer to array of <link id="TMsgStrTable"/> records.</short>
</element>

<!-- record type Visibility: default -->
<element name="TStringMessageTable">
<short>String message table container for class.</short>
<descr>
Record used to describe the string messages handled by a class.
It consists of a count, followed by an array of <link id="TMsgStrTable"/>
records.
</descr>
<seealso>
<link id="TMsgStrTable"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.count">
<short>Number of messages in the string table.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.msgstrtable">
<short>First <link id="TMsgStrTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pstringmessagetable">
<short>Pointer to <link id="TStringMessageTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PGuid">
<short>Pointer to <link id="TGUID"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="TGuid">
<short>Standard GUID representation type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfaceentry">
<short>Pointer to <link id="tinterfaceentry"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfaceentry">
<short>Interfaces table entry.</short>
<descr>
<var>tinterfaceentry</var> is used to store the list of Interfaces of a
class. This list is stored as an array of <var>tinterfaceentry</var>
records.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IID">
<short>Unique GUID for this interface.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.VTable">
<short>Pointer to interface VTable.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IOffset">
<short>Offset</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IIDStr">
<short>Pointer to GUID string. Always assigned for COM.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfacetable">
<short>Pointer to <link id="tinterfacetable"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfacetable">
<short>Record to store list of interfaces of a class.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.EntryCount">
<short>Number of interfaces.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.Entries">
<short>Array of <link id="tinterfaceentry"/> records.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Base class of all classes.</short>
<descr>
<var>TObject</var> is the parent root class for all classes in Object
Pascal. If a class has no parent class explicitly declared, it is dependent
on <var>TObject</var>. <var>TObject</var> introduces class methods that deal
with the class' type information, and contains all necessary methods to
create an instance at runtime, and to dispatch messages to the correct
method (both string and integer messages).
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TObject.Create">
<short><var>TObject</var> Constructor</short>
<descr>
<var>Create</var> creates a new instance of <var>TObject</var>. Currently it
does nothing. It is also not virtual, so there is in principle no need to
call it directly. 
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TObject.Destroy">
<short><var>TObject</var> destructor.</short>
<descr>
<p>
<var>Destroy</var> is the destructor of <var>TObject</var>. 
It will clean up the memory assigned to the instance. Descendent classes
should override destroy if they want to do additional clean-up. No other
destructor should be implemented.
</p>
<p>
It is bad programming practice to call <var>Destroy</var> directly. It is
better to call the <link id="TObject.Free">Free</link> method, because that
one will check first if <var>Self</var> is different from <var>Nil</var>.
</p>
<p>
To clean up an instance and reset the refence to the instance, it is best to
use the <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> function.
</p>
</descr>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.newinstance">
<short>Allocate memory on the heap for a new instance</short>
<descr>
<var>NewInstance</var> allocates memory on the heap for a new instance of
the current class. If the memory was allocated, the class will be
initialized by a call to <link id="TObject.InitInstance">InitInstance</link>.
The function returns the newly initialized instance.
</descr>
<errors>
If not enough memory is available, a <var>Nil</var> pointer may be returned, 
or an exception may be raised.
</errors>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.InstanceSize">InstanceSize</link>
<link id="TObject.FreeInstance">FreeInstance</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.FreeInstance">
<short>Clean up instance and free the memory reserved for the instance.</short>
<descr>
<var>FreeInstance</var> cleans up an instance of the current class, and
releases the heap memory occupied by the class instance.
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.NewInstance">NewInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.SafeCallException">
<short>Handle exception object</short>
<descr>
<var>SafeCallException</var> should be overridden to handle exceptions in a
method marked with the savecall directive. The implementation in
<var>TObject</var> simply returns zero.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandler">
<short>Default handler for integer message handlers.</short>
<descr>
<var>DefaultHandler</var> is the default handler for messages. If a message
has an unknown message ID (i.e. does not appear in the table with integer
message handlers), then it will be passed to
<var>DefaultHandler</var> by the <link id="TObject.Dispatch">Dispatch</link>
method.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Free">
<short>Check for <var>Nil</var> and call destructor.</short>
<descr>
<var>Free</var> will check the <var>Self</var> pointer and calls
<link id="TObject.Destroy">Destroy</link> if it is different from
<var>Nil</var>. This is a safer method than calling <var>Destroy</var>
directly. If a reference to the object must be reset as well (a recommended
technque), then the function <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> should be called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="#rtl.sysutils.freeandnil">FreeAndNil</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InitInstance">
<short>Initialize a new class instance.</short>
<descr>
<var>InitInstance</var> initializes the memory pointer to by
<var>Instance</var>. This means that the VMT is initialized, and the
interface pointers are set up correctly.
The function returns the newly initialized instance.
</descr>
<seealso>
<link id="TObject.NewInstance">NewInstance</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.CleanupInstance">
<short>Finalize the class instance.</short>
<descr>
<p>
<var>CleanUpinstance</var> finalizes the instance, i.e. takes care of all
reference counted objects, by decreasing their reference count by 1, and
freeing them if their count reaches zero.
</p>
<p>
Normally, <var>CleanupInstance</var> should never be called, it is called
automatically when the object is freed with it's constructor.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
<link id="TObject.InitInstance">InitInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassInfo">
<short>Return a pointer to the type information for this class.</short>
<descr>
<var>ClassInfo</var> returns a pointer to the type information for this
class. This pointer can be used in the various type information routines.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassType">
<short>Return a "class of" pointer for the current class</short>
<descr>
<var>ClassType</var> returns a <link id="TClass"/> class type reference for
the current class.
</descr>
<seealso>
<link id="TClass"/>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassName">
<short>Return the current class name.</short>
<descr>
<var>ClassName</var> returns the class name for the current class, in
all-uppercase letters. To check for the class name, use the <link
id="TObject.ClassNameIs">ClassNameIs</link> class method.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassNameIs">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassNameIs">
<short>Check whether the class name equals the given name.</short>
<descr>
<var>ClassNameIs</var> checks whether <var>Name</var> equals the class name.
It takes of case sensitivity, i.e. it converts both names to uppercase
before comparing.
</descr>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassParent">
<short>Return the parent class.</short>
<descr>
<var>ClassParent</var> returns the class of the parent class of the current
class. This is always different from <var>Nil</var>, except for
<var>TObject</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InstanceSize">
<short>Return the size of an instance.</short>
<descr>
<var>InstanceSize</var> returns the number of bytes an instance takes in
memory. This is Just the memory occupied by the class structure, and does
not take into account any additional memory that might be allocated by the
constructor of the class.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InheritsFrom">
<short>Check whether class is an ancestor.</short>
<descr>
<var>InheritsFrom</var> returns <var>True</var> if <var>AClass</var> is an
ancestor class from the current class, and returns false if it is not.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TClass"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.StringMessageTable">
<short>Return a pointer to the string message table.</short>
<descr>
<var>StringMessageTable</var> returns a pointer to the string message table,
which can be used to look up methods for dispatching a string message. It is
used by the <link id="TObject.DispatchStr">DispatchStr</link> method.
</descr>
<errors>
If there are no string message handlers, nil is returned.
</errors>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Dispatch">
<short>Dispatch an integer message</short>
<descr>
<p>
<var>Dispatch</var> looks in the message handler table for a handler that
handles <var>message</var>. The message is identified by the first dword
(cardinal) in the message structure.
</p>
<p>
If no matching message handler is found, the message is passed to the
<link id="TObject.DefaultHandler">DefaultHandler</link> method, which can be
overridden by descendent classes to add custom handling of messages.
</p>
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DispatchStr">
<short>Dispatch a string message.</short>
<descr>
<var>DispatchStr</var> extracts the message identifier from
<var>Message</var> and checks the message handler table to see if a handler
for the message is found, and calls the handler, passing along the message. 
If no handler is found, the default <link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link> 
is called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodAddress">
<short>Return the address of a method</short>
<descr>
<var>MethodAddress</var> returns the address of a method, searching the
method by its name. The <var>Name</var> parameter specifies which method
should be taken. The search is conducted in a case-insensitive manner.
</descr>
<errors>
If no matching method is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodName">MethodName</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodName">
<short>Return the name of a method.</short>
<descr>
<var>MethodName</var> searches the VMT for a method with the specified 
<var>address</var> and returns the name of the method.
</descr>
<errors>
If no method with the matching address is found, an empty string is
returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.FieldAddress">
<short>Return the address of a field.</short>
<descr>
<var>FieldAddress</var> returns the address of the field with name <var>name</var>. 
The address is the address of the field in the current class instance.
</descr>
<errors>
If no field with the specified name is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.MethodName">MethodName</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.AfterConstruction">
<short>Method called after the constructor was called.</short>
<descr>
<var>AfterConstruction</var> is a method called after the constructor was
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed after the constructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.BeforeDestruction">BeforeDestruction</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.BeforeDestruction">
<short>Method called before the destructor is called.</short>
<descr>
<var>BeforeDestruction</var> is a method called before the destructor is
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed before the destructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.AfterConstruction">AfterConstruction</link>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandlerStr">
<short>Default handler for string messages.</short>
<descr>
<var>DefaultHandlerStr</var> is called for string messages which have no
handler associated with them in the string message handler table. The
implementation of <var>DefaultHandlerStr</var> in <var>TObject</var> does
nothing and mut be overridden by descendent classes to provide specific
message handling behaviour.
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TExceptProc">
<short>Exception handler procedural type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExceptObject">
<short>Pointer to Exception handler procedural type <link id="TExceptProc"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExceptObject">
<short>Exception object</short>
<descr>
<var>TExceptObject</var> is the exception description record which is found
on the exception stack.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.FObject">
<short>Exception instance.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Addr">
<short>Address where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Frame">
<short>Exception frame where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Next">
<short>Next exception object on the stack.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.refcount">
<short>Reference count for this exception object</short>
</element>

<!-- constant Visibility: default -->
<element name="ExceptProc">
<short>Current exception handling procedure.</short>
<descr>
<p>
This constant points to the current exception handling procedure. 
This routine is called when an unhandled exception occurs, i.e. an exception
that is not stopped by a except block.
</p>
<p>
If the handler is not set, the RTL will emit a run-time error 217 when an
unhandler exception occurs.
</p>
<p>
It is set by the <link id="#rtl.sysutils">sysutils</link> unit. 
</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="RaiseProc">
<short>Procedure to raise an exception.</short>
</element>

<!-- function Visibility: default -->
<element name="RaiseList">
<short>List of currently raised exceptions.</short>
<descr>
<var>RaiseList</var> returns a pointer to the list of currently raised
exceptions (i.e. a pointer to the first exception block.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AcquireExceptionObject">
<short>Obtain a reference to the current exception object</short>
<descr>
<p>
<var>AcquireExceptionObject</var> returns the current exception object.
It raises the reference count of the exception object, so it will not be
freed.  Calling this method is only valid within an except block.
</p>
<p>
The effect of this function is countered by re-raising an exception
via <var>raise;</var>
</p>
<p>
To make sure that the exception object is released when it is no longer
needed, <link id="ReleaseExceptionObject"/> must be called when the 
reference is no longer needed.
</p>
</descr>
<errors>
If there is no current exception, a run-time error 231 will occur.
</errors>
<seealso>
<link id="ReleaseExceptionObject"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReleaseExceptionObject">
<short>Decrease the reference count of the current exception object.</short>
<descr>
<p>
<var>ReleaseExceptionObject</var> decreases the reference count of the
current exception object. This should be called whenever a reference to the
exception object was obtained via the <link id="AcquireExceptionObject"/>
call.
</p>
<p>
Calling this method is only valid within an except block.
</p>
</descr>
<errors>
If there is no current exception object, a run-time error 231 will occur.
</errors>
<seealso>
<link id="AcquireExceptionObject"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vtInteger">
<short>TVarRec type: Integer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtBoolean">
<short>TVarRec type: Boolean</short>
</element>

<!-- constant Visibility: default -->
<element name="vtChar">
<short>TVarRec type: Char</short>
</element>

<!-- constant Visibility: default -->
<element name="vtExtended">
<short>TVarRec type: Extended</short>
</element>

<!-- constant Visibility: default -->
<element name="vtString">
<short>TVarRec type: String</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPointer">
<short>TVarRec type: pointer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPChar">
<short>TVarRec type: PChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtObject">
<short>TVarRec type: Object instance</short>
</element>

<!-- constant Visibility: default -->
<element name="vtClass">
<short>TVarRec type: Class type</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideChar">
<short>TVarRec type: Widechar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPWideChar">
<short>TVarRec type: PWideChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtAnsiString">
<short>TVarRec type: Ansistring</short>
</element>

<!-- constant Visibility: default -->
<element name="vtCurrency">
<short>TVarRec type: Currency</short>
</element>

<!-- constant Visibility: default -->
<element name="vtVariant">
<short>TVarRec type: Variant</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInterface">
<short>TVarRec type: Interface</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideString">
<short>TVarRec type: WideString</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInt64">
<short>TVarRec type: Int64 (signed 64-bit integer)</short>
</element>

<!-- constant Visibility: default -->
<element name="vtQWord">
<short>TVarRec type: QWord (unsigned 64-bit integer)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVarRec">
<short>Pointer to <link id="TVarRec"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="TVarRec">
<short>Record describing an element in an array of const</short>
<descr>
<var>TVarRec</var> is a record generated by the compiler for each element in
a <var>array of const</var> call. The procedure that receives the constant
array receives an array of <var>TVarRec</var> elements, with lower bound zero
and high bound equal to the number of elements in the array minus one
(as returned by <var>High(Args)</var>)
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="tdynarrayindex">
<short>Type with the correct size for index into a dynamic array.</short>
<descr>
A variable of type <var>tdynarrayindex</var> will always have the correct
size, suitable for serving as an index in a dynamic array.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pdynarrayindex">
<short>Pointer to <link id="tdynarrayindex"/> type.</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_big_chararray" skip="1">
<short>Array of char.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="fpc_small_set" skip="1">
<short>Type with the size of a small set</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_normal_set" skip="1">
<short>Type with the size of a normal set</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMemoryManager">
<short>Pointer to <link id="TMemoryManager"/> record</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryManager">
<short>Record describing the current memory manager</short>
<descr>
<var>TMemoryManager</var> describes the memory manager. For more information
about the memory manager, see the programmer's reference. 
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.NeedLock">
<short>Does the memory manager require a lock</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Getmem">
<short>Function called when memory must be allocated on the heap.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Freemem">
<short>Function called when previously allocated memory can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.FreememSize">
<short>Function called when previously allocated memory with a known size can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.AllocMem">
<short>Same as getmem, but additionally clear the allocated memory (filled with 0 bytes).</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.ReAllocMem">
<short>Handler called when an allocated  memory block should be resized</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.MemSize">
<short>Return the size of a memory block.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.GetHeapStatus">
<short>Handler called when the heap status must be reported.</short>
</element>

<element name="GetHeapStatus">
<short>Return the memory manager heap status.</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryMutexManager">
<short>Record describing the mutex manager for the heap.</short>
<descr>
When the heapmanager needs a lock, then the mutex manager is used to handle
the lock.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexInit">
<short>Initialize the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexDone">
<short>Finalize (i.e. dispose of) the mutex.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexLock">
<short>Lock the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexUnlock">
<short>Unlock the mutex.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetMemoryMutexManager">
<short>Procedure to set the mutex manager.</short>
<descr>
<var>SetMemoryMutexManager</var> sets the mutex manager used by the memory
manager to <var>MutexMgr</var>. The current mutex manager is returned in
<var>MutexMgr</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TMemoryMutexManager"/>
<link id="SetMemoryManager"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="growheapsizesmall">
<short>Fixed size small blocks grow rate</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize1">
<short>Grow rate for block less than 256 Kb.</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize2">
<short>Grow rate for block larger than 256 Kb.</short>
</element>

<!-- variable Visibility: default -->
<element name="ReturnNilIfGrowHeapFails">
<short>Describe behaviour if getmem fails.</short>
<descr>
<var>ReturnNilIfGrowHeapFails</var> describes what happens if there is no
more memory available from the operating system. if set to <var>True</var>
the memory manager will return <var>Nil</var>. If set to <var>False</var>
then a run-time error will occur.
</descr>
</element>

<!-- function Visibility: default -->
<element name="SysGetmem">
<short>System memory manager memory allocator.</short>
<descr>
<var>SysGetmem</var> is the system memory manager implementation for <link
id="GetMem"/> 
</descr>
<seealso>
<link id="GetMem"/>
<link id="GetMemory"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreemem">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreeem</var> is the system memory manager implementation for <link id="FreeMem"/>
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreememSize">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for <link
id="FreeMem"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysMemSize">
<short>System memory manager: free size.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="MemSize"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysAllocMem">
<short>System memory manager: Allocate memory</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="AllocMem"/>
</descr>
<seealso>
<link id="AllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysTryResizeMem">
<short>System memory manager: attempt to resize memory.</short>
<descr>
<var>SysTryResizeMem</var> is a help routine for the system memory 
manager implementation for <link id="ReAllocMem"/>, <link
id="SysReAllocMem"/>
</descr>
<seealso>
<link id="SysReAllocMem"/>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysReAllocMem">
<short>System memory manager: Reallocate memory</short>
<descr>
<var>SysReallocMem</var> is a help routine for the system memory
manager implementation for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Getmemory">
<short>Alias for <link id="GetMem"/></short>
<descr>
<var>Getmemory</var> is an alias for <link id="GetMem"/>.
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Freememory">
<short>Alias for <link id="FreeMem"/></short>
<descr>
<var>FreeMemory</var> is an alias for <link id="FreeMem"/>.
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="MemSize">
<short>Return the size of a memory block.</short>
<descr>
<var>MemSize</var> returns the size of a memory block on the heap.
</descr>
<errors>
Passing an invalid pointer may lead to run-time errors (access violations).
</errors>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<element name="AllocMem">
<short>Allocate and clear memory.</short>
<descr>
<var>AllocMem</var> calls getmem <link id="GetMem"/>, and clears the
allocated memory, i.e. the allocated memory is filled with <var>Size</var> zero bytes.
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMem">
<short>Re-allocate memory on the heap</short>
<descr>
<p>
<var>ReAllocMem</var> resizes the memory pointed to by <var>P</var> so it has size
<var>Size</var>. The value of <var>P</var> may change during this operation.
The contents of the memory pointed to by <var>P</var> (if any) will be copied to
the new location, but may be truncated if the newly allocated memory block
is smaller in size. If a larger block is allocated, only the used memory is
initialized, extra memory will not be zeroed out.
</p>
<p>
Note that <var>P</var> may be nil, in that case the behaviour of
<var>ReAllocMem</var> is equivalent to <var>Getmem</var>.
</p>
</descr>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMemory">
<short>Alias for <link id="ReAllocMem"/></short>
<descr>
<var>ReAllocMemory</var> is an alias for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmGetmem">
<short>Routine that can be called from assembler routines to get memory.</short>
<descr>
<var>AsmGetmem</var> is a routine that can be called from assembler code to
get memory. The assembler reader cannot decide which overloaded <link
id="GetMem"/> call should be used. <var>AsmGetMem</var> provides a unique
name that can be called from assembler. Other than that it is completely
equivalent to <var>GetMem</var>.
</descr>
<seealso>
<link id="GetMem"/>
<link id="AsmFreeMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmFreemem">
<short>Routine that can be called from assembler routines to release memory.</short>
<descr>
<var>AsmFreemem</var> is a routine that can be called from assembler code to
release previously alocated memory. The assembler reader cannot decide which 
overloaded <link id="FreeMem"/> call should be used. <var>AsmFreeMem</var> 
provides a unique name that can be called from assembler. Other than that it 
is completely equivalent to <var>FreeMem</var>.
</descr>
<seealso>
<link id="FreeMem"/>
<link id="AsmGetMem"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="THandle">
<short>Type alias.</short>
<descr>
This type should be considered opaque. It is used to describe file and other
handles.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LineEnding">
<short>Constant describing the current line ending character.</short>
<descr>
<p>
<var>LineEnding</var> is a constant which contains the current line-ending
character. This character is system dependent, and is initialized by the
system. It should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="sLineBreak"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LFNSupport">
<short>Constant describing support for long filenames.</short>
<descr>
<p>
<var>LFNSupport</var> determines whether the current OS supports long file
names, i.e. filenames that are not of the form 8.3 as on ancient DOS
systems. If the value of this constant is <var>True</var> then long
filenames are supported. If it is false, then not.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</element>

<!-- constant Visibility: default -->
<element name="DirectorySeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
<var>DirectorySeparator</var> is the character used by the current operating
system to separate directory parts in a pathname. This constant is system
dependent, and should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DriveSeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
On systems that support driveletters, the <var>DriveSeparator</var> constant
denotes the character that separates the drive indicator from the directory
part in a filename path.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PathSeparator">
<short>Character used to separate paths in a search list</short>
<descr>
<p>
<var>PathSeparator</var> is the character used commonly on the current
operating system to separate paths in a list of paths, such as the 
<var>PATH</var> environment variable. 
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="DriveSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FileNameCaseSensitive">
<short>OS treatment of filenames is case sensitive.</short>
<descr>
<p>
<var>FileNameCaseSensitive</var> is <var>True</var> if case is important
when using filenames on the current OS. In this case, the OS will treat 
files with different cased names as different files. Note that this may 
depend on the filesystem: Unix operating systems that access a DOS or
Windows partition will have this constant set to true, but when writing to
the DOS partition, the casing is ignored.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="FileNameCasePreserving"/>
<link id="PathSeparator"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FileNameCasePreserving">
<short>OS preserves case in filenames when creating or renaming entries.</short>
<descr>
<p>
<var>FileNameCasePreserving</var> is <var>True</var> if case of letters
in file and directory entries is preserved and may be later retrieved
exactly as supplied when creating or renaming these entries. Note that this
may depend on the filesystem: Unix operating systems that access a DOS or
Windows partition will have this constant set to true, but when writing to
the DOS partition, all letters may be automatically converted to uppercase.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="FileNameCaseSensitive"/>
<link id="PathSeparator"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="sLineBreak">
<short>Alias for <link id="LineEnding"/></short>
<descr>
<p>
<var>sLineBreak</var> is an alias for <link id="LineEnding"/> and is
supplied for Delphi compatibility.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DefaultTextLineBreakStyle">
<short>Default line ending style.</short>
<descr>
<p>
<var>DefaultTextLineBreakStyle</var> contains the default OS setting for the
<link id="TTextLineBreakStyle"/> type. It is initizliaed by the system unit,
and is used to determine the default line ending when writing to text files.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="SetTextLineEnding"/>
<link id="TTextLineBreakStyle"/>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="FileNameCasePreserving"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="maxExitCode">
<short>Maximum exit code supported by the operating system.</short>
<descr>
<var>maxExitCode</var> is the maximum value for the <link id="Halt"/> call.
</descr>
<seealso>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UnusedHandle">
<short>Value indicating an unused file handle (as reported by the OS).</short>
</element>

<!-- constant Visibility: default -->
<element name="StdInputHandle">
<short>Value of the OS handle for the standard input file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdOutputHandle">
<short>Value of the OS handle for the standard output file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdErrorHandle">
<short>Value of the OS handle for the standard error-output file.</short>
</element>


<!-- variable Visibility: default -->
<element name="argc" skip="1">
<short>Number of command-line arguments.</short>
<descr>
<var>argc</var> contains the number of command-line arguments passed to
the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argv"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="argv">
<short>Pointer to the array of command-line arguments</short>
<descr>
<var>argv</var> contains a pointer to a <var>nil</var>-terminated 
array of null-terminated strings, containing the command-line 
arguments passed to the program by the OS. It is not available 
on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="envp">
<short>Pointer to the array of environment variables</short>
<descr>
<var>envp</var> contains a pointer to a <var>nil</var>-terminated
array of null-terminated strings, containing the environment variables
passed to the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="argv"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeInt">
<short>Signed integer type which fits for sizes</short>
<descr>
<var>SizeInt</var> is used to describe sizes of structures in FPC using a
signed integer. The actual type of this
type depends on the architecture: its size reflects the maximum addressable
memory on the current architecture, thus it is 64-bit on 64-bit platforms,
32-bit on 32-bit platforms, and 16 bit on 16 bit platforms.
</descr>
<seealso>
<link id="SizeUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeUInt">
<short>Unsigned Integer type which fits for sizes</short>
<descr>
<var>SizeUInt</var> is used to describe sizes of structures in FPC using an unsigned integer. 
The actual type of this type depends on the architecture: its size reflects the maximum addressable
memory on the current architecture, thus it is 64-bit on 64-bit platforms,
32-bit on 32-bit platforms, and 16 bit on 16 bit platforms.
</descr>
<seealso>
<link id="SizeInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrInt">
<short>Signed integer type with same size as Pointer.</short>
<descr>
<p><var>Ptrint</var> is a signed integer type which has always the same size as a
pointer. Ptrint is considered harmfull and should almost never be used in actual
code, because pointers are normally unsigned. For example, consider the following
code:
</p>
<code>
getmem(p,2048);                 {Assume the address of p becomes $7ffffff0.}
q:=pointer(ptrint(p)+1024));    {Overflow error.}
writeln(q>p);                   {Incorrect answer.}
</code>
<p>
Ptrint might have a valid use when two pointers are substracted from each other if
it is unknown which pointer has the largest address. However, even in this case
ptrint causes trouble in case the distance is larger than high(ptrint) and must be
used with great care.
</p><p>
The introduction of the <var>ptrint</var> type was a mistake. Please use
<link id="ptruint"/> instead.
</p>
</descr>
<seealso>
<link id="ptruInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrUInt">
<short>Unsigned integer type with same size as Pointer.</short>
<descr>
<var>PtrUInt</var> is an unsigned integer type which has always the same size as a
pointer. When using integers which will be cast to pointers and vice versa,
use this type, never the regular Cardinal type.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="ValSInt">
<short>Val-Signed integer.</short>
<descr>
Integer with the same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValUInt">
<short>Val-unsigned integer</short>
<descr>
Integer with the same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVariant">
<short>Pointer to <var>Variant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="POleVariant">
<short>Pointer to <var>OleVariant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWideChar">
<short>Pointer to <link id="WChar"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPWideChar">
<short>Pointer to link id="PWideChar"> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="UCS2Char">
<short>UCS2 unicode character.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PUCS2Char">
<short>Pointer to <link id="UCS2Char"/> character.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PText">
<short>Pointer to text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="ErrOutput">
<short>Alias for <link id="StdErr"/></short>
<descr>
<var>ErrOutput</var> is provided for Delphi compatibility.
</descr>
<seealso>
<link id="StdErr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_word">
<short>FPC compiler internal procedure index: lo (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_word">
<short>FPC compiler internal procedure index: hi (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_long">
<short>FPC compiler internal procedure index: lo (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_long">
<short>FPC compiler internal procedure index: hi (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ord_x">
<short>FPC compiler internal procedure index: ord</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_length_string">
<short>FPC compiler internal procedure index: length</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_chr_byte">
<short>FPC compiler internal procedure index: chr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_write_x">
<short>FPC compiler internal procedure index: write</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_writeln_x">
<short>FPC compiler internal procedure index: writeln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_read_x">
<short>FPC compiler internal procedure index: read</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_readln_x">
<short>FPC compiler internal procedure index: readln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_concat_x">
<short>FPC compiler internal procedure index: concat</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assigned_x">
<short>FPC compiler internal procedure index: assigned</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_str_x_string">
<short>FPC compiler internal procedure index: str</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ofs_x">
<short>FPC compiler internal procedure index: ofs</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sizeof_x">
<short>FPC compiler internal procedure index: sizeof</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeof_x">
<short>FPC compiler internal procedure index: typeof</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_val_x">
<short>FPC compiler internal procedure index: val</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_x">
<short>FPC compiler internal procedure index: reset</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_x">
<short>FPC compiler internal procedure index: rewrite</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_low_x">
<short>FPC compiler internal procedure index: low</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_high_x">
<short>FPC compiler internal procedure index: high</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_seg_x">
<short>FPC compiler internal procedure index: seg</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pred_x">
<short>FPC compiler internal procedure index: pred</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_succ_x">
<short>FPC compiler internal procedure index: succ</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_typedfile">
<short>FPC compiler internal procedure index: reset</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_typedfile">
<short>FPC compiler internal procedure index: rewrite</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_settextbuf_file_x">
<short>FPC compiler internal procedure index: settextbuf</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_inc_x">
<short>FPC compiler internal procedure index: inc</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dec_x">
<short>FPC compiler internal procedure index: dec</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_include_x_y">
<short>FPC compiler internal procedure index:  include</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exclude_x_y">
<short>FPC compiler internal procedure index: exclude</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_break">
<short>FPC compiler internal procedure index: break</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_continue">
<short>FPC compiler internal procedure index: continue</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assert_x_y">
<short>FPC compiler internal procedure index: assert</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_addr_x">
<short>FPC compiler internal procedure index: addr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeinfo_x">
<short>FPC compiler internal procedure index: typeinfo</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_setlength_x">
<short>FPC compiler internal procedure index: setlength</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_finalize_x">
<short>FPC compiler internal procedure index: finalize</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_new_x">
<short>FPC compiler internal procedure index: new</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dispose_x">
<short>FPC compiler internal procedure index: dispose</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exit">
<short>FPC compiler internal procedure index: exit</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_copy_x">
<short>FPC compiler internal procedure index: copy</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_initialize_x">
<short>FPC compiler internal procedure index: initialize</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_leave">
<short>FPC compiler internal procedure index: leave</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cycle">
<short>FPC compiler internal procedure index: cycle</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_trunc">
<short>FPC compiler internal procedure index: trunc</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_round">
<short>FPC compiler internal procedure index: round</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_frac">
<short>FPC compiler internal procedure index: frac</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_abs">
<short>FPC compiler internal procedure index: abs</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_int">
<short>FPC compiler internal procedure index: int</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqr">
<short>FPC compiler internal procedure index: sqr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_odd">
<short>FPC compiler internal procedure index: sqr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ptr">
<short>FPC compiler internal procedure index: sqr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_word">
<short>FPC compiler internal procedure index: swap (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_long">
<short>FPC compiler internal procedure index: swap (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_pi">
<short>FPC compiler internal procedure index: pi</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqrt">
<short>FPC compiler internal procedure index: sqrt</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_arctan">
<short>FPC compiler internal procedure index: arctan</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_cos">
<short>FPC compiler internal procedure index: cos</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_exp">
<short>FPC compiler internal procedure index: exp</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ln">
<short>FPC compiler internal procedure index: in</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sin">
<short>FPC compiler internal procedure index: sin</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_qword">
<short>FPC compiler internal procedure index: lo (qword)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_qword">
<short>FPC compiler internal procedure index: hi (qword)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cos_real">
<short>FPC compiler internal procedure index: cos (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pi">
<short>FPC compiler internal procedure index: pi</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_abs_real">
<short>FPC compiler internal procedure index: abs (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqr_real">
<short>FPC compiler internal procedure index: sqr (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqrt_real">
<short>FPC compiler internal procedure index: sqrt (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_arctan_real">
<short>FPC compiler internal procedure index: arctan (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ln_real">
<short>FPC compiler internal procedure index: ln (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sin_real">
<short>FPC compiler internal procedure index: sin (real)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_qword">
<short>FPC compiler internal procedure index: swap (qword)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_prefetch_var">
<short>FPC compiler internal procedure index: prefetch</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqb">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqw">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqd">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtb">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtw">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtd">
<short>FPC compiler internal procedure index: MMX</short>
</element>

<element name="fpc_abs_real">
<short>FPC internal compiler routine: abs_real</short>
</element>


<element name="fpc_AbstractErrorIntern">
<short>FPC internal compiler routine: AbstractErrorIntern</short>
</element>


<element name="fpc_Addref">
<short>FPC internal compiler routine: Addref</short>
</element>


<element name="fpc_ansistr_append_ansistring">
<short>FPC internal compiler routine: ansistr_append_ansistring</short>
</element>


<element name="fpc_ansistr_append_char">
<short>FPC internal compiler routine: ansistr_append_char</short>
</element>


<element name="fpc_ansistr_append_shortstring">
<short>FPC internal compiler routine: ansistr_append_shortstring</short>
</element>


<element name="fpc_AnsiStr_Assign">
<short>FPC internal compiler routine: AnsiStr_Assign</short>
</element>


<element name="fpc_AnsiStr_CheckRange">
<short>FPC internal compiler routine: AnsiStr_CheckRange</short>
</element>


<element name="fpc_AnsiStr_CheckZero">
<short>FPC internal compiler routine: AnsiStr_CheckZero</short>
</element>


<element name="fpc_AnsiStr_Compare">
<short>FPC internal compiler routine: AnsiStr_Compare</short>
</element>


<element name="fpc_AnsiStr_Concat">
<short>FPC internal compiler routine: AnsiStr_Concat</short>
</element>


<element name="fpc_AnsiStr_Concat_multi">
<short>FPC internal compiler routine: AnsiStr_Concat_multi</short>
</element>


<element name="fpc_ansistr_Copy">
<short>FPC internal compiler routine: ansistr_Copy</short>
</element>


<element name="fpc_ansistr_decr_ref">
<short>FPC internal compiler routine: ansistr_decr_ref</short>
</element>


<element name="fpc_AnsiStr_Float">
<short>FPC internal compiler routine: AnsiStr_Float</short>
</element>


<element name="fpc_ansistr_incr_ref">
<short>FPC internal compiler routine: ansistr_incr_ref</short>
</element>


<element name="fpc_ansistr_int64">
<short>FPC internal compiler routine: ansistr_int64</short>
</element>


<element name="fpc_ansistr_qword">
<short>FPC internal compiler routine: ansistr_qword</short>
</element>


<element name="fpc_AnsiStr_SetLength">
<short>FPC internal compiler routine: AnsiStr_SetLength</short>
</element>


<element name="fpc_AnsiStr_sint">
<short>FPC internal compiler routine: AnsiStr_sint</short>
</element>


<element name="fpc_ansistr_to_chararray">
<short>FPC internal compiler routine: ansistr_to_chararray</short>
</element>


<element name="fpc_AnsiStr_To_ShortStr">
<short>FPC internal compiler routine: AnsiStr_To_ShortStr</short>
</element>


<element name="fpc_ansistr_to_widechararray">
<short>FPC internal compiler routine: ansistr_to_widechararray</short>
</element>


<element name="fpc_AnsiStr_To_WideStr">
<short>FPC internal compiler routine: AnsiStr_To_WideStr</short>
</element>


<element name="fpc_AnsiStr_uint">
<short>FPC internal compiler routine: AnsiStr_uint</short>
</element>


<element name="fpc_ansistr_Unique">
<short>FPC internal compiler routine: ansistr_Unique</short>
</element>


<element name="fpc_arctan_real">
<short>FPC internal compiler routine: arctan_real</short>
</element>


<element name="fpc_assert">
<short>FPC internal compiler routine: assert</short>
</element>


<element name="fpc_Catches">
<short>FPC internal compiler routine: Catches</short>
</element>


<element name="fpc_chararray_Float">
<short>FPC internal compiler routine: chararray_Float</short>
</element>


<element name="fpc_chararray_int64">
<short>FPC internal compiler routine: chararray_int64</short>
</element>


<element name="fpc_chararray_qword">
<short>FPC internal compiler routine: chararray_qword</short>
</element>


<element name="fpc_chararray_sint">
<short>FPC internal compiler routine: chararray_sint</short>
</element>


<element name="fpc_CharArray_To_AnsiStr">
<short>FPC internal compiler routine: CharArray_To_AnsiStr</short>
</element>


<element name="fpc_chararray_to_shortstr">
<short>FPC internal compiler routine: chararray_to_shortstr</short>
</element>


<element name="fpc_CharArray_To_WideStr">
<short>FPC internal compiler routine: CharArray_To_WideStr</short>
</element>


<element name="fpc_chararray_uint">
<short>FPC internal compiler routine: chararray_uint</short>
</element>


<element name="fpc_char_copy">
<short>FPC internal compiler routine: char_copy</short>
</element>


<element name="fpc_Char_To_AnsiStr">
<short>FPC internal compiler routine: Char_To_AnsiStr</short>
</element>


<element name="fpc_Char_To_WideStr">
<short>FPC internal compiler routine: Char_To_WideStr</short>
</element>


<element name="fpc_class_as_intf">
<short>FPC internal compiler routine: class_as_intf</short>
</element>


<element name="fpc_cos_real">
<short>FPC internal compiler routine: cos_real</short>
</element>


<element name="fpc_DecRef">
<short>FPC internal compiler routine: DecRef</short>
</element>


<element name="fpc_divbyzero">
<short>FPC internal compiler routine: divbyzero</short>
</element>


<element name="fpc_div_int64">
<short>FPC internal compiler routine: div_int64</short>
</element>


<element name="fpc_div_qword">
<short>FPC internal compiler routine: div_qword</short>
</element>


<element name="fpc_do_as">
<short>FPC internal compiler routine: do_as</short>
</element>


<element name="fpc_do_is">
<short>FPC internal compiler routine: do_is</short>
</element>


<element name="fpc_dynarray_clear">
<short>FPC internal compiler routine: dynarray_clear</short>
</element>


<element name="fpc_dynarray_copy">
<short>FPC internal compiler routine: dynarray_copy</short>
</element>


<element name="fpc_dynarray_decr_ref">
<short>FPC internal compiler routine: dynarray_decr_ref</short>
</element>


<element name="fpc_dynarray_high">
<short>FPC internal compiler routine: dynarray_high</short>
</element>


<element name="fpc_dynarray_incr_ref">
<short>FPC internal compiler routine: dynarray_incr_ref</short>
</element>


<element name="fpc_dynarray_length">
<short>FPC internal compiler routine: dynarray_length</short>
</element>


<element name="fpc_dynarray_setlength">
<short>FPC internal compiler routine: dynarray_setlength</short>
</element>


<element name="fpc_dynarray_to_variant">
<short>FPC internal compiler routine: dynarray_to_variant</short>
</element>


<element name="fpc_exp_real">
<short>FPC internal compiler routine: exp_real</short>
</element>


<element name="fpc_finalize">
<short>FPC internal compiler routine: finalize</short>
</element>


<element name="fpc_finalize_array">
<short>FPC internal compiler routine: finalize_array</short>
</element>


<element name="fpc_frac_real">
<short>FPC internal compiler routine: frac_real</short>
</element>


<element name="fpc_freemem">
<short>FPC internal compiler routine: freemem</short>
</element>


<element name="fpc_get_input">
<short>FPC internal compiler routine: get_input</short>
</element>


<element name="fpc_getmem">
<short>FPC internal compiler routine: getmem</short>
</element>


<element name="fpc_get_output">
<short>FPC internal compiler routine: get_output</short>
</element>


<element name="fpc_help_constructor">
<short>FPC internal compiler routine: help_constructor</short>
</element>


<element name="fpc_help_destructor">
<short>FPC internal compiler routine: help_destructor</short>
</element>


<element name="fpc_help_fail">
<short>FPC internal compiler routine: help_fail</short>
</element>


<element name="fpc_in_exp_real">
<short>FPC internal compiler routine: in_exp_real</short>
</element>


<element name="fpc_in_fillchar_x">
<short>FPC internal compiler routine: in_fillchar_x</short>
</element>


<element name="fpc_in_frac_real">
<short>FPC internal compiler routine: in_frac_real</short>
</element>


<element name="fpc_in_get_caller_addr">
<short>FPC internal compiler routine: in_get_caller_addr</short>
</element>


<element name="fpc_in_get_caller_frame">
<short>FPC internal compiler routine: in_get_caller_frame</short>
</element>


<element name="fpc_in_get_frame">
<short>FPC internal compiler routine: in_get_frame</short>
</element>


<element name="fpc_in_int_real">
<short>FPC internal compiler routine: in_int_real</short>
</element>


<element name="fpc_Initialize">
<short>FPC internal compiler routine: Initialize</short>
</element>


<element name="fpc_InitializeUnits">
<short>FPC internal compiler routine: InitializeUnits</short>
</element>


<element name="fpc_in_move_x">
<short>FPC internal compiler routine: in_move_x</short>
</element>


<element name="fpc_in_pi_real">
<short>FPC internal compiler routine: in_pi_real</short>
</element>


<element name="fpc_in_round_real">
<short>FPC internal compiler routine: in_round_real</short>
</element>


<element name="fpc_in_slice">
<short>FPC internal compiler routine: in_slice</short>
</element>


<element name="fpc_interface_to_variant">
<short>FPC internal compiler routine: interface_to_variant</short>
</element>


<element name="fpc_intf_as">
<short>FPC internal compiler routine: intf_as</short>
</element>


<element name="fpc_intf_assign">
<short>FPC internal compiler routine: intf_assign</short>
</element>


<element name="fpc_intf_decr_ref">
<short>FPC internal compiler routine: intf_decr_ref</short>
</element>


<element name="fpc_intf_incr_ref">
<short>FPC internal compiler routine: intf_incr_ref</short>
</element>


<element name="fpc_int_real">
<short>FPC internal compiler routine: int_real</short>
</element>


<element name="fpc_in_trunc_real">
<short>FPC internal compiler routine: in_trunc_real</short>
</element>


<element name="fpc_iocheck">
<short>FPC internal compiler routine: iocheck</short>
</element>


<element name="fpc_ln_real">
<short>FPC internal compiler routine: ln_real</short>
</element>


<element name="fpc_mod_int64">
<short>FPC internal compiler routine: mod_int64</short>
</element>


<element name="fpc_mod_qword">
<short>FPC internal compiler routine: mod_qword</short>
</element>


<element name="fpc_mul_int64">
<short>FPC internal compiler routine: mul_int64</short>
</element>


<element name="fpc_mul_qword">
<short>FPC internal compiler routine: mul_qword</short>
</element>


<element name="fpc_overflow">
<short>FPC internal compiler routine: overflow</short>
</element>


<element name="fpc_pchar_length">
<short>FPC internal compiler routine: pchar_length</short>
</element>


<element name="fpc_PChar_To_AnsiStr">
<short>FPC internal compiler routine: PChar_To_AnsiStr</short>
</element>


<element name="fpc_pchar_to_shortstr">
<short>FPC internal compiler routine: pchar_to_shortstr</short>
</element>


<element name="fpc_PChar_To_WideStr">
<short>FPC internal compiler routine: PChar_To_WideStr</short>
</element>


<element name="fpc_pi_real">
<short>FPC internal compiler routine: pi_real</short>
</element>


<element name="fpc_PopAddrStack">
<short>FPC internal compiler routine: PopAddrStack</short>
</element>


<element name="fpc_PopObjectStack">
<short>FPC internal compiler routine: PopObjectStack</short>
</element>


<element name="fpc_PopSecondObjectStack">
<short>FPC internal compiler routine: PopSecondObjectStack</short>
</element>


<element name="fpc_PushExceptAddr">
<short>FPC internal compiler routine: PushExceptAddr</short>
</element>


<element name="fpc_PushExceptObj">
<short>FPC internal compiler routine: PushExceptObj</short>
</element>


<element name="fpc_pwidechar_length">
<short>FPC internal compiler routine: pwidechar_length</short>
</element>


<element name="fpc_PWideChar_To_AnsiStr">
<short>FPC internal compiler routine: PWideChar_To_AnsiStr</short>
</element>


<element name="fpc_PWideChar_To_ShortStr">
<short>FPC internal compiler routine: PWideChar_To_ShortStr</short>
</element>


<element name="fpc_PWideChar_To_WideStr">
<short>FPC internal compiler routine: PWideChar_To_WideStr</short>
</element>


<element name="fpc_Raiseexception">
<short>FPC internal compiler routine: Raiseexception</short>
</element>


<element name="fpc_rangeerror">
<short>FPC internal compiler routine: rangeerror</short>
</element>


<element name="fpc_Read_End">
<short>FPC internal compiler routine: Read_End</short>
</element>


<element name="fpc_ReadLn_End">
<short>FPC internal compiler routine: ReadLn_End</short>
</element>


<element name="fpc_Read_Text_AnsiStr">
<short>FPC internal compiler routine: Read_Text_AnsiStr</short>
</element>


<element name="fpc_Read_Text_Char">
<short>FPC internal compiler routine: Read_Text_Char</short>
</element>


<element name="fpc_Read_Text_Float">
<short>FPC internal compiler routine: Read_Text_Float</short>
</element>


<element name="fpc_Read_Text_Int64">
<short>FPC internal compiler routine: Read_Text_Int64</short>
</element>


<element name="fpc_Read_Text_PChar_As_Array">
<short>FPC internal compiler routine: Read_Text_PChar_As_Array</short>
</element>


<element name="fpc_Read_Text_PChar_As_Pointer">
<short>FPC internal compiler routine: Read_Text_PChar_As_Pointer</short>
</element>


<element name="fpc_Read_Text_QWord">
<short>FPC internal compiler routine: Read_Text_QWord</short>
</element>


<element name="fpc_Read_Text_ShortStr">
<short>FPC internal compiler routine: Read_Text_ShortStr</short>
</element>


<element name="fpc_Read_Text_SInt">
<short>FPC internal compiler routine: Read_Text_SInt</short>
</element>


<element name="fpc_Read_Text_UInt">
<short>FPC internal compiler routine: Read_Text_UInt</short>
</element>


<element name="fpc_ReRaise">
<short>FPC internal compiler routine: ReRaise</short>
</element>


<element name="fpc_reset_typed">
<short>FPC internal compiler routine: reset_typed</short>
</element>


<element name="fpc_rewrite_typed">
<short>FPC internal compiler routine: rewrite_typed</short>
</element>


<element name="fpc_round_real">
<short>FPC internal compiler routine: round_real</short>
</element>


<element name="fpc_set_add_sets">
<short>FPC internal compiler routine: set_add_sets</short>
</element>


<element name="fpc_set_comp_sets">
<short>FPC internal compiler routine: set_comp_sets</short>
</element>


<element name="fpc_set_contains_sets">
<short>FPC internal compiler routine: set_contains_sets</short>
</element>


<element name="fpc_set_create_element">
<short>FPC internal compiler routine: set_create_element</short>
</element>


<element name="fpc_set_in_byte">
<short>FPC internal compiler routine: set_in_byte</short>
</element>


<element name="fpc_set_load_small">
<short>FPC internal compiler routine: set_load_small</short>
</element>


<element name="fpc_set_mul_sets">
<short>FPC internal compiler routine: set_mul_sets</short>
</element>


<element name="fpc_set_set_byte">
<short>FPC internal compiler routine: set_set_byte</short>
</element>


<element name="fpc_set_set_range">
<short>FPC internal compiler routine: set_set_range</short>
</element>


<element name="fpc_set_sub_sets">
<short>FPC internal compiler routine: set_sub_sets</short>
</element>


<element name="fpc_set_symdif_sets">
<short>FPC internal compiler routine: set_symdif_sets</short>
</element>


<element name="fpc_set_unset_byte">
<short>FPC internal compiler routine: set_unset_byte</short>
</element>


<element name="fpc_shortstr_append_shortstr">
<short>FPC internal compiler routine: shortstr_append_shortstr</short>
</element>


<element name="fpc_shortstr_compare">
<short>FPC internal compiler routine: shortstr_compare</short>
</element>


<element name="fpc_shortstr_concat">
<short>FPC internal compiler routine: shortstr_concat</short>
</element>


<element name="fpc_shortstr_Copy">
<short>FPC internal compiler routine: shortstr_Copy</short>
</element>


<element name="fpc_ShortStr_Float">
<short>FPC internal compiler routine: ShortStr_Float</short>
</element>


<element name="fpc_shortstr_int64">
<short>FPC internal compiler routine: shortstr_int64</short>
</element>


<element name="fpc_shortstr_qword">
<short>FPC internal compiler routine: shortstr_qword</short>
</element>


<element name="fpc_Shortstr_SetLength">
<short>FPC internal compiler routine: Shortstr_SetLength</short>
</element>


<element name="fpc_ShortStr_sint">
<short>FPC internal compiler routine: ShortStr_sint</short>
</element>


<element name="fpc_ShortStr_To_AnsiStr">
<short>FPC internal compiler routine: ShortStr_To_AnsiStr</short>
</element>


<element name="fpc_shortstr_to_chararray">
<short>FPC internal compiler routine: shortstr_to_chararray</short>
</element>


<element name="fpc_shortstr_to_shortstr">
<short>FPC internal compiler routine: shortstr_to_shortstr</short>
</element>


<element name="fpc_shortstr_to_widechararray">
<short>FPC internal compiler routine: shortstr_to_widechararray</short>
</element>


<element name="fpc_ShortStr_To_WideStr">
<short>FPC internal compiler routine: ShortStr_To_WideStr</short>
</element>


<element name="fpc_shortstr_uint">
<short>FPC internal compiler routine: shortstr_uint</short>
</element>


<element name="fpc_sin_real">
<short>FPC internal compiler routine: sin_real</short>
</element>


<element name="fpc_sqr_real">
<short>FPC internal compiler routine: sqr_real</short>
</element>


<element name="fpc_sqrt_real">
<short>FPC internal compiler routine: sqrt_real</short>
</element>


<element name="fpc_trunc_real">
<short>FPC internal compiler routine: trunc_real</short>
</element>


<element name="fpc_typed_read">
<short>FPC internal compiler routine: typed_read</short>
</element>


<element name="fpc_typed_write">
<short>FPC internal compiler routine: typed_write</short>
</element>


<element name="fpc_Val_int64_AnsiStr">
<short>FPC internal compiler routine: Val_int64_AnsiStr</short>
</element>


<element name="fpc_val_int64_shortstr">
<short>FPC internal compiler routine: val_int64_shortstr</short>
</element>


<element name="fpc_Val_int64_WideStr">
<short>FPC internal compiler routine: Val_int64_WideStr</short>
</element>


<element name="fpc_Val_qword_AnsiStr">
<short>FPC internal compiler routine: Val_qword_AnsiStr</short>
</element>


<element name="fpc_val_qword_shortstr">
<short>FPC internal compiler routine: val_qword_shortstr</short>
</element>


<element name="fpc_Val_qword_WideStr">
<short>FPC internal compiler routine: Val_qword_WideStr</short>
</element>


<element name="fpc_Val_Real_AnsiStr">
<short>FPC internal compiler routine: Val_Real_AnsiStr</short>
</element>


<element name="fpc_Val_Real_ShortStr">
<short>FPC internal compiler routine: Val_Real_ShortStr</short>
</element>


<element name="fpc_Val_Real_WideStr">
<short>FPC internal compiler routine: Val_Real_WideStr</short>
</element>


<element name="fpc_Val_SInt_AnsiStr">
<short>FPC internal compiler routine: Val_SInt_AnsiStr</short>
</element>


<element name="fpc_Val_SInt_ShortStr">
<short>FPC internal compiler routine: Val_SInt_ShortStr</short>
</element>


<element name="fpc_Val_SInt_WideStr">
<short>FPC internal compiler routine: Val_SInt_WideStr</short>
</element>


<element name="fpc_Val_UInt_AnsiStr">
<short>FPC internal compiler routine: Val_UInt_AnsiStr</short>
</element>


<element name="fpc_Val_UInt_Shortstr">
<short>FPC internal compiler routine: Val_UInt_Shortstr</short>
</element>


<element name="fpc_Val_UInt_WideStr">
<short>FPC internal compiler routine: Val_UInt_WideStr</short>
</element>


<element name="fpc_vararray_get">
<short>FPC internal compiler routine: vararray_get</short>
</element>


<element name="fpc_vararray_put">
<short>FPC internal compiler routine: vararray_put</short>
</element>


<element name="fpc_variant_copy">
<short>FPC internal compiler routine: variant_copy</short>
</element>


<element name="fpc_variant_to_dynarray">
<short>FPC internal compiler routine: variant_to_dynarray</short>
</element>


<element name="fpc_variant_to_interface">
<short>FPC internal compiler routine: variant_to_interface</short>
</element>


<element name="fpc_WideCharArray_To_AnsiStr">
<short>FPC internal compiler routine: WideCharArray_To_AnsiStr</short>
</element>


<element name="fpc_WideCharArray_To_ShortStr">
<short>FPC internal compiler routine: WideCharArray_To_ShortStr</short>
</element>


<element name="fpc_WideCharArray_To_WideStr">
<short>FPC internal compiler routine: WideCharArray_To_WideStr</short>
</element>


<element name="fpc_WideStr_Assign">
<short>FPC internal compiler routine: WideStr_Assign</short>
</element>


<element name="fpc_WideStr_CheckRange">
<short>FPC internal compiler routine: WideStr_CheckRange</short>
</element>


<element name="fpc_WideStr_CheckZero">
<short>FPC internal compiler routine: WideStr_CheckZero</short>
</element>


<element name="fpc_WideStr_Compare">
<short>FPC internal compiler routine: WideStr_Compare</short>
</element>


<element name="fpc_WideStr_Concat">
<short>FPC internal compiler routine: WideStr_Concat</short>
</element>


<element name="fpc_WideStr_Concat_multi">
<short>FPC internal compiler routine: WideStr_Concat_multi</short>
</element>


<element name="fpc_widestr_Copy">
<short>FPC internal compiler routine: widestr_Copy</short>
</element>


<element name="fpc_WideStr_Decr_Ref">
<short>FPC internal compiler routine: WideStr_Decr_Ref</short>
</element>


<element name="fpc_WideStr_Float">
<short>FPC internal compiler routine: WideStr_Float</short>
</element>


<element name="fpc_WideStr_Incr_Ref">
<short>FPC internal compiler routine: WideStr_Incr_Ref</short>
</element>


<element name="fpc_widestr_int64">
<short>FPC internal compiler routine: widestr_int64</short>
</element>


<element name="fpc_widestr_qword">
<short>FPC internal compiler routine: widestr_qword</short>
</element>


<element name="fpc_WideStr_SetLength">
<short>FPC internal compiler routine: WideStr_SetLength</short>
</element>


<element name="fpc_WideStr_sint">
<short>FPC internal compiler routine: WideStr_sint</short>
</element>


<element name="fpc_WideStr_To_AnsiStr">
<short>FPC internal compiler routine: WideStr_To_AnsiStr</short>
</element>


<element name="fpc_widestr_to_chararray">
<short>FPC internal compiler routine: widestr_to_chararray</short>
</element>


<element name="fpc_WideStr_To_ShortStr">
<short>FPC internal compiler routine: WideStr_To_ShortStr</short>
</element>


<element name="fpc_widestr_to_widechararray">
<short>FPC internal compiler routine: widestr_to_widechararray</short>
</element>


<element name="fpc_WideStr_uint">
<short>FPC internal compiler routine: WideStr_uint</short>
</element>


<element name="fpc_widestr_Unique">
<short>FPC internal compiler routine: widestr_Unique</short>
</element>


<element name="fpc_Write_End">
<short>FPC internal compiler routine: Write_End</short>
</element>


<element name="fpc_Writeln_End">
<short>FPC internal compiler routine: Writeln_End</short>
</element>


<element name="fpc_Write_Text_AnsiStr">
<short>FPC internal compiler routine: Write_Text_AnsiStr</short>
</element>


<element name="fpc_Write_Text_Boolean">
<short>FPC internal compiler routine: Write_Text_Boolean</short>
</element>


<element name="fpc_Write_Text_Char">
<short>FPC internal compiler routine: Write_Text_Char</short>
</element>


<element name="fpc_Write_Text_Float">
<short>FPC internal compiler routine: Write_Text_Float</short>
</element>


<element name="fpc_write_text_int64">
<short>FPC internal compiler routine: write_text_int64</short>
</element>


<element name="fpc_Write_Text_Pchar_as_Array">
<short>FPC internal compiler routine: Write_Text_Pchar_as_Array</short>
</element>


<element name="fpc_Write_Text_PChar_As_Pointer">
<short>FPC internal compiler routine: Write_Text_PChar_As_Pointer</short>
</element>


<element name="fpc_write_text_qword">
<short>FPC internal compiler routine: write_text_qword</short>
</element>


<element name="fpc_Write_Text_ShortStr">
<short>FPC internal compiler routine: Write_Text_ShortStr</short>
</element>


<element name="fpc_Write_Text_SInt">
<short>FPC internal compiler routine: Write_Text_SInt</short>
</element>


<element name="fpc_Write_Text_UInt">
<short>FPC internal compiler routine: Write_Text_UInt</short>
</element>


<element name="fpc_write_text_variant">
<short>FPC internal compiler routine: write_text_variant</short>
</element>


<element name="fpc_Write_Text_WideChar">
<short>FPC internal compiler routine: Write_Text_WideChar</short>
</element>


<element name="fpc_Write_Text_WideStr">
<short>FPC internal compiler routine: Write_Text_WideStr</short>
</element>

<!-- function Visibility: default -->
<element name="Align">
<short>Return aligned version of an address</short>
<descr>
<var>Align</var> returns <var>Address</var>, aligned to <var>Alignment</var>
bytes.
</descr>
<errors>
None.
</errors>
</element>

<element name="ArrayStringToPPchar">
<short>Concert an array of string to an array of null-terminated strings</short>
<descr>
<p>
<var>ArrayStringToPPchar</var> creates an array of null-terminated strings
that point to strings which are the same as the strings in the array
<var>S</var>. The function returns a pointer to this array. The array and
the strings it contains must be disposed of after being used, because it 
they are allocated on the heap.
</p>
<p>
The <var>ReserveEntries</var> parameter tells <var>ArrayStringToPPchar</var>
to allocate room at the end of the array for another <var>ReserveEntries</var>
entries.
</p>
</descr>
<errors>
If not enough memory is available, an error may occur.
</errors>
<seealso>
<link id="StringToPPChar"/>
</seealso>
</element>

<element name="StringToPPChar">
<short>Split string in list of null-terminated strings</short>
<descr>
<p>
<var>StringToPPChar</var> splits the string <var>S</var> in words, replacing any
whitespace with zero characters. It returns a pointer to an array of pchars
that point to the first letters of the words in <var>S</var>. This array is terminated
by a <var>Nil</var> pointer.
</p>
<p>
The function does <em>not</em> add a zero character to the end of the string
unless it ends on whitespace.
</p>
<p>
The function reserves memory on the heap to store the array of <var>PChar</var>;
The caller is responsible for freeing this memory. 
</p>
<p>
This function is only available on certain platforms.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ArrayStringToPPchar"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="varempty">
<short>Variant type: <var>Empty</var> variant</short>
</element>

<!-- constant Visibility: default -->
<element name="varnull">
<short>Variant type: <link id="Null"/> variant</short>
</element>

<!-- constant Visibility: default -->
<element name="varsmallint">
<short>Variant type: smallint (8 bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varinteger">
<short>Variant type: Integer (32-bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varsingle">
<short>Variant type: Single float</short>
</element>

<!-- constant Visibility: default -->
<element name="vardouble">
<short>Variant type: Double float</short>
</element>

<!-- constant Visibility: default -->
<element name="varcurrency">
<short>Variant type: Currency</short>
</element>

<!-- constant Visibility: default -->
<element name="vardate">
<short>Variant type: Date</short>
</element>

<!-- constant Visibility: default -->
<element name="varolestr">
<short>Variant type: OLE string (widestring)</short>
</element>

<!-- constant Visibility: default -->
<element name="vardispatch">
<short>Variant type: dispatch interface</short>
</element>

<!-- constant Visibility: default -->
<element name="varerror">
<short>Variant type: Error type</short>
</element>

<!-- constant Visibility: default -->
<element name="varboolean">
<short>Variant type: Boolean type</short>
</element>

<!-- constant Visibility: default -->
<element name="varvariant">
<short>Variant type: Variant (arrays only)</short>
</element>

<!-- constant Visibility: default -->
<element name="varunknown">
<short>Variant type: Unknown</short>
</element>

<!-- constant Visibility: default -->
<element name="vardecimal">
<short>Variant type: Decimal (BCD)</short>
</element>

<!-- constant Visibility: default -->
<element name="varshortint">
<short>Variant type: Shortint (16 bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varbyte">
<short>Variant type: Byte (8 bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varword">
<short>Variant type: Word (16 bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varlongword">
<short>Variant type: Word (32 bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varint64">
<short>Variant type: Integer (64-Bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varqword">
<short>Variant type: Word (64-bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varstrarg">
<short>Variant type: String</short>
</element>

<!-- constant Visibility: default -->
<element name="varstring">
<short>Variant type: String</short>
</element>

<!-- constant Visibility: default -->
<element name="varany">
<short>Variant type: Any</short>
</element>

<!-- constant Visibility: default -->
<element name="vartypemask">
<short>Variant type: Mask to extract type</short>
</element>

<!-- constant Visibility: default -->
<element name="vararray">
<short>Variant type: variant Array</short>
</element>

<!-- constant Visibility: default -->
<element name="varbyref">
<short>Variant type: By reference</short>
</element>

<!-- constant Visibility: default -->
<element name="varword64">
<short>Variant type: Word (64-bit)</short>
</element>

<!-- alias type Visibility: default -->
<element name="tvartype">
<short>Type with size of variant type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararrayboundarray">
<short>Pointer to <link id="tvararrayboundarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraycoorarray">
<short>Pointer to <link id="tvararraycoorarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraybound">
<short>Pointer to <link id="tvararraybound"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararray">
<short>Pointer to <link id="TVarArray"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararraybound">
<short>Type describing variant array bounds.</short>
<descr>
<var>tvararraybound</var> is used to describe one dimension in a variant
array.
</descr>
<seealso>
<link id="tvararray"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.elementcount">
<short>Number of elements in this array dimension.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.lowbound">
<short>Lower bound of this array dimension (index of first element).</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararray">
<short>Type describing variant array</short>
<descr>
<var>tvararray</var> is a record describing a variant array. It contains
some general data, followed by a number of <link id="TVarArrayBound"/>
records equal to the number of dimensions in the array (<var>dimcoun</var>).
</descr>
<seealso>
<link id="TVarArrayBound"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.dimcount">
<short>Number of dimensions</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.flags">
<short>Array flags.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.elementsize">
<short>Size of one element in the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.lockcount">
<short>Lock (reference) count of the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.data">
<short>Pointer to the array data.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.bounds">
<short>Array describing the bounds in the array.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararrayboundarray">
<short>array of <link id="tvararraybound"/> records.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararraycoorarray">
<short>Array of variant array coordinates</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="tvarop">
<short>Variant operation.</short>
<descr>
<var>tvarop</var> describes a variant operation. It is mainly used for the
variant manager to implement the various conversions and mathematical
operations on a variant.
</descr>
<seealso>
<link id="TVariantManager"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opadd">
<short>Variant operation: Addition.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opsubtract">
<short>Variant operation: Substraction</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmultiply">
<short>Variant operation: multiplication</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opdivide">
<short>Variant operation: division</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opintdivide">
<short>Variant operation: integer divide</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmodulus">
<short>Variant operation: Modulus</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftleft">
<short>Variant operation: Shift left</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftright">
<short>Variant operation: Shift right</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opand">
<short>Variant operation: Binary AND operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opor">
<short>Variant operation: Binary OR operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opxor">
<short>Variant operation: binary XOR operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcompare">
<short>Variant operation: Compare</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnegate">
<short>Variant operation: negation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnot">
<short>Variant operation: Binary NOT operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpeq">
<short>Variant operation: Compare equal.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpne">
<short>Variant operation: Compare not equal</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmplt">
<short>Variant operation: Compare less than.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmple">
<short>Variant operation: Compare less than or equal to</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpgt">
<short>Variant operation: Compare larger than</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpge">
<short>Variant operation: Compare larger than or equal</short>
</element>

<!-- record type Visibility: default -->
<element name="tvardata">
<short>Variant record.</short>
<descr>
<var>TVarData</var> is a record representation of a variant. It contains the
internal structure of a variant and is handled by the various variant
handling routines.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vtype">
<short>Type of variant.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvardata">
<short>Pointer to <link id="TVarData"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcalldesc">
<short>Pointer to <link id="TCallDesc"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tcalldesc">
<short>COM/OLE dispatch call argument description.</short>
<descr>
<var>tcalldesc</var> is used to encode the arguments to a dispatch call to 
an OLE dual interface. It is used on windows only. It describes the 
arguments to a call.
</descr>
</element>


<!-- variable Visibility: default -->
<element name="tcalldesc.calltype">
<short>Call type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argcount">
<short>Number of arguments to call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.namedargcount">
<short>Number of named arguments in the call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argtypes">
<short>Types of arguments.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="tdispdesc">
<short>COM/OLE dispatch call description.</short>
<descr>
<var>tcalldesc</var> is used to encode a dispatch call to an OLE dispatch 
interface. It is used on windows only. It describes the dispath call call.
</descr>
<seealso>
<link id="tcalldesc"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="pdispdesc">
<short>Pointer to <link id="tdispdesc"/> record</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.dispid">
<short>Dispatch ID</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.restype">
<short>Result type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.calldesc">
<short>Arguments description.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvariantmanager">
<short>Record describing the variant manager.</short>
<descr>
<var>TVariantManager</var> describes the variant manager as expected by the
<link id="SetVariantManager"/> call.
</descr>
<seealso>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint">
<short>Called to convert a variant to an integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint64">
<short>Called to convert a variant to an int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoword64">
<short>Called to convert a variant to a word64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartobool">
<short>Called to convert a variant to a boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoreal">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartocurr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartopstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartolstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartowstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartointf">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodisp">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodynarray">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrombool">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromword64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromreal">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromwstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromintf">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdisp">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdynarray">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromvar">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varop">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.cmpop">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varneg">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varnot">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varinit">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varclear">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varaddref">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcopy">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcast">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcastole">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.dispinvoke">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayredim">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayget">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayput">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.writevariant">
<short>Called to perform a variant operation:</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.write0Variant">
<short>Called to perform a variant operation:</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvariantmanager">
<short>Pointer to <link id="TVariantManager"/> record.</short>
</element>

<!-- procedure Visibility: default -->
<element name="GetVariantManager">
<short>Return the current variant manager.</short>
<descr>
<var>GetVariantManager</var> returns the current variant manager in
<var>varmgr</var>.
</descr>
<seealso>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetVariantManager">
<short>Set the current variant manager.</short>
<descr>
<var>SetVariantManager</var> sets the variant manager to <var>varmgr</var>.
</descr>
<seealso>
<link id="GetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="VarDispProc">
<short>Callback to perform dispatch interface procedure call by name.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant. For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  V.OpenDocument('c:\temp\mydoc.doc');
end;  
</code>
<p>
is encoded by the compiler and passed to <var>VarDispProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
<seealso>
<link id="DispCallByIDProc"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DispCallByIDProc">
<short>Callback to perform dispatch interface procedure call by ID.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant which contains a dispatch interface. 
For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  (V as IWord).OpenDocument('c:\temp\mydoc.doc');
end;
</code>    
<p>
where <var>IWord</var> is a dispatch interface is encoded by the compiler and 
passed to <var>DispCallByIDProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="Null">
<short>Null variant</short>
</element>

<!-- variable Visibility: default -->
<element name="Unassigned">
<short>Unassigned variant.</short>
</element>

<!-- record type Visibility: default -->
<element name="THeapStatus">
<short>Record describing current heap status.</short>
<descr>
<var>THeapStatus</var> is the record describing the current heap status. It
is returned by the <link id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapSize">
<short>Biggest heap size used.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapUsed">
<short>Biggest used part of heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapSize">
<short>Current heap size.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapUsed">
<short>Current size of used heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapFree">
<short>Current size of free heap memory.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SysGetHeapStatus">
<short>System implementation of <link id="GetHeapStatus"/></short>
<descr>
<var>SysGetHeapStatus</var> is the system implementation of the <link
id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Heapsize">
<short>Current heap size</short>
<descr>
<var>HeapSize</var> returns the current heap size. The heap grows
dynamically (as allowed by the OS) and the <var>HeapSize</var> reflects the
current state of the heap.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TThreadID">
<short>Type for Thread-IDs</short>
<descr>
This is an opaque type, it can differ from operating system to operating
system.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PRTLCriticalSection">
<short>Pointer to <link id="#rtl.system.TRTLCriticalSection"/> type.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRTLCriticalSection" opaque="1">
<short>A critical section.</short>
<descr>
<var>TRTLCriticalSection</var> represents a critical section (a mutex). This is an opaque type, 
it can differ from operating system to operating system. No assumptions
should be made about it's structure or contents. 
</descr>
<seealso>
<link id="InitCriticalSection"/>
<link id="DoneCriticalSection"/>
<link id="EnterCriticalSection"/>
<link id="LeaveCriticalSection"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="InitProc">
<short>Initialization routine</short>
<descr>
<p>
<var>InitProc</var> is a routine that can be called after all units were
initialized. It can be set by units to execute code that can be initialized
after all units were initialized.
</p>
<remark>
When setting the value of <var>InitProc</var>, the previous value should
always be saved, and called when the installed initialization routine has
finished executing. 
</remark>
</descr>
<seealso>
<link id="ExitProc"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetProcessID">
<short>Get the current process ID</short>
<descr>
<var>GetProcessID</var> returns the current process ID. 
The meaning of the return value of this call is system dependent.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetThreadID"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetThreadID">
<short>Get the current Thread ID.</short>
<descr>
<var>GetThreadID</var> returns the current process ID. 
The meaning of the return value of this call is system dependent.
</descr>
<seealso>
<link id="GetProcessID"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="S_OK">
<short>Interface call result: OK</short>
</element>

<!-- constant Visibility: default -->
<element name="S_FALSE">
<short>Interface call result: Not OK</short>
</element>

<!-- constant Visibility: default -->
<element name="E_NOINTERFACE">
<short>Interface call result: Error: not an interface</short>
</element>

<!-- constant Visibility: default -->
<element name="E_UNEXPECTED">
<short>Interface call result: Unexpected error</short>
</element>

<!-- constant Visibility: default -->
<element name="E_NOTIMPL">
<short>Interface call result: Interface not implemented</short>
</element>

<!-- record type Visibility: default -->
<element name="TMethod">
<short>Record describing a method.</short>
<descr>
<var>TMethod</var> describes a general method pointer, and is used in
Run-Time Type Information handling.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMethod.Code">
<short>Pointer to method code.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMethod.Data">
<short>Pointer to object instance.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Framecount">
<short>Number of frames in the exception object</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Frames">
<short>Pointer to array of frame pointers</short>
</element>

<!-- constant Visibility: default -->
<element name="RaiseMaxFrameCount">
<short>Maximum number of frames to include in <link id="#rtl.system.TExceptObject">TExceptObject</link></short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.oppower">
<short>Variant operation: Power</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartotdatetime">
<short>Callback to convert a variant to a <var>TDatetime</var> value.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromtdatetime">
<short>Callback to convert a <var>TDateTime</var> value to a variant.</short>
</element> 

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromcurr">
<short>Callback to convert a variant to a currency value.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarClearProc">
<short>Callback to clear a variant.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarAddRefProc">
<short>Callback to increase reference count of a variant.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarCopyProc">
<short>Callback to copy a variant</short>
</element>

<!-- constant Visibility: default -->
<element name="VarToLStrProc">
<short>Callback to convert a variant to a ansistring.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarToWStrProc">
<short>Callback to convert a variant to a widestring.</short>
</element>

<!-- procedure Visibility: default -->
<element name="VarArrayRedim">
<short>Redimension a variant array</short>
<descr>
<var>VarArrayRedim</var> re-sizes the first dimension of the variant array
<var>A</var>, giving it a new high bound <var>HighBound</var>. 
Obviously, <var>A</var> must be a variant array for this function to work.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="fpc_big_widechararray" skip="1">
<short>Internal type used by widestring routines. Do not use</short>
</element>

<!-- constant Visibility: default -->
<element name="DefaultStackSize">
<short>Default size for a new thread's stack (4MiB by default).</short>
</element>

<!-- alias type Visibility: default -->
<element name="PEventState">
<short>Pointer to EventState, which is an opaque type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PRTLEvent">
<short>Pointer to RTLEvent, which is an opaque type.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadFunc">
<short>Thread function prototype</short>
</element>

<!-- procedure type Visibility: default -->
<element name="trtlmethod">
<short>Callback type for synchronization event.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBeginThreadHandler">
<short>Callback for thread start in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TEndThreadHandler">
<short>Callback for thread end in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadHandler">
<short>Generic thread handler callback for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadSwitchHandler">
<short>Callback type for thread switch in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TWaitForThreadTerminateHandler">
<short>Callback type for thread termination in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadSetPriorityHandler">
<short>Callback type for thread priority setting in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadGetPriorityHandler">
<short>Callback type for thread priority getting in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TGetCurrentThreadIdHandler">
<short>Callback type for retrieving thread ID in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TCriticalSectionHandler">
<short>Generic callback type for critical section handling in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TInitThreadVarHandler">
<short>Threadvar initialization callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TRelocateThreadVarHandler">
<short>Threadvar relocalization callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAllocateThreadVarsHandler">
<short>Threadvar allocation callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TReleaseThreadVarsHandler">
<short>Threadvar release callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TBasicEventHandler">
<short>Generic callback type for handling eventstate in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBasicEventWaitForHandler">
<short>Wait for basic event callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBasicEventCreateHandler">
<short>callback type for creating eventstate in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventHandler">
<short>Generic TRTLEvent handling type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventHandlerTimeout">
<short>TRTLEvent timeout handling type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TRTLCreateEventHandler">
<short>Callback type for creating a <var>TRTLEvent</var> type in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventSyncHandler">
<short>Callback type for event sycnhronization in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- record type Visibility: default -->
<element name="TThreadManager">
<short>Thread manager record.</short>
<descr>
<p>
<var>TThreadManager</var> is a record that contains all callbacks needed for the thread handling
routines of the Free Pascal Run-Time Library. The thread manager can be set
by the <link id="SetThreadManager"/> procedure, and the current thread
manager can be retrieved with the <link id="GetThreadManager"/> procedure.
</p>
<p>
The Windows RTL will set the thread manager automatically to a system thread
manager, based on the Windows threading routines. Unix operating systems
provide a unit <file>cthreads</file> which implements threads based on the C
library POSIX thread routines. It is not included by default, because it
would make the system unit dependent on the C library.
</p>

<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<seealso>
<link id="GetThreadManager"/>
<link id="SetThreadManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitManager">
<short>Initialize the thread manager.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.DoneManager">
<short>Clean up the thread manager.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BeginThread">
<short>Start a new thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.EndThread">
<short>End the current thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SuspendThread">
<short>Suspend a running thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ResumeThread">
<short>Resumt a suspended thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.KillThread">
<short>Kill a running thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadSwitch">
<short>Cause a threadswitch.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.WaitForThreadTerminate">
<short>Wait for a thread to stop.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadSetPriority">
<short>Set thread priority</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadGetPriority">
<short>Get thread priority.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.GetCurrentThreadId">
<short>Get current thread ID</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitCriticalSection">
<short>Initialize a critical section.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.DoneCriticalSection">
<short>Free a critical section</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.EnterCriticalSection">
<short>Enter a critical section</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.LeaveCriticalSection">
<short>leave a critical section.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitThreadVar">
<short>Initialize a thread variable.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RelocateThreadVar">
<short>Relocate a thread variable.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.AllocateThreadVars">
<short>Allocate thread variables.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ReleaseThreadVars">
<short>Release thread variables.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventCreate">
<short>Create a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventDestroy">
<short>Destroy a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventResetEvent">
<short>Reset a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventSetEvent">
<short>Set a basic event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasiceventWaitFOr">
<short>Wait for a basic event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventCreate">
<short>Create an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventDestroy">
<short>Free an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventSetEvent">
<short>Set an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventResetEvent">
<short>Reset an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventStartWait">
<short>Wait for an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventWaitFor">
<short>Wait for an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventSync">
<short>Synchronize an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventWaitForTimeout">
<short>Wait for RTL event, with timeout.</short>
</element>

<!-- function Visibility: default -->
<element name="GetThreadManager">
<short>Return the current thread manager</short>
<descr>
<p>
<var>GetThreadManager</var> returns the currently used thread manager in
<var>TM</var>.
</p>
<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<seealso>
<link id="SetThreadManager"/>
<link id="TThreadManager"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetThreadManager">
<short>Set the thread manager, optionally return the current thread manager.</short>
<descr>
<p>
<var>SetThreadManager</var> sets the thread manager to <var>NewTM</var>.
If <var>OldTM</var> is given, <var>SetThreadManager</var> uses it to return the
previously used thread manager.
</p>
<p>
The function returns <var>True</var> if the threadmanager was set
succesfully, <var>False</var> if an error occurred.
</p>
<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<errors>
If an error occurred cleaning up the previous manager, or an error occurred
initializing the new manager, <var>False</var> is returned.
</errors>
<seealso>
<link id="GetThreadManager"/>
<link id="TThreadManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetNoThreadManager">
<short>Clear the threadmanager</short>
<descr>
<var>SetNoThreadManager</var> clears the thread manager by setting the
thread manager to an empty thread manager record.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="InitThread">
<short>Initialize a thread</short>
<descr>
Do not use, this is used internally by the thread manager.
</descr>
</element>

<!-- function Visibility: default -->
<element name="BeginThread">
<short>Start a new thread.</short>
<descr>
<p>
<var>BeginThread</var> starts a new thread and executes
<var>ThreadFunction</var> in the new thread. If <var>P</var> is specified,
then it is passed to <var>ThreadFunction</var>. If <var>ThreadId</var> is
specified, it is filled with the thread ID of the newly started thread. If
<var>StackSize</var> is specified, it is set as the stack size for the new
thread. If none is specified, a default stack size of 4MiB is used.
</p> 
<p>
The function returns the thread handle (or ID, on some other operating systems
like Linux or OS/2) on success, or 0 if an error occurred.
Note that the thread ID and handle are the same on Unix processes, and that
the thread ID and thread handle are different on windows systems.
</p>
</descr>
<errors>
On error, the value "0" is returned.
</errors>
<seealso>
<link id="EndThread"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="EndThread">
<short>End the current thread.</short>
<descr>
<p>
<var>EndThread</var> ends the current thread. If <var>ExitCode</var> is
supplied, it is returned as the exit code for the thread to a function
waiting for the thread to terminate (<link id="WaitForThreadTerminate"/>).
If it is omitted, zero is used.
</p>
<p>
This function does not return.
</p>
</descr>
<seealso>
<link id="WaitForThreadTerminate"/>
<link id="BeginThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SuspendThread">
<short>Suspend a running thread.</short>
<descr>
<p>
<var>SuspendThread</var> suspends a running thread. The thread is identified
with it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is system
dependent.
</errors>
<seealso>
<link id="ResumeThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ResumeThread">
<short>Resume a suspended thread.</short>
<descr>
<p>
<var>ResumeThread</var> causes a suspended thread (using <link
id="SuspendThread"/>) to resume it's execution. The thread is 
identified with it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is system
dependent.
</errors>
<seealso>
<link id="SuspendThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ThreadSwitch">
<short>Signal possibility of thread switch</short>
<descr>
<p>
<var>ThreadSwitch</var> signals the operating system that the thread should
be suspended and that another thread should be executed.
</p>
<p>
This call is a hint only, and may be ignored.
</p>
</descr>
<seealso>
<link id="SuspendThread"/>
<link id="ResumeThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="KillThread">
<short>Kill a running thread</short>
<descr>
<p>
<var>KillThread</var> causes a running thread to be aborted. The thread is
identified by it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is system
dependent.
</errors>
<seealso>
<link id="WaitForThreadTerminate"/>
<link id="EndThread"/>
<link id="SuspendThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WaitForThreadTerminate">
<short>Wait for a thread to terminate.</short>
<descr>
<p>
<var>WaitForThreadTerminate</var> waits for a thread to finish its
execution. The thread is identified by it's handle or ID
<var>threadHandle</var>. If the thread does not exit within <var>TimeoutMs</var>
milliseconds, the function will return with an error value. 
</p>
<p>
The function returns the exit code of the thread.
</p>
<p>
Not all platforms support the timeout parameter: the Unix platforms (with threads support
based on pthreads) do not support timeout, and will wait indefinitely for
the thread to exit.
</p>
</descr>
<seealso>
<link id="EndThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ThreadSetPriority">
<short>Set the priority of a thread.</short>
<descr>
<var>ThreadSetPriority</var> sets the priority of thread <var>TThreadID</var> to <var>Prio</var>.
Priority is a value between -15 and 15. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ThreadGetPriority"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ThreadGetPriority">
<short>Return the priority of a thread.</short>
<descr>
<var>ThreadGetPriority</var> returns the priority of thread
<var>TThreadID</var> to <var>Prio</var>. The returned priority
is a value between -15 and 15.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ThreadSetPriority"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetCurrentThreadId">
<short>Return the id of the currently running thread.</short>
<descr>
<var>GetCurrentThreadId</var> returns the ID of the currently running
thread. It can be used in calls such as <link id="KillThread"/> or 
<link id="ThreadSetPriority"/>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="KillThread"/>
<link id="ThreadSetPriority"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="InitCriticalSection">
<short>Initialize a critical section</short>
<descr>
<p>
<var>InitCriticalSection</var> initializes a critical section <var>CS</var>
for use. Before using a critical section with <link id="EnterCriticalsection"/> or
<link id="LeaveCriticalsection"/> the critical section should be initialized
with <var>InitCriticalSection</var>.
</p>
<p>
When a critical section is no longer used, it should be disposed of with
<link id="DoneCriticalsection"/>
</p>
</descr>
<seealso>
<link id="DoneCriticalsection"/>
<link id="EnterCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DoneCriticalsection">
<short>Clean up a critical section.</short>
<descr>
<var>DoneCriticalsection</var> cleans up the critical section <var>CS</var>.
After a call to <var>DoneCriticalsection</var>, the critical section can no
longer be used with <link id="EnterCriticalsection"/> or
<link id="LeaveCriticalsection"/>, unless it is again initialized with <link
id="InitCriticalSection"/>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="EnterCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="EnterCriticalSection">
<short>Enter a critical section</short>
<descr>
<p>
<var>EnterCriticalSection</var> will suspend the current thread if another
thread has currently entered the critical section. When the other thread has
left the critical section (through <link id="LeaveCriticalSection"/>), the
current thread resumes execution. The result is that only 1 thread is
executing code which is protected by a <var>EnterCriticalsection</var> and 
<var>LeaveCriticalSection</var> pair.
</p>
<p>
The critical section must have been initialized with <link id="InitCriticalSection"/>
prior to a call to <var>EnterCriticalsection</var>.
</p>
<p>
A call to <var>EnterCriticalsection</var> must always be matched by a call
to <link id="LeaveCriticalSection"/>. To avoid problems, it is best to
include the code to be execute in a <var>try...finally</var> block, as
follows:
</p>
<code>
  EnterCriticalSection(Section);
  Try 
    // Code to be protected goes here.
  Finally
    LeaveCriticalSection(Section);
  end;
</code>
<p>
For performance reasons it is best to limit the code between the entering
and leaving of a critical section as short as possible.
</p>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="DoneCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="LeaveCriticalsection">
<short>Leave a critical section</short>
<descr>
<p>
<var>LeaveCriticalSection</var> signals that the current thread is exiting
the critical section <var>CS</var> it has entered with <link id="EnterCriticalSection"/>.
</p>
<p>
The critical section must have been initialized with <link id="InitCriticalSection"/>
prior to a call to <var>EnterCriticalsection</var> and <var>LeaveCriticalSection</var>.
</p>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="DoneCriticalsection"/>
<link id="EnterCriticalsection"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BasicEventCreate">
<short>Obsolete. Don't use</short>
<descr>
<var>BasicEventCreate</var> is obsolete, use <link id="RTLEventCreate"/>
instead.
</descr>
<seealso>
<link id="RTLEventCreate"/></seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventdestroy">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventdestroy</var> is obsolete. Use <link id="RTLEventDestroy"/>
instead.
</descr>
<seealso>
<link id="RTLEventDestroy"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventResetEvent">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventResetEvent</var> is obsolete. Use <link id="RTLEventResetEvent"/>
instead.
</descr>
<seealso>
<link id="RTLEventResetEvent"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventSetEvent">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventSetEvent</var> is obsolete. Use <link id="RTLEventSetEvent"/>
instead.
</descr>
<seealso>
<link id="RTLEventSetEvent"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="basiceventWaitFor">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventwaitfor</var> is obsolete. Use <link id="RTLEventWaitFor"/>
instead.
</descr>
<seealso>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RTLEventCreate">
<short>Create a new RTL event</short>
<descr>
<p>
<var>RTLEventCreate</var> creates and initializes a new RTL event.  RTL
events are used to notify other threads that a certain condition is met, 
and to notify other threads of condition changes (conditional variables).
</p>
<p>
The function returns an initialized RTL event, which must be disposed of
with <link id="RTLEventdestroy"/>
</p>
<p>
<var>RTLEvent</var> is used mainly for the synchronize method.
</p>
</descr>
<seealso>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventReSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventdestroy">
<short>Destroy a RTL Event</short>
<descr>
<var>RTLeventdestroy</var> destroys the RTL event <var>State</var>.
After a call to <var>RTLeventdestroy</var>, the <var>State</var> RTL event
may no longer be used.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventResetEvent"/>
<link id="RTLEventSetEvent"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventSetEvent">
<short>Notify threads of the event.</short>
<descr>
<var>RTLeventSetEvent</var> notifies other threads which are listening, 
that the event has occurred.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventResetEvent"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventResetEvent">
<short>Reset an event</short>
<descr>
<var>RTLeventResetEvent</var> resets the event: this should be used to undo
the signaled state of an event. Resetting an event that is not set (or was
already reset) has no effect.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventStartWait">
<short>Prepare the event for waiting.</short>
<descr>
<p>
<var>RTLeventResetEvent</var> signals that a thread is ready to start
waiting on an event <var>state</var>. No event can be posted until a thread explicitly 
starts waiting on the event using <link id="RTLEventWaitFor"/>.
</p>
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventWaitFor">
<short>Wait for an event.</short>
<descr>
<p>
<var>RTLeventWaitFor</var> suspends the thread till the event occurs. The
event will occur when another thread calls <link id="RTLEventSetEvent"/> on
<var>State</var>.
</p>
<p>
By default, the thread will be suspended indefinitely. However, if
<var>TimeOut</var> is specified, then the thread will resume after timeout
milliseconds have elapsed.
</p>
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventsync">
<short>Obsolete. Don't use</short>
<descr>
<var>RTLeventsync</var> is obsolete, don't use it.
</descr>
</element>

<element name="ThreadingAlreadyUsed">
<short>Internal constant for the threading system. Don't use.</short>
</element>



<!-- constant Visibility: default -->
<element name="CtrlZMarksEOF">
<short>Determine whether CTRL-Z marks the end of file.</short>
<descr>
<p>
<var>CtrlZMarksEOF</var> indicates whether on this system, an
<var>CTRL-Z</var> character (ordinal 26) in a file marks the 
end of the file. This is <var>False</var> on most systems apart from DOS and Windows.
</p>
<p>
To get DOS/Windows-compatible behaviour, this constant can be set to <var>True</var>
</p>
</descr>
<seealso>
<link id="LineEnding"/>
<link id="SetTextLineEnding"/>
</seealso>
</element>

<element name="SIGSTKSZ" skip="1"/>


<element name="AnsiToUtf8">
<short>Convert ansi string to UTF-8 string</short>
<descr>
<p>
<var>AnsiToUtf8</var> converts the ansistring <var>S</var> to a UTF-8
format, that is, it converts the string from whatever codepage is currently
in use, to UTF-8.
</p>
<p>
The current codepage is fetched from the system, if internationalization support 
is enabled. It can be UTF-8, in which case the function simply returns
<var>S</var>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Utf8toAnsi"/>
</seealso>
</element>


<element name="DefaultAnsi2WideMove">
<short>Standard implementation of Ansi to Widestring conversion routine</short>
<descr>
<var>DefaultAnsi2WideMove</var> simply copies each character of the
null-terminated ansi-string <var>Source</var> to the corresponding WideChar
in <var>Dest</var>. At most <var>Len</var> characters will be copied.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultUnicode2AnsiMove"/>
</seealso>
</element>


<element name="DefaultUnicode2AnsiMove">
<short>Standard implementation of Widestring to Ansi conversion routine</short>
<descr>
<var>DefaultUnicode2AnsiMove</var> simply copies each character from
<var>Source</var> having an ordinal value of less than 255 to the
corresponding character in <var>Dest</var>. Characters having an 
ordinal valuelarger than 255 will be replaced by question marks.
At most <var>Len</var> characters will be copied.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultAnsi2WideMove"/>
</seealso>
</element>


<element name="DynArraySetLength">
<short>Set the length of a dynamic array</short>
<descr>
<p>
<var>DynArraySetLength</var> sets the length of the dynamical array
<var>a</var> to the first <var>dimCnt</var> lengths specified in the 
array <var>lengthVec</var>. The dynamical array type is described in
<var>typeInfo</var> which points to a record of type <link
id="TDynArrayTypeInfo"/>
</p>
<p>
It should never be necessary to call this function directly, the 
standard <link id="SetLength"/> function should be used instead.
</p>
</descr>
<errors>
If an invalid pointer is specified, an error may occur.
</errors>
<seealso>
<link id="SetLength"/>
<link id="tdynarraytypeinfo"/>
</seealso>
</element>



<element name="GetFPCHeapStatus">
<short>Return FPC heap manager status information</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>




<element name="HGLOBAL">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="HINSTANCE">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="HMODULE">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="IDispatch">
<short>Dispatch interface</short>
<descr>
<var>IDispatch</var> is the pascal definition of the Windows Dispatch
interface definition.
</descr>
<seealso>
<link id="IUnknown"/>
</seealso>
</element>


<element name="IDispatch.GetIDsOfNames">
<short>Return IDs of named procedures</short>
<descr>
Return the ID of a procedure.
</descr>
</element>


<element name="IDispatch.GetTypeInfo">
<short>Return type information about properties</short>
</element>


<element name="IDispatch.GetTypeInfoCount">
<short>Return number of properties.</short>
</element>


<element name="IDispatch.Invoke">
<short>Invoke a dispatch method</short>
</element>


<element name="IInterface">
<short>Basic interface for all COM based interfaces</short>
<descr>
<var>IInterface</var> is the basic interface from which all COM style
interfaces descend.
</descr>
<seealso>
<link id="IDispatch"/>
<link id="IInvokable"/>
</seealso>
</element>


<element name="IInvokable">
<short>Interface with RTTI associated with it.</short>
<descr>
<var>IInvokable</var> is a descendent of <link id="IInterface"/>, compiled
in the <var>{$M+}</var> state, so Run-Time Type Information (RTTI) is
generated for it.
</descr>
<seealso>
<link id="IDispatch"/>
<link id="IInterface"/>
</seealso>
</element>


<element name="InitThreadVars">
<short>Initialize threadvars</short>
<descr>
This routine should be called when threading is started. It is called by the
compiler and should never be called manually, only from a thread manager.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TThreadManager"/>
</seealso>
</element>


<element name="IUnknown">
<short>Basic interface for all COM-based interfaces</short>
<descr>
<var>IUnknown</var> is defined by windows. It's the basic interface which
all COM objects must implement. The definition does not contain any code.
</descr>
<seealso>
<link id="IInterface"/>
<link id="IDispatch"/>
<link id="IInvokable"/>
</seealso>
</element>


<element name="IUnknown._AddRef">
<short>Increase reference count of the interface</short>
<seealso>
<link id="IUnknown._Release"/>
</seealso>
</element>


<element name="IUnknown.QueryInterface">
<short>Return pointer to VMT table of interface</short>
</element>


<element name="IUnknown._Release">
<short>Decrease reference count of the interface</short>
<seealso>
<link id="IUnknown._AddRef"/>
</seealso>
</element>

<element name="FindResource">
<short>Locate a resource and return a handle to it.</short>
<descr>
<var>FindResource</var> searches for a resource with name
<var>ResourceName</var> and of type <var>ResourceType</var> 
in the executable or library identified by <var>ModuleHandle</var>.
It returns a <var>TResourceHandle</var> which can be used to load the
resource with <link id="LoadResource"/>.
</descr>
<errors>
None. In case the resource was not found, 0 is returned.
</errors>
<seealso>
<link id="FreeResource"/>
<link id="LoadResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="FreeResource">
<short>Free a loaded resource</short>
<descr>
<var>FreeResource</var> unloads the resource identified by
<var>ResData</var> from memory. The resource must have been loaded by <link
id="LoadResource"/>. It returns <var>True</var> if the operation was
succesful, <var>False</var> otherwise.
</descr>
<errors>
On error, <var>False</var> is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="LoadResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>



<element name="LoadResource">
<short>Load a resource for use</short>
<descr>
<p>
<var>LoadResource</var> loads a resource identified by <var>ResHandle</var>
from a module identified by <var>ModuleHandle</var>into memory. It returns
a handle to the resource.
</p>
<p>
Loaded resources must be unloaded again using the <link id="FreeResource"/>
function.
</p>
</descr>
<errors>
On error, 0 is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="LockResource">
<short>Lock a resource</short>
<descr>
<p>
<var>LockResource</var> locks a resource previously loaded by
<var>LoadResource</var> into memory. This means that any attempt to modify
the resource will fail while it is locked. The function returns a pointer to
the resource location in memory.
</p>
<p>
The resource can be freed again using the <link id="UnlockResource"/>
function.
</p>
</descr>
<errors>
if the function fails, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LoadResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>

<element name="SizeofResource">
<short>Return the size of a particular resource</short>
<descr>
<var>SizeOfResource</var> returns the size of the resource identified by
<var>ResHandle</var> in module identified by <var>ModuleHandle</var>. 
<var>ResHandle</var> should be obtained from a call to <link id="LoadResource"/>
</descr>
<errors>
In case of an error, 0 is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="LoadResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>

<element name="UnlockResource">
<short>Unlock a previously locked resource</short>
<descr>
<var>UnlockResource</var> unlocks a previously locked resource. Note that
this function does not exist on windows, it's only needed on other
platforms.
</descr>
<errors>
The function returns <var>False</var> if it failed.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LoadResource"/>
<link id="lockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="MAKEINTRESOURCE">
<short>Alias for the <link id="#rtl.system.PChar">PChar</link> type.</short>
</element>


<element name="MaxKeptOSChunks">
<short>Maximum number of OS chunks to be kept in memory</short>
<descr>
<var>MaxKeptOSChunks</var> tells the heap manager how many free 
chunks of OS-allocated memory it should keep in memory. When freeing memory,
it can happen that a memory block obtained from the OS is completely free.
If more than <var>MaxKeptOSChunks</var> such blocks are free, then the heap
manager will return them to the OS, to reduce memory requirements.
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>


<element name="MaxPathLen">
<short>Constant defining the maximum length of filenames (including path)</short>
<descr>
This constant is system dependent.
</descr>
</element>


<element name="BEtoN">
<short>Convert Big Endian-ordered integer to Native-ordered integer</short>
<descr>
<var>BEToN</var> will rearrange the bytes in a Big-Endian number to 
the native order for the current processor. That is, for a big-endian 
processor, it will do nothing, and for a little-endian processor, 
it will invert the order of the bytes.
</descr>
<seealso>
<link id="LEtoN"/>
<link id="NtoBE"/>
<link id="NtoLE"/>
</seealso>
</element>


<element name="LEtoN">
<short>Convert Little Endian-ordered integer to Native-ordered integer</short>
<descr>
<var>LEToN</var> will rearrange the bytes in a Little-Endian number to 
the native order for the current processor. That is, for a little-endian 
processor, it will do nothing, and for a big-endian processor, 
it will invert the order of the bytes.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="NtoBE"/>
<link id="NtoLE"/>
</seealso>
</element>

<element name="NtoBE">
<short>Convert Native-ordered integer to a Big Endian-ordered integer</short>
<descr>
<var>NToBE</var> will rearrange the bytes in a natively-ordered number to 
the Big-Endian order. That is, for a Little-Endian processor, it will 
invert the order of the bytes and for a big-endian processor, it will do
nothing.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="LEtoN"/>
<link id="NtoLE"/>
</seealso>
</element>


<element name="NtoLE">
<short>Convert Native-ordered integer to a Little Endian-ordered integer</short>
<descr>
<var>NToLE</var> will rearrange the bytes in a natively-ordered number to 
the little-Endian order. That is, for a Big-Endian processor, it will 
invert the order of the bytes and for a Little-Endian processor, it will do
nothing.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="LEtoN"/>
<link id="NtoBE"/>
</seealso>
</element>


<element name="PDispatch">
<short>Pointer to <link id="#rtl.system.IDispatch">IDispatch</link> interface type</short>
</element>


<element name="PDynArrayTypeInfo">
<short>Pointer to <link id="#rtl.system.tdynarraytypeinfo">TDynArrayTypeInfo</link> type.</short>
</element>


<element name="PPDispatch">
<short>Pointer to <link id="#rtl.system.PDispatch">PDispatch</link> pointer type</short>
</element>


<element name="PPUnknown">
<short>Pointer to untyped pointer</short>
</element>


<element name="PUnknown">
<short>Untyped pointer</short>
</element>


<element name="PWideString">
<short>Pointer to widestring type</short>
</element>


<element name="RT_ACCELERATOR">
<short>Constant identifying an accelerator resouce</short>
</element>


<element name="RT_BITMAP">
<short>Constant identifying a bitmap resource</short>
</element>


<element name="RT_CURSOR">
<short>Constant identifying a cursor resource</short>
</element>


<element name="RT_DIALOG">
<short>Constant identifying a dialog resource</short>
</element>


<element name="RT_FONT">
<short>Constant identifying a font resource</short>
</element>


<element name="RT_FONTDIR">
<short>Constant identifying a font directory resource</short>
</element>


<element name="RT_GROUP_CURSOR">
<short>Constant identifying a group cursor resource</short>
</element>


<element name="RT_GROUP_ICON">
<short>Constant identifying a group icon resource</short>
</element>


<element name="RT_ICON">
<short>Constant identifying an icon resource</short>
</element>


<element name="RT_MENU">
<short>Constant identifying a menu resource</short>
</element>


<element name="RT_MESSAGETABLE">
<short>Constant identifying a message data resource</short>
</element>


<element name="RT_RCDATA">
<short>Constant identifying a binary data resource</short>
</element>


<element name="RT_STRING">
<short>Constant identifying a string table resource</short>
</element>


<element name="RT_VERSION">
<short>Constant identifying a version info resource</short>
</element>


<element name="RuntimeErrorExitCodes">
<short>Mapping between runtime-error constants and program exit codes</short>
<descr>
This array is used by the <link id="Error"/> routine to convert a 
<link id="TRuntimeError"/> enumeration type to a process exit code.
</descr>
<seealso>
<link id="Error"/>
</seealso>
</element>


<element name="SafeCallErrorProc">
<short>Error handler for safecall errors</short>
<descr>
<var>SafeCallErrorProc</var> is a Handler called in case of a 
safecall calling convention error. <var>Error</var> is the error 
number (passed by the Windows operating system) and <var>Addr</var> is the address where the 
error occurred.
</descr>
<seealso>
<link id="TSafeCallErrorProc"/>
</seealso>
</element>

<element name="GetWideStringManager">
<short>Return a copy of the currently active widestring manager.</short>
<descr>
<p>
<var>GetWideStringManager</var> returns a copy of the currently active 
heap manager in <var>Old</var>
</p>
<p>
WideStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a WideString manager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstring</file>).
</p>
<p>
It is possible to implement a custom widestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<seealso>
<link id="SetWideStringManager"/>
<link id="TWideStringManager"/>
</seealso>
</element>

<element name="SetWideStringManager">
<short>Set the widestring manager</short>
<descr>
<p>
<var>SetWideStringManager</var> sets the current widestring manager to <var>New</var>.
Optionally, it returns the currently active widestring manager in <var>Old</var>.
</p>
<p>
WideStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a WideString manager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstring</file>).
</p>
<p>
It is possible to implement a custom widestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="TWideStringManager"/>
</seealso>
</element>

<element name="TWideStringManager">
<short>Record containing the various callbacks of the widestring manager.</short>
<descr>
<var>TWideStringManager</var> contains the definition of the widestring manager.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TWideStringManager.Wide2AnsiMoveProc">
<short>Convert an AnsiString to a WideString</short>
</element>

<element name="TWideStringManager.Ansi2WideMoveProc">
<short>Convert a WideString to an AnsiString</short>
</element>

<element name="TWideStringManager.UpperWideStringProc">
<short>Convert a widestring to all-uppercase</short>
</element>

<element name="TWideStringManager.LowerWideStringProc">
<short>Convert a widestring to all-lowercase</short>
</element>

<element name="TWideStringManager.CompareWideStringProc">
<short>Compare 2 widestrings, case-sensitive</short>
</element>

<element name="TWideStringManager.CompareTextWideStringProc">
<short>Compare 2 widestrings, case-insensitive</short>
</element>

<element name="TWideStringManager.CharLengthPCharProc">
<short>Return the length, in characters, of a widestring</short>
</element>

<element name="TWideStringManager.UpperAnsiStringProc">
<short>Convert an ansistring to all-uppercase</short>
</element>

<element name="TWideStringManager.LowerAnsiStringProc">
<short>Convert an ansistring to all-lowercase</short>
</element>

<element name="TWideStringManager.CompareStrAnsiStringProc">
<short>Compare 2 ansistrings, case-sensitive</short>
</element>

<element name="TWideStringManager.CompareTextAnsiStringProc">
<short>Compare 2 ansistrings, case-insensitive</short>
</element>

<element name="TWideStringManager.StrCompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-sensitive</short>
</element>

<element name="TWideStringManager.StrICompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-insensitive</short>
</element>

<element name="TWideStringManager.StrLCompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-sensitive, for a maximum length</short>
</element>

<element name="TWideStringManager.StrLICompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-insensitive, for a maximum length</short>
</element>

<element name="TWideStringManager.StrLowerAnsiStringProc">
<short>Convert an ansistring to all-lowercase</short>
</element>

<element name="TWideStringManager.StrUpperAnsiStringProc">
<short>Convert an ansistring to all-uppercase</short>
</element>


<element name="StackTop">
<short>Top location of the stack.</short>
<descr>
<var>StackTop</var> contains the top of the stack for the current process.
It is used to check the heap on some operating systems, and is set by the 
system unit initialization code. Do not use or modify this value.
</descr>
<seealso>
<link id="StackBottom"/>
<link id="StackLength"/>
</seealso>
</element>


<element name="StringToWideChar">
<short>Convert a string to an array of widechars.</short>
<descr>
<var>StringToWideChar</var> converts an ansistring <var>Src</var> 
to a null-terminated  array of WideChars. The destination for this
array is pointed to by <var>Dest</var>, and contains room for at 
least <var>DestSize</var> widechars.
</descr>
<errors>
No validity checking is performed on <var>Dest</var>.
</errors>
<seealso>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="SysGetFPCHeapStatus">
<short>Return the status of the FPC heapmanager</short>
<descr>
<var>SysGetFPCHeapStatus</var> returns the status of the 
default FPC heapmanager. It is set as the default value 
of the corresponding <link id="GetFPCHeapStatus"/> function.
</descr>
<errors>
None. The result of this function is bogus information if
the current heapmanager is not the standard FPC heapmanager.
</errors>
<seealso>
<link id="GetFPCHeapStatus"/>
</seealso>
</element>


<element name="tdynarraytypeinfo">
<short>Type information for a dynamic array.</short>
<descr>
<var>tdynarraytypeinfo</var> describes the structure of 
a multi-dimensional dynamical array. 
It is used in the <link id="DynArraySetLength"/> call.
</descr>
<seealso>
<link id="DynArraySetLength"/>
</seealso>
</element>

<element name="tdynarraytypeinfo.kind">
<short>Kind of array.</short>
</element>
<element name="tdynarraytypeinfo.namelen">
<short>Length of the Name of the array type. Name follows as Namelen characters.</short>
</element>
<element name="tdynarraytypeinfo.elesize">
<short>Size of a single element in the array</short>
</element>
<element name="tdynarraytypeinfo.eletype">
<short>Pointer to next dimension structure in case of a multidimensional array</short>
</element>
<element name="tdynarraytypeinfo.vartype">
<short>Type (variant type) of element in the array</short>
</element>


<element name="TError">
<short>Error type, used in variants.</short>
</element>


<element name="TFPCHeapStatus">
<short>Record describing the state of the default FPC heap manager.</short>
<descr>
<var>TFPCHeapStatus</var> describes the state of the FPC heap manager. 
This is not equivalent to the <link id="THeapStatus"/> record defined 
by Delphi, which contains information not meaningful for the FPC heap manager.
The heap status can be retrieved by the <link id="GetFPCHeapStatus"/> call.
</descr>
<seealso>
<link id="GetFPCHeapStatus"/>
<link id="GetHeapStatus"/>
<link id="THeapStatus"/>
</seealso>
</element>

<element name="TFPCHeapStatus.MaxHeapSize">
<short>Maximum allowed size for the heap, in bytes</short>
</element>

<element name="TFPCHeapStatus.MaxHeapUsed">
<short>Maximum used size for the heap, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapSize">
<short>Current heap size, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapUsed">
<short>Currently used heap size, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapFree">
<short>Currently free memory on heap, in bytes</short>
</element>



<element name="TInterfacedClass">
<short><link id="#rtl.system.tobject">TObject</link> descendent implementing the <link id="#rtl.system.IInterface">IInterface</link> interface</short>
<descr>
<var>TInterfacedClass</var> is a descendent of 
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TInterfacedObject">
<short><link id="#rtl.system.tobject">TObject</link> descendent implementing the <link id="#rtl.system.IUnknown">IUnknown</link> interface</short>
<descr>
<var>TInterfacedObject</var> is a descendent of <link id="TObject"/> which implements the
<link id="IUnknown"/> interface. It can be used as a base class for all classes which need
reference counting.
</descr>
<seealso>
<link id="IUnknown"/>
<link id="TObject"/>
</seealso>
</element>


<element name="TInterfacedObject.AfterConstruction">
<short>Handle reference count properly.</short>
<descr>
<var>AfterConstruction</var> overrides the basic method in <var>TObject</var> 
and adds some additional reference count handling.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TInterfacedObject.BeforeDestruction">BeforeDestruction</link>
</seealso>
</element>


<element name="TInterfacedObject.BeforeDestruction">
<short>Check reference count.</short>
<descr>
<var>AfterConstruction</var> overrides the basic method in <var>TObject</var> 
and adds a reference count check: if the reference count is not zero, an error
occurs.
</descr>
<errors>
A runtime-error 204 will be generated if the reference count is nonzero when 
the object is destroyed.
</errors>
<seealso>
<link id="TInterfacedObject.AfterConstruction">AfterConstruction</link>
</seealso>
</element>


<element name="TInterfacedObject.NewInstance">
<short>Create a new instance</short>
<descr>
<var>NewInstance</var> initializes a new instance of <link id="TInterfacedObject"/>
</descr>
<errors>
None.
</errors>
</element>


<element name="TInterfacedObject.RefCount">
<short>Return the current reference count</short>
<descr>
<var>RefCount</var> returns the current reference count. 
This reference count cannot be manipulated, except through 
the methods of <link id="IUnknown"/>. When it reaches zero,
the class instance is destroyed.
</descr>
<seealso>
<link id="IUnknown"/>
</seealso>
</element>


<element name="TObject.GetInterface">
<short>Return a reference to an interface</short>
<descr>
<p>
<var>GetInterface</var> scans the interface tables and returns a reference
to the interface <var>iid</var>. The reference is stored in <var>Obj</var> 
which should be an interface reference. It returns <var>True</var> if the 
interface was found, <var>False</var> if not.
</p>
<p>
The reference count of the interface is increased by this call.
</p>
</descr>
<errors>
If no interface was found, <var>False</var> is returned.
</errors>
<seealso>
<link id="TObject.GetInterfaceByStr">GetInterfaceByStr</link>
</seealso>
</element>


<element name="TObject.GetInterfaceByStr">
<short>Return an interface based on its GUID</short>
<descr>
<p>
<var>GetInterfaceByStr</var> returns in <var>obj</var> a pointer to the interface 
identified by <var>iidstr</var>. The function returns <var>True</var> if the
interface is indeed implemented by the class, or <var>False</var> otherwise.
</p>
<p>
The <var>iidstr</var> is the unique GUID by which the interface was declared.
</p>
</descr>
<errors>
The function returns false if the requested interface is not implemented.
</errors>
<seealso>
<link id="TObject.GetInterfaceEntry"/>
<link id="TObject.GetInterfaceEntryByStr"/>
</seealso>
</element>


<element name="TObject.GetInterfaceEntry">
<short>Return the interface table entry by GUID</short>
<descr>
<var>GetInterfaceEntry</var> returns the internal interface table entry for the
interface identified by <var>iid</var> (the GUID used in the declaration
of the interface). If the interface is not implemented by the
class, the function returns <var>Nil</var>.
</descr>
<seealso>
<link id="TObject.GetInterfaceByStr"/>
<link id="TObject.GetInterfaceEntryByStr"/>
</seealso>
</element>


<element name="TObject.GetInterfaceEntryByStr">
<short>Return the interface table entry by string</short>
<descr>
<var>GetInterfaceEntryByStr</var> returns the internal interface table entry for the
interface identified by <var>iidstr</var> (A string representation of the GUID used in the declaration
of the interface). If the interface is not implemented by the
class, the function returns <var>Nil</var>.
</descr>
<seealso>
<link id="TObject.GetInterfaceByStr"/>
<link id="TObject.GetInterfaceEntry"/>
</seealso>
</element>


<element name="TObject.GetInterfaceTable">
<short>Return a pointer to the table of implemented interfaces for a class</short>
<descr>
<var>GetInterfaceTable</var> returns a pointer to the internal table of
implemented interfaces for a class. The result will always point to a valid
address, if the class implements no interfaces the <var>EntryCount</var>
field of the interface table will be zero.
</descr>
<seealso>
<link id="TObject.GetInterfaceByStr"/>
<link id="TObject.GetInterfaceEntry"/>
</seealso>
</element>


<element name="TResourceHandle">
<short>Handle to a resource, for use in the resource loading routines</short>
<descr>
This is an opaque type. 
</descr>
<seealso>
<link id="LoadResource"/>
</seealso>
</element>


<element name="TRuntimeError">
<short>Type of runtime-error for the Error procedure</short>
<descr>
<var>TRuntimeError</var> is used in the <link id="Error"/> procedure to
indicate what kind of error should be reported. 
</descr>
<seealso>
<link id="Error"/>
</seealso>
</element>


<element name="TRuntimeError.reAccessViolation">
<short>Access Violation</short>
</element>


<element name="TRuntimeError.reAssertionFailed">
<short>Assertion failed error</short>
</element>


<element name="TRuntimeError.reCodesetConversion">
<short>Code set conversion error</short>
</element>


<element name="TRuntimeError.reControlBreak">
<short>User pressed CTRL-C</short>
</element>


<element name="TRuntimeError.reDivByZero">
<short>Division by zero error</short>
</element>


<element name="TRuntimeError.reExternalException">
<short>An external exception occurred</short>
</element>


<element name="TRuntimeError.reIntfCastError">
<short>Interface typecast error</short>
</element>


<element name="TRuntimeError.reIntOverflow">
<short>Integer overflow error</short>
</element>


<element name="TRuntimeError.reInvalidCast">
<short>Invalid (class) typecast error</short>
</element>


<element name="TRuntimeError.reInvalidOp">
<short>Invalid operation error</short>
</element>


<element name="TRuntimeError.reInvalidPtr">
<short>Invalid pointer error</short>
</element>


<element name="TRuntimeError.reNone">
<short>No error</short>
</element>


<element name="TRuntimeError.reOutOfMemory">
<short>Out of memory error</short>
</element>


<element name="TRuntimeError.reOverflow">
<short>Overflow error</short>
</element>


<element name="TRuntimeError.rePrivInstruction">
<short>Privileged instruction error</short>
</element>


<element name="TRuntimeError.reQuit">
<short>Quit signal error</short>
</element>


<element name="TRuntimeError.reRangeError">
<short>Range check error</short>
</element>


<element name="TRuntimeError.reSafeCallError">
<short>Safecall (IDispInterface) error</short>
</element>


<element name="TRuntimeError.reStackOverflow">
<short>Stack overflow error</short>
</element>


<element name="TRuntimeError.reUnderflow">
<short>Underflow error</short>
</element>


<element name="TRuntimeError.reVarArrayBounds">
<short>Variant array bounds error</short>
</element>


<element name="TRuntimeError.reVarArrayCreate">
<short>Variant array creation error</short>
</element>


<element name="TRuntimeError.reVarDispatch">
<short>Variant Dispatch error.</short>
</element>


<element name="TRuntimeError.reVarInvalidOp">
<short>Invalid variant operation error</short>
</element>


<element name="TRuntimeError.reVarNotArray">
<short>Variant is not an array error.</short>
</element>


<element name="TRuntimeError.reVarTypeCast">
<short>Invalid typecase from variant</short>
</element>


<element name="TRuntimeError.reZeroDivide">
<short>Division by zero error</short>
</element>


<element name="TSafeCallErrorProc">
<short>Prototype for the safecall error handler</short>
<descr>
Prototype of a safecall error handler routine. <var>Error</var> is the error
number (passed by the Windows operating system) and <var>Addr</var> is the
address where the error occurred.
</descr>
<seealso>
<link id="SafeCallErrorProc"/>
</seealso>
</element>

<element name="TSafeCallErrorProc.error">
<short>Error number</short>
</element>

<element name="TSafeCallErrorProc.addr">
<short>Address where error occurred</short>
</element>



<element name="UCS4StringToWideString">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="UnicodeToUtf8">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>




<element name="UTF8Decode">
<short>Convert an UTF-8 encoded ansistring to a unicodestring</short>
<descr>
<p>
<var>UTF8Decode</var> converts the UTF-8 encoded ansistring <var>S</var> to 
a unicodestring and returns the resulting string. It calls the
low-level <link id="Utf8ToUnicode"/> function to do the actual work.
</p>
</descr>
<seealso>
<link id="UTF8Encode"/>
<link id="Utf8ToAnsi"/>
<link id="SetWideStringManager"/>
<link id="Utf8ToUnicode"/>
</seealso>
</element>


<element name="UTF8Encode">
<short>Convert a widestring or unicodestring to an UTF-8 encoded ansistring</short>
<descr>
<p>
<var>UTF8Encode</var> converts an ansistring or widestring <var>S</var> to the equivalent UTF-8 encoded unicode string and returns this resulting string. It calls the
low-level <link id="UnicodeToUTF8"/> function to do the actual work.
</p>
<p>
The resulting string has code page <var>CP_UTF8</var>.
</p>
</descr>
<seealso>
<link id="UTF8Decode"/>
<link id="Utf8ToAnsi"/>
<link id="UnicodeToUtf8"/>
<link id="SetWideStringManager"/>
</seealso>
</element>


<element name="Utf8ToAnsi">
<short>Convert a UTF-8 encoded unicode string to an ansistring</short>
<descr>
<p>
<var>Utf8ToAnsi</var> converts an utf8-encode unicode string to an
ansistring. It converts the string to a widestring and then converts
the widestring to an ansistring.
</p>
<p>
For this function to work, a widestring manager must be installed.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="UTF8Encode"/>
<link id="UTF8Decode"/>
<link id="SetWideStringManager"/>
</seealso>
</element>


<element name="Utf8ToUnicode">
<short>Convert a buffer with UTF-8 characters to widestring characters</short>
<descr>
<p>
<var>Utf8ToUnicode</var> converts the buffer in <var>Source</var> with a
length of <var>SourceBytes</var> or for a maximum length of
<var>MaxChars</var>  (or <var>MaxDestChars</var>) widestring 
characters to the buffer pointed to by <var>Dest</var>.
</p>
<p>
The function returns the number of copied widestring characters.
</p>
</descr>
<errors>
On error, -1 is returned.
</errors>
<seealso>
<link id="UTF8Encode"/>
<link id="UTF8Decode"/>
<link id="Utf8ToAnsi"/>
<link id="SetWideStringManager"/>
</seealso>
</element>


<element name="VarCast">
<short>Cast a variant to a certain type</short>
<descr>
<var>VarCast</var> converts the variant in <var>Source</var> to the type
indicated in <var>VarType</var> and returns the result in <var>dest</var>.
The <var>VarType</var> must be one of the pre-defined <var>VarNNN</var> constants.
</descr>
<errors>
If the conversion is not possible because the value cannot be correctly
casted, then a run-time error or an exception may occur.
</errors>
<seealso>
</seealso>
</element>


<element name="varrecord">
<short>Record variant type</short>
</element>


<element name="WideCharLenToString">
<short>Convert a length-limited array of widechar to an ansistring</short>
<descr>
<var>WideCharLenToString</var> converts at most <var>Len</var> widecharacters from 
the null-terminated widechar array <var>S</var> to an ansistring, and returns 
the ansistring.
</descr>
<errors>
No validity checking is performed on <var>S</var>. 
Passing an invalid pointer may lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
</seealso>
</element>

<element name="WideCharLenToStrVar">
<short>Convert a length-limited array of widechar to an ansistring</short>
<descr>
<var>WideCharLenToString</var> converts at most <var>Len</var> widecharacters from 
the null-terminated widechar array <var>Src</var> to an ansistring, and returns 
the ansistring in <var>Dest</var>.
</descr>
<errors>
No validity checking is performed on <var>Src</var>. 
Passing an invalid pointer may lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="WideCharToString">
<short>Convert a null-terminated array of widechar to an ansistring</short>
<descr>
<var>WideCharToString</var> converts the null-terminated widechar 
array <var>S</var> to an ansistring, and returns the ansistring.
</descr>
<errors>
No validity checking is performed on <var>Src</var>. 
Passing an invalid pointer, or an improperly terminated array may 
lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>

<element name="WideCharToStrVar">
<short>Convert a null-terminated array of widechar to an ansistring</short>
<descr>
<var>WideCharToString</var> converts the null-terminated widechar 
array <var>S</var> to an ansistring, and returns the ansistring in <var>Dest</var>.
</descr>
<errors>
No validity checking is performed on <var>S</var>. 
Passing an invalid pointer, or an improperly terminated array may 
lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="widestringmanager">
<short>Current widestring manager.</short>
<descr>
Contains the current widestring manager. Do not use directly.
</descr>
<seealso>
<link id="GetWideStringManager"/>
<link id="SetWideStringManager"/>
</seealso>
</element>


<element name="WideStringToUCS4String">
<short>Convert a widestring to a UCS-4 encoded string.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="operator and(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ansistring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ansistring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Boolean): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Boolean): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Byte): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Byte): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Char): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Char): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(currency): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(currency): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator div(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(double): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(double): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(DWord): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(DWord): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Int64): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Int64): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(longbool): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(longbool): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(LongInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(LongInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator mod(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator not(variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): ansistring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Byte">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Char">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): currency">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): DWord">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Int64">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): longbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): LongInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): qword">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): ShortInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): shortstring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): SmallInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): TDateTime">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): TError">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): widechar">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): widestring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Word">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): wordbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator or(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(qword): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(qword): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(real48): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator shl(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ShortInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ShortInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(shortstring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(shortstring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator shr(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(SmallInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(SmallInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TDateTime): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TDateTime): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TError): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TError): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): ansistring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Byte">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Char">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): currency">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): DWord">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Int64">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): longbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): LongInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): qword">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): ShortInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): shortstring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): SmallInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): TDateTime">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): TError">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator -(variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &lt;=(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &lt;(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator =(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &gt;=(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &gt;(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator -(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator /(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator *(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator **(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator +(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): widechar">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): widestring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Word">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): wordbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widechar): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widechar): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widestring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widestring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(wordbool): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(wordbool): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Word): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Word): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator xor(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SwapEndian">
<short>Swap endianness of the argument</short>
<descr>
<var>SwapEndian</var> will swap the endianness of the bytes in its argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="hi"/>
<link id="lo"/>
<link id="swap"/>
<link id="BEToN"/>
<link id="NToBE"/>
<link id="NToLE"/>
<link id="LEToN"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedIncrement">
<short>Thread-safe increment</short>
<descr>
<var>InterLockedIncrement</var> increments <var>Target</var> with 1 and returns the result.
This is done in a thread-safe way (i.e. only one processor is accessing the variable at a time).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedDecrement">
<short>Thread-safe decrement</short>
<descr>
<var>InterLockedDecrement</var> decrements <var>Target</var> with 1 and returns the result.
This is done in a thread-safe way. (i.e. only one processor is accessing the variable at a time).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedExchange">
<short>Exchange 2 integers in a thread-safe way</short>
<descr>
<var>InterLockedExchange</var> stores <var>Source</var> in <var>Target</var> and returns the old value of <var>Target</var>. 
This is done in a thread-safe way, i.e., only one processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedExchangeAdd">
<short>Thread-safe add and exchange of 2 values</short>
<descr>
<var>InterLockedExchangeAdd</var> adds to <var>Target</var> the value of <var>Source</var> in a thread-safe way, 
and returns the old value of <var>Target</var>.This is done in a thread-safe way, i.e., only one 
processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterlockedCompareExchange">
<short>Conditional exchange</short>
<descr>
<var>InterlockedCompareExchange</var> does an  compare-and-exchange operation on the specified values in a thread-safe way. 
The function compares <var>Target</var> and <var>Comparand</var> and exchanges <var>Target</var> with <var>NewValue</var>
if <var>Target</var> and <var>Comparand</var> are equal. It returns the old value of <var>Target</var>. 
This is done in a thread-safe way, i.e., only one processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data1">
<short>First 4 bytes of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data2">
<short>Bytes 5 and 6 of  GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data3">
<short>Bytes 7 and 8 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data4">
<short>Bytes 9-17 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D1">
<short>First 4 bytes of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D2">
<short>Bytes 5 and 6 of  GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D3">
<short>Bytes 7 and 8 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D4">
<short>Bytes 9-17 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInteger">
<short>Integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VBoolean">
<short>Boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VChar">
<short>Character value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VWideChar">
<short>Widechar value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VExtended">
<short>Extended value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VString">
<short>String value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPointer">
<short>Pointer value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPChar">
<short>PChar value (null-terminated string)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VObject">
<short>Object value (instance pointer)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VClass">
<short>Class pointer value (VMT pointer)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPWideChar">
<short>Widechar value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VAnsiString">
<short>Ansistring value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VCurrency">
<short>Currency value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VVariant">
<short>Variant value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInterface">
<short>Interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VWideString">
<short>Widestring value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInt64">
<short>Int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VQWord">
<short>QWord value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res1">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res2">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res3">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vsmallint">
<short>Smallint value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vinteger">
<short>Integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vsingle">
<short>Single value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdouble">
<short>Double value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vcurrency">
<short>Currency value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdate">
<short>TDateTime value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.volestr">
<short>OLE string value (specially allocated widestring)</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdispatch">
<short>Dispatch interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.verror">
<short>Error value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vboolean">
<short>Boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vunknown">
<short>IUnknown interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vshortint">
<short>Shortint value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vbyte">
<short>Byte value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vword">
<short>Word value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vlongword">
<short>Longword value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vint64">
<short>Int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vqword">
<short>QWord value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vword64">
<short>QWord value (?)</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vstring">
<short>Ansistring value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vany">
<short>Any valyue</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.varray">
<short>Variant array value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vpointer">
<short>Pointer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vlongs">
<short>Value as an array of longints</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vwords">
<short>Value as an array of words</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vbytes">
<short>Value as an array of bytes</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalAddrSpace">
<short>Total amount of available addressable memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalUncommitted">
<short>Total amount of uncommitted memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalCommitted">
<short>Total amount of committed memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalAllocated">
<short>Total amount of allocated memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalFree">
<short>Total amount of free memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.FreeSmall">
<short>Total amount of free small memory blocks</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.FreeBig">
<short>Total amount of free large memory blocks</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.Unused">
<short>Total amount of free process memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.Overhead">
<short>Total bytes of overhead by memory manager</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.HeapErrorCode">
<short>Last error code</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.GetFPCHeapStatus">
<short>Handler to get FPC heap status information.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="Real">
<short>Alias for real type</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__m_reserved">
<short>Do not use.</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__m_count">
<short>Do not use.</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__m_owner">
<short>Do not use.</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__m_kind">
<short>Do not use</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__m_lock">
<short>Do not use</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pack_x_y_z">
<short>FPC compiler internal procedure index: pack</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_unpack_x_y_z">
<short>FPC compiler internal procedure index: unpack</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_bitsizeof_x">
<short>FPC compiler internal procedure index: bitsizeof</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_invalid">
<short>IEC/IEEE floating-point exception flag: Invalid operation error</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_denormal">
<short>IEC/IEEE floating-point exception flag: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_divbyzero">
<short>IEC/IEEE floating-point exception flag: Division by zero error</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_overflow">
<short>IEC/IEEE floating-point exception flag: Overflow error</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_underflow">
<short>IEC/IEEE floating-point exception flag: Underflow error</short>
</element>

<!-- constant Visibility: default -->
<element name="float_flag_inexact">
<short>IEC/IEEE floating-point exception flag: ?</short>
</element>

<!-- variable Visibility: default -->
<element name="softfloat_exception_mask">
<short>Current soft float exception mask</short>
</element>

<!-- variable Visibility: default -->
<element name="softfloat_exception_flags">
<short>Current soft float exception flags</short>
</element>

<!-- procedure Visibility: default -->
<element name="float_raise">
<short>Raise floating point exception</short>
<descr>
<var>float_raise</var> raises the floating point exceptions specified by 
<link id="softfloat_exception_flags"/>.
</descr>
<seealso>
<link id="softfloat_exception_flags"/>
<link id="softfloat_exception_mask"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator :=">
<short>Overload for variants</short>
<descr>
The assignment operator is overloaded for various types. This should be
transparent to the user.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.time_low">
<short>low part of GUID timestamp</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.time_mid">
<short>Middle part of GUID timestamp</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.time_hi_and_version">
<short>High part of GUID timestamp and version</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.clock_seq_hi_and_reserved">
<short>High part of clock sequence of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.clock_seq_low">
<short>Low part of clock sequence of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.node">
<short>Node part of GUID</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="tinterfaceentrytype">
<short>Dispatch interface entry type</short>
<descr>
This is an internal type for the compiler to encode calls to 
dispatch interfaces.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etStandard">
<short>Standard entry</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etVirtualMethodResult">
<short>Virtual method</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etStaticMethodResult">
<short>Statis method</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etFieldValue">
<short>Field value</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IType">
<short>Interface entry interface type</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.__pad_dummy">
<short>Padding bytes</short>
</element>

<!--
  ********************************************************************
    #rtl.System.TAggregatedObject
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TAggregatedObject">
<short>Aggregated object</short>
<descr>
<p>
<var>TAggregatedObject</var> implements an object whose lifetime is
governed by an external object (or interface). It does not implement the
<var>IUnknown</var> interface by itself, but delegates all methods to the controller
object, as exposed in the <link id="TAggregatedObject.Controller">Controller</link> 
property. In effect, the reference count of the aggregated object is the
same as that of it's controller, and additionally, all interfaces of the
controller are exposed by the aggregated object.
</p>
<p>
Note that the aggregated object maintains a non-counted reference to
the controller.
</p>
<p>
Aggregated objects should be used when using delegation to implement
reference counted objects: the delegated interfaces can be implemented
safely by <var>TAggregatedObject</var> descendents.
</p>
</descr>
<seealso>
<link id="TAggregatedObject.Create">Create</link>
<link id="TAggregatedObject.Controller">Controller</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TAggregatedObject.Create">
<short>Create a new instance of <var>TAggregatedObject</var></short>
<descr>
<var>Create</var> creates a new instance of <var>TAggregatedObject</var> on
the heap, and stores a reference to <var>aController</var>, so it can be
exposed in the <link id="TAggregatedObject.Controller">Controller</link>
property.
</descr>
<errors>
If not enough memory is present on the heap, an exception will be raised.
If the <var>aController</var> is <var>Nil</var>, exceptions will occur when
any of the <var>TAggregatedObject</var> methods (actually, the <var>IUnknown</var>
methods) 
are used.
</errors>
<seealso>
<link id="TAggregatedObject.Controller">Controller</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TAggregatedObject.Controller">
<short>Controlling instance</short>
<descr>
<p>
<var>Controller</var> exposes the controlling object, with all interfaces it
has.
</p>
<p>
The value of the controller is set when the <var>TAggregatedObject</var>
instance is created.
</p>
</descr>
<seealso>
<link id="TAggregatedObject.Create"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TSempahoreInitHandler">
<short>Function prototype for initializing a semaphore</short>
<descr>
<var>TSempahoreInitHandler</var> is the function prototype for initializing
a semaphore. It is used by the thread manager (<var>ThreadManager.SemaphoreInit</var>) 
to create semaphores. The function should return a pointer, usable by the other 
semaphore functions of the thread manager.
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TSemaphoreDestroyHandler">
<short>Function prototype for destroying a semaphore</short>
<descr>
<var>TSemaphoreDestroyHandler</var> is the function prototype to 
destroy an existing semaphore, as returned by 
(<var>ThreadManager.SemaphoreInit</var>). It is used by the 
thread manager (<var>ThreadManager.SemaphoreDestroy</var>)
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TSemaphorePostHandler">
<short>Function prototype for posting an event to a semaphore</short>
<descr>
<var>TSemaphorePostHandler</var> is the function prototype to post an event
to the semaphore. It should handle a pointer as returned by the
<var>ThreadManager.SemaphoreInit</var> procedure. it's used by the thread
manager <var>ThreadManager.SemaphorePost</var>.
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TSemaphoreWaitHandler">
<short>Function prototype to wait on a semaphore</short>
<descr>
<var>TSemaphoreWaitHandler</var> is the function prototype to wait on an 
event on the semaphore (which should be posted to the semaphore with
<var>ThreadManager.SemaphorePost</var>). It should handle a pointer as eturned by the
<var>ThreadManager.SemaphoreInit</var> procedure. it's used by the thread
manager <var>ThreadManager.SemaphoreWait</var>.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SemaphoreInit">
<short>Initialize (create) a new semaphore</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SemaphoreDestroy">
<short>Destroy (free) a semaphore created using <var>SemaphoreInit</var>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SemaphorePost">
<short>Post an event on a semaphore created using <var>SemaphoreInit</var>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SemaphoreWait">
<short>Wait on a semaphore event posted by <var>SemaphorePost</var>.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FlushThread">
<short>Flush all standard files</short>
<descr>
<var>FlushThread</var> flushes any buffers from standard file descriptors
such as standard input/output/error. It should normally not be called by 
user code, but is executed when a thread exits.
</descr>
<seealso>
<link id="EndThread"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="UInt64">
<short>Unsigned 64-bit integer</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPtrUInt">
<short>Pointer to unsigned integer of pointer size</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDateTime">
<short>Pointer to <var>TDatetime</var></short>
</element>

<!-- record type Visibility: default -->
<element name="TEntryInformation">
<short>Executable entry point information structure</short>
<descr>
<var>TEntryInformation</var> is used to initialize a Free Pascal program or 
library. Under normal circumstances, there should be no need to use this
structure directly: it is used by the system unit and special linking units.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TEntryInformation.InitFinalTable">
<short>List of units to initialize/finalize</short>
</element>

<!-- variable Visibility: default -->
<element name="TEntryInformation.ThreadvarTablesTable">
<short>List of threadvar locations</short>
</element>

<!-- variable Visibility: default -->
<element name="TEntryInformation.asm_exit">
<short>Exit procedure</short>
</element>

<!-- variable Visibility: default -->
<element name="TEntryInformation.PascalMain">
<short>Main pascal code routine</short>
</element>

<!-- variable Visibility: default -->
<element name="TEntryInformation.valgrind_used">
<short>Determine if valgrind is used or not</short>
</element>

<!-- function type Visibility: default -->
<element name="TCtrlBreakHandler">
<short>CTRL-C Handler prototype</short>
<descr>
<var>TCtrlBreakHandler</var> is the prototype for the CTRL-C handler.
If <var>CtrlBreak</var> is <var>True</var> then Ctrl-Break was hit,
otherwise <var>CTRL-C</var> was hit. The handlers should return
<var>True</var> to signal that the key-combination was handled. If
<var>False</var> is returned, then default handling will be used,
which by default means an exception will be raised if the sysutils unit is
used.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ModuleIsLib">
<short>Determines whether the current module is a library</short>
<descr>
<var>ModuleIsLib</var> is set by the compiler when linking a library,
program or package, and determines whether the current module is a
library (or package) (<var>True</var>) or program (<var>False</var>).
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ModuleIsPackage">
<short>Determines whether the current module is a package</short>
<descr>
<var>ModuleIsLib</var> is set by the compiler when linking a library,
program or package, and determines whether the current module is a
package (<var>True</var>) or a library or program (<var>False</var>).
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ModuleIsCpp">
<short>program compiled by CPP ?</short>
<descr>
<var>ModuleIsCpp</var> is always false for FPC programs, it is provided
for Delphi compatibility only.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_writestr_x">
<short>Internal write string procedure</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_readstr_x">
<short>Internal read string procedure</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_abs_long">
<short>Internal ABS function</short>
</element>

<!-- procedure Visibility: default -->
<element name="ReadBarrier">
<short>Memory Read Barrier</short>
<descr>
<var>ReadBarrier</var> is a low-level instruction to force a read barrier
in the CPU: all memory reads before the instruction will be finished before
this instruction, before memory reads after the instruction occur.
</descr>
<seealso>
<link id="ReadDependencyBarrier"/>
<link id="ReadWriteBarrier"/>
<link id="WriteBarrier"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReadDependencyBarrier">
<short>Memory Read Dependency Barrier</short>
<descr>
<var>ReadDependencyBarrier</var> is a low-level instruction to force a read
barrier in the CPU: all memory reads (loads) depending on previous loads are 
separate from the ones following the instruction.
</descr>
<seealso>
<link id="ReadBarrier"/>
<link id="ReadWriteBarrier"/>
<link id="WriteBarrier"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReadWriteBarrier">
<short>Memory read/write barrier</short>
<descr>
<var>ReadWriteBarrier</var> is a low-level instruction to force a read/write
barrier in the CPU: both read (Loads) and write (stores) operations before 
and after the barrier are separate.
</descr>
<seealso>
<link id="ReadBarrier"/>
<link id="ReadDependencyBarrier"/>
<link id="WriteBarrier"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="WriteBarrier">
<short>Memory write barrier</short>
<descr>
<var>WriteBarrier</var> is a low-level instruction to force a write
barrier in the CPU: write (store) operations before and after the 
barrier are separate.
</descr>
<seealso>
<link id="ReadBarrier"/>
<link id="ReadDependencyBarrier"/>
<link id="ReadWriteBarrier"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ShortCompareText">
<short>Compare 2 shortstrings</short>
<descr>
<p>
<var>ShortCompareText</var> compares two shortstrings, <var>S1</var> and <var>S2</var>,
and returns the following
result:
</p>
<dl>
<dt>&lt;0</dt><dd>if <var>S1&lt;S2</var>.</dd>
<dt>0</dt><dd>if <var>S1=S2</var>.</dd>
<dt>&gt;0</dt><dd>if <var>S1&gt;S2</var>.</dd>
</dl>
<p>
The comparision of the two strings is case-insensitive.
The function does not take internationalization settings into account, it
simply compares ASCII values.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="#rtl.sysutils.CompareText">CompareText</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TWideStringManager.ThreadInitProc">
<short>Called when a new thread is started.</short>
</element>

<!-- variable Visibility: default -->
<element name="TWideStringManager.ThreadFiniProc">
<short>Called when a thread has finished.</short>
</element>

<!-- procedure Visibility: default -->
<element name="DumpExceptionBackTrace">
<short>Create backtrace</short>
<descr>
<var>DumpExceptionBackTrace</var> writes a backtrace of the current
exception to the file <var>f</var>. If no exception is currently being
raised, nothing is written. As much frames as available are written.
If debug info is available, then file names and line numbers will be written
as well.
</descr>
<errors>
No check is done to see whether <var>f</var> is opened for writing.
</errors>
<seealso>
<link id="dump_stack"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitFPU">
<short>Initialize the FPU</short>
<descr>
<var>SysInitFPU</var> initializes (resets) the floating point unit, if one is
available. It is called for instance when a new thread is started.
</descr>
<seealso>
<link id="BeginThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysSetCtrlBreakHandler">
<short>System CTRL-C handler</short>
<descr>
<var>SysSetCtrlBreakHandler</var> sets the CTRL-C handler to the
<var>Handler</var> callback, and returns the previous value of the handler.
</descr>
<seealso>
<link id="TCtrlBreakHandler"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="VarArrayPut">
<short>Put a value in a single cell of a variant array</short>
<descr>
<p>
<var>VarArrayPut</var> puts <var>Value</var> in the variant array
<var>A</var> at the location indicated by <var>Indices</var>. Thus the
statement
</p>
<pre>
  VarArrayPut(A,B,[2,1]);
</pre>
<p>
is equivalent to 
</p>
<pre>
  A[2,1]:=B;
</pre>
<p>
The difference is that the previous is usable when the amount of indices
is not known at compile time.
</p>
</descr>
<errors>
If the number of indices is wrong (or out of range) an exception may be
raised.
</errors>
<seealso>
<link id="VarArrayGet"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="VarArrayGet">
<short>Get a value from a single cell of a variant array</short>
<descr>
<p>
<var>VarArrayGet</var> returns  the value in the variant array
<var>A</var> at the location indicated by <var>Indices</var>. Thus the
statement
</p>
<pre>
  B:=VarArrayGet(A,[2,1]);
</pre>
<p>
is equivalent to 
</p>
<pre>
  B:=A[2,1];
</pre>
<p>
The difference is that the previous is usable when the amount of indices
is not known at compile time.
</p>
</descr>
<errors>
If the number of indices is wrong (or out of range) an exception may be
raised.
</errors>
<seealso>
<link id="VarArrayPut"/>
</seealso>
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.InitThread">
<short>Called when a thread is initialized</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.DoneThread">
<short>Called when a thread ends</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.RelocateHeap">
<short>Relocate the heap to a different location</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DoneThread">
<short>End the current thread</short>
<descr>
<var>DoneThread</var> should be used to end the current thread. It performs
the necessary housekeeping before actually ending the thread. Using the
operating system calls to end the thread may result in data corruption
or memory leaks.
</descr>
<seealso>
<link id="BeginThread"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AllFilesMask">
<short>File mask for all files on the current platform</short>
<descr>
<var>AllFilesMask</var> is the wildcard that can be used to return
all files in a directory. Do not assume that this is '*' or '*.*' based on
the platform only. The actual value on DOS/Windows based systems can be
influenced by e.g. <link id="LFNSupport"/>.
</descr>
<seealso>
<link id="LFNSupport"/>
<link id="DirectorySeparator"/>
<link id="DriveSeparator"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="TContainedObject">
<short>Base class for contained objects</short>
<descr>
<var>TContainedObject</var> is the base class for contained objects, i.e.
objects that do not implement a reference counting mechanism themselves, but
are owned by some other object which handles the reference counting
mechanism. It implements the <var>IUnknown</var> interface and, more
specifically, the <var>QueryInterface</var> method of <var>IUnknown</var>.
</descr>
<seealso>
<link id="IInterface"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ExtensionSeparator">
<short>Character which separates the filename from the file extension.</short>
<descr>
<var>ExtensionSeparator</var> is the character which separates the filename
from the file extension. On all current platforms, this is the <var>.</var>
(dot) character. All RTL filename handling routines use this constant.
</descr>
<seealso>
<link id="PathSeparator"/>
<link id="DriveSeparator"/>
<link id="AllowDirectorySeparators"/>
<link id="AllowDriveSeparators"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AllowDirectorySeparators">
<short>Set of characters considered directory separators</short>
<descr>
<p>
<var>AllowDirectorySeparators</var> is the set of characters which are
considered directory separators by the RTL units. By default, this is set
to the most common directory separators: forward slash and backslash, so 
routines will work in a cross-platform manner, no matter which character
was used:
</p>
<pre>
 AllowDirectorySeparators : set of char = ['\','/'];
</pre>
<p>
If a more strict behaviour is desired, then <var>AllowDirectorySeparators</var> 
can be set to the only character allowed on the current operating system, and 
all RTL routines that handle filenames (splitting filenames, extracting
parts of the filename and so on) will use that character only.
</p>
</descr>
<seealso>
<link id="PathSeparator"/>
<link id="DriveSeparator"/>
<link id="ExtensionSeparator"/>
<link id="AllowDriveSeparators"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AllowDriveSeparators">
<short>Set of characters considered drive separators</short>
<descr>
<var>AllowDriveSeparators</var> are the characters which are considered
to separate the drive part from the directory part in a filename. This
will be an empty set on systems that do not support drive letters. Other
systems (Dos, Windows and OS/2) will have the colon (:) character as the
only member of this set.
</descr>
<seealso>
<link id="PathSeparator"/>
<link id="DriveSeparator"/>
<link id="ExtensionSeparator"/>
<link id="AllowDirectorySeparators"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="UnicodeChar">
<short>Unicode string character</short>
<descr>
<var>UnicodeChar</var> is a single character from a UnicodeString. It equals
<var>WideChar</var> in all respects.
</descr>
<seealso>
<link id="WideChar"/>
<link id="UnicodeString"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUnicodeChar">
<short>Pointer to unicode character</short>
<descr>
<var>PUnicodeChar</var> is a pointer to a unicode character, just like
<var>PChar</var> is a pointer to a <var>Char</var> ansistring character.
</descr>
<seealso>
<link id="UnicodeChar"/>
<link id="WideChar"/>
<link id="UnicodeString"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUnicodeString">
<short>Pointer to unicodestring</short>
<descr>
<var>PUnicodeString</var> is a pointer to a <var>UnicodeString</var> string.
</descr>
<seealso>
<link id="UnicodeChar"/>
<link id="PUnicodeChar"/>
<link id="WideChar"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="__status" skip="1" />
<element name="__spinlock" skip="1"/>
<element name="fpc_in_ror_x" skip="1"/>
<element name="fpc_in_ror_x_x" skip="1"/>
<element name="fpc_in_rol_x" skip="1"/>
<element name="fpc_in_rol_x_x" skip="1"/>
<element name="fpc_objc_selector_x" skip="1"/>

<element name="FillQWord">
<short>Fill memory range with QWord (64-bit) values</short>
<descr>
<var>FillQWord</var> fills the memory location of <var>x</var> with <var>Count</var>
times <var>value</var>. The size of the filled memory location is therefor
<var>8*count</var> bytes.
</descr>
<errors>
No checks are made to see if X actually has a minimum size of <var>(Count*8)</var>
bytes. Therefor, other variables can be overwritten or the memory may be out
of the accessible memory for the program. In the latter case a run-error or
exception may be triggered.
</errors>
<seealso>
<link id="FillChar"/>
<link id="FillWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IndexQWord">
<short>Return the position of a QWord in a memory range</short>
<descr>
<p>
<var>IndexQWord</var> checks the first <var>len</var> qwords starting at
<var>Buf</var>, and returns the position (zero-based) of <var>b</var>. If
<var>b</var> does not appear in the first <var>len</var> qwords, then
-1 is returned.
</p>
<p>
Note that the search is done on QWord boundaries, but that the address of
<var>buf</var> need not be on a QWord boundary.
</p>
</descr>
<errors>
No check is done to see whether the indicated memory range is valid. If it
is not, a run-error or exception may be triggered.
</errors>
<seealso>
<link id="IndexDWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RorByte">
<short>Rotate bits of a byte value to the right</short>
<descr>
<var>RorByte</var> rotates the bits of the byte <var>AValue</var> with <var>Dist</var>
positions to the right. If <var>Dist</var> is not specified, then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RolByte"/>
<link id="RorWord"/>
<link id="RorDWord"/>
<link id="RorQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RolByte">
<short>Rotate bits of a byte value to the left</short>
<descr>
<var>RolByte</var> rotates the bits of the byte <var>AValue</var> with
<var>Dist</var> positions to the left. If <var>Dist</var> is not specified, 
then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RorByte"/>
<link id="RolWord"/>
<link id="RolDWord"/>
<link id="RolQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RorWord">
<short>Rotate bits of a word value to the right</short>
<descr>
<var>RorWord</var> rotates the bits of the word <var>AValue</var> with
<var>Dist</var> positions to the right. If <var>Dist</var> is not specified, then 1 is
assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RorByte"/>
<link id="RolWord"/>
<link id="RorDWord"/>
<link id="RorQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RolWord">
<short>Rotate bits of a word value to the left</short>
<descr>
<var>RolWord</var> rotates the bits of the word <var>AValue</var> with
<var>Dist</var> positions to the right. If <var>Dist</var> is not specified,
then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RolByte"/>
<link id="RorWord"/>
<link id="RolDWord"/>
<link id="RolQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RorDWord">
<short>Rotate bits of a DWord (cardinal) value to the right</short>
<descr>
<var>RorDWord</var> rotates the bits of the DWord (cardinal) <var>AValue</var> 
with <var>Dist</var> positions to the right. If <var>Dist</var> is not specified,
then 1 is
assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RorByte"/>
<link id="RolDWord"/>
<link id="RorWord"/>
<link id="RorQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RolDWord">
<short>Rotate bits of a DWord (cardinal) value to the left</short>
<descr>
<var>RolDWord</var> rotates the bits of the DWord (cardinal) <var>AValue</var> with
<var>Dist</var> positions to the left. If <var>Dist</var> is not specified,
then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RolByte"/>
<link id="RolWord"/>
<link id="RorDWord"/>
<link id="RolQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RorQWord">
<short>Rotate bits of a QWord (64-bit) value to the right</short>
<descr>
<var>RorQWord</var> rotates the bits of the QWord (64-bit) <var>AValue</var> 
with <var>Dist</var> positions to the right. If <var>Dist</var> is not specified, 
then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RorByte"/>
<link id="RorWord"/>
<link id="RorDWord"/>
<link id="RolQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RolQWord">
<short>Rotate bits of a QWord (64-bit) value to the left</short>
<descr>
<var>RorQWord</var> rotates the bits of the QWord (64-bit) <var>AValue</var>
with <var>Dist</var> positions to the left. If <var>Dist</var> is not
specified, then 1 is assumed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="RolByte"/>
<link id="RolWord"/>
<link id="RolDWord"/>
<link id="RorQWord"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="float_round_nearest_even">
<short>Round to nearest even number</short>
</element>

<!-- constant Visibility: default -->
<element name="float_round_down">
<short>Round down</short>
</element>

<!-- constant Visibility: default -->
<element name="float_round_up">
<short>Round up</short>
</element>

<!-- constant Visibility: default -->
<element name="float_round_to_zero">
<short>Round in the direction of zero (down for positive, up for negative)</short>
</element>

<!-- variable Visibility: default -->
<element name="softfloat_rounding_mode">
<short>Rounding mode for softfloat</short>
<descr>
<p>
<var>softfloat_rounding_mode</var> determines how the software floating-point
emulation routines do the rounding. The value can be one of the following:
</p>
<dl>
<dt>float_round_nearest_even</dt><dd><printshort id="float_round_nearest_even"/></dd>
<dt>float_round_down</dt><dd><printshort id="float_round_down"/></dd>
<dt>float_round_up</dt><dd><printshort id="float_round_up"/></dd>
<dt>float_round_to_zero</dt><dd><printshort id="float_round_to_zero"/></dd>
</dl>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="UnicodeCharToString">
<short>Convert unicode character to string</short>
<descr>
<p>
<var>UnicodeCharToString</var> converts a null-word-terminated array of unicode characters 
in <var>S</var> to an AnsiString value. It simply calls <link id="UnicodeCharLenToString"/>
with the length of the string <var>S</var>.
</p>
<p>
This function requires the use of a widestring manager.
</p>
</descr>
<errors>
No checking is done to see if the pointer <var>S</var> is valid.
</errors>
<seealso>
<link id="StringToUnicodeChar"/>
<link id="UnicodeCharLenToString"/>
<link id="WidestringManager"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="StringToUnicodeChar">
<short>Convert an ansistring to a null-terminated array of unicode characters.</short>
<descr>
<p>
<var>StringToUnicodeChar</var> converts the ansistring <var>S</var> to a
unicodestring and places the result in <var>Dest</var>. The size of the
memory location pointed to by <var>Dest</var> must be given in
<var>DestSize</var>. If the result string is longer than the available size,
the result string will be truncated.
</p>
<p>
The function always returns <var>Dest</var>.
</p>
</descr>
<errors>
No check is performed to see whether <var>Dest</var> points to a valid
memory location.
</errors>
<seealso>
<link id="UnicodeCharToString"/>
<link id="UnicodeCharLenToString"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="UnicodeCharLenToString">
<short>Convert a memory buffer with unicode characters to an ansistring</short>
<descr>
<p>
<var>UnicodeCharLenToString</var> converts the unicode characters in buffer
<var>S</var> with at most <var>len</var> bytes length, to an ansistring and
returns the result.
</p>
<p>
This function requires the use of a widestring manager.
</p>
</descr>
<errors>
No checking is done to see if the pointer <var>S</var> or length <var>len</var> are valid.
</errors>
<seealso>
<link id="StringToUnicodeChar"/>
<link id="UnicodeCharToString"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UnicodeCharLenToStrVar">
<short>Convert a memory buffer with unicode characters to an ansistring</short>
<descr>
<p>
<var>UnicodeCharLenToString</var> converts the unicode characters in buffer
<var>S</var> with at most <var>len</var> bytes length, to an ansistring and
returns the result in <var>Dest</var>
</p>
<p>
This function does the same as <link id="UnicodeCharLenToString"/>.
</p>
</descr>
<errors>
No checking is done to see if the pointer <var>S</var> or length
<var>len</var> are valid.
</errors>
<seealso>
<link id="StringToUnicodeChar"/>
<link id="UnicodeCharToString"/>
<link id="UnicodeCharLenToString"/>
<link id="UnicodeCharToStrVar"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UnicodeCharToStrVar">
<short>Convert a null-terminated memory buffer with unicode characters to an ansistring</short>
<descr>
<p>
<var>UnicodeCharLenToString</var> converts the unicode characters in buffer
<var>S</var> up to the first null word, to an ansistring and
returns the result in <var>Dest</var>
</p>
<p>
This function does the same as <link id="UnicodeCharToString"/>.
</p>
</descr>
<errors>
No checking is done to see if the pointer <var>S</var> is valid.
</errors>
<seealso>
<link id="StringToUnicodeChar"/>
<link id="UnicodeCharToString"/>
<link id="UnicodeCharLenToString"/>
<link id="UnicodeCharToString"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DefaultUnicode2AnsiMove">
<short>Standard widestring manager callback</short>
<descr>
<var>DefaultUnicode2AnsiMove</var> is the standard callback used for the
widestring manager when a unicode string must be converted to an ansistring.
It replaces all words with value &lt; 256 with their value as ASCII code.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="WidestringManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DefaultAnsi2UnicodeMove">
<short>Standard widestring manager callback</short>
<descr>
<var>DefaultAnsi2UnicodeMove</var> is the standard callback used for the
widestring manager when an ansistring must be converted to a unicodestring.
It simply copies over all characters from the ansistring to the
unicodestring, no conversion whatsoever is performed.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUnicodeStringManager">
<short>Unicode string manager</short>
<descr>
<p>
<var>TUnicodeStringManager</var> is currently the same as the <link
id="TUnicodeStringManager"/> manager record. It performs the same functions:
converting unicode strings to ansistrings and vice-versa,
performing uppercase to lowercase transformations and comparing strings.
</p>
</descr>
<seealso>
<link id="TWideStringManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.Wide2AnsiMoveProc">
<short>Callback used when a unicode/wide string must be converted to an ansistring</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.Ansi2WideMoveProc">
<short>Callback used when an ansistring must be converted to a unicodestring/widestring.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.UpperWideStringProc">
<short>Callback used when a unicode/wide string must be uppercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.LowerWideStringProc">
<short>Callback used when a unicode/wide string must be lowercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareWideStringProc">
<short>Callback used when 2 unicode/wide strings must be compared</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareTextWideStringProc">
<short>Callback used when 2 unicode/wide strings must be compared case-insensitively</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CharLengthPCharProc">
<short>Callback used when the character length of a unicode/wide string must be calculated</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.UpperAnsiStringProc">
<short>Callback used when an ansistring must be uppercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.LowerAnsiStringProc">
<short>Callback used when an ansistring must be lowercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareStrAnsiStringProc">
<short>Callback used when 2 ansistrings must be compared.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareTextAnsiStringProc">
<short>Callback used when 2 ansistrings must be compared case insensitively.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrCompAnsiStringProc">
<short>Callback used when 2 ansistrings must be compared case insensitively</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrICompAnsiStringProc">
<short>Callback used when 2 null-terminated ansistring arrays must be compared case insensitively</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrLCompAnsiStringProc">
<short>Callback used when 2 ansistring arrays must be compared up to a given length</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrLICompAnsiStringProc">
<short>Callback used when 2 ansistring arrays must be compared case insensitively up to agiven length</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrLowerAnsiStringProc">
<short>Callback used when a null-terminated ansistring array must be lowercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.StrUpperAnsiStringProc">
<short>Callback used when a null-terminated ansistring array must be uppercased.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.ThreadInitProc">
<short>Called whenever a new thread is started.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.ThreadFiniProc">
<short>Called whenever a thread ends.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.Unicode2AnsiMoveProc">
<short>Callback used whenever a unicode string must be converted to an ansistring.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.Ansi2UnicodeMoveProc">
<short>Callback used whenever a ansistring must be converted to a unicode string.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.UpperUnicodeStringProc">
<short>Callback used to convert a unicode string to uppercase.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.LowerUnicodeStringProc">
<short>Callback used to convert a unicode string to lowercase.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareUnicodeStringProc">
<short>Callback used to compare 2 unicode strings.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CompareTextUnicodeStringProc">
<short>Callback used to compare 2 unicode strings case insensitively</short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeStringToUCS4String">
<short>Convert a unicode string to a UCS-4 string.</short>
<descr>
<p>
<var>UnicodeStringToUCS4String</var> converts a unicode string <var>S</var> to a UCS-4
encoded string, and returns the resulting string.
</p>
<p>
This function requires the widestring manager.
</p>
</descr>
<seealso>
<link id="UCS4StringToUnicodeString"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="UCS4StringToUnicodeString">
<short>Convert a UCS-4 encoded string to a unicode string</short>
<descr>
<p>
<var>UCS4StringToUnicodeString</var> converts the UCS-4 encoded string
<var>S</var> to a unicode string and returns the resulting string.
</p>
<p>
This function requires the widestring manager.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="UnicodeStringToUCS4String"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="GetUnicodeStringManager">
<short>Return a copy of the currently active unicodetring manager.</short>
<descr>
<p>
<var>GetUnicodeStringManager</var> returns a copy of the currently active 
unicode string manager in <var>Old</var>
</p>
<p>
UnicodeStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a UnicodeStringManager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstring</file>).
</p>
<p>
It is possible to implement a custom unicodestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<seealso>
<link id="SetUnicodeStringManager"/>
<link id="TUnicodeStringManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetUnicodeStringManager">
<short>Set the unicodestring manager</short>
<descr>
<p>
<var>SetUnicodeStringManager</var> sets the current unicodestring manager to <var>New</var>.
Optionally, it returns the currently active widestring manager in <var>Old</var>.
</p>
<p>
UnicodeStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a UnicodeString manager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstring</file>).
</p>
<p>
It is possible to implement a custom unicodestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="TUnicodeStringManager"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmt">
<short>Pointer to <link id="#rtl.system.TVMT">TVMT</link> record</short>
</element>

<!-- record type Visibility: default -->
<element name="TVmt">
<short>Virtual method table layout</short>
<descr>
<var>TVMT</var> is a record describing the VMT of a class. It's various
fields represent the available information in the VMT, as far as it is
common to all classes.
</descr>
<seealso>
<link id="PVmt"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vInstanceSize">
<short>Class instance size</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vInstanceSize2">
<short>Duplicate of class instance size (should equal -vInstanceSize)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vParent">
<short>Pointer to parent VMT</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vClassName">
<short>Pointer to shortstring with classname</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDynamicTable">
<short>Pointer to table with dynamic methods.</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vMethodTable">
<short>Pointer to table with virtual methods.</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vFieldTable">
<short>Pointer to table with field information</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vTypeInfo">
<short>Pointer to class type info record.</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vInitTable">
<short>Pointer to initialization information</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vAutoTable">
<short>Pointer to Automation interfaces table</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vIntfTable">
<short>Pointer to interfaces table</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vMsgStrPtr">
<short>Pointer to string message dispatch table</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDestroy">
<short>Pointer to destructor</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vNewInstance">
<short>Pointer to NewInstance method</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vFreeInstance">
<short>Pointer to FreeInstance method</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vSafeCallException">
<short>?</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDefaultHandler">
<short>Pointer to default message handler</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vAfterConstruction">
<short>Pointer to afterconstruction method.</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vBeforeDestruction">
<short>Pointer to beforeconstruction method.</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDefaultHandlerStr">
<short>Pointer to default string message handler</short>
</element>

<!-- alias type Visibility: default -->
<element name="PInterface">
<short>Pointer to <link id="#rtl.system.IInterface">IInterface</link> interface</short>
</element>

<!-- record type Visibility: default -->
<element name="_fpc_objc_sel_type" skip="1"/>

<!-- pointer type Visibility: default -->
<element name="SEL" skip="1"/>


<!-- alias type Visibility: default -->
<element name="TFPResourceHandle">
<short>Handle to resource</short>
<descr>
<var>TFPResourceHandle</var> represents a handle to a binary resource and is
used in the various resource calls. Its actual type and size may differ accross 
platforms. 
</descr>
<seealso>
<link id="TFPResourceHMODULE"/>
<link id="TFPResourceHGLOBAL"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TFPResourceHMODULE">
<short>Handle to module containing resource</short>
<descr>
<var>TFPResourceHMODULE</var> represents a module (library, executable, other) in which
a resource is located. It is used in the various resource calls. It is an opaque type: 
its actual type and size may differ accross platforms.
</descr>
<seealso>
<link id="TFPResourceHandle"/>
<link id="TFPResourceHGLOBAL"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TFPResourceHGLOBAL">
<short>TFPResourceHGLOBAL</short>
<descr>
<var>TFPResourceHGLOBAL</var> represents a handle to the global module
containing a resource. It is used in the various resource calls. 
It is an opaque type: its actual type and size may differ accross platforms.
</descr>
<seealso>
<link id="TFPResourceHandle"/>
<link id="TFPResourceHMODULE"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RT_ANICURSOR">
<short>Resource type: Animated cursor</short>
<descr>
This constant can be used to specify a resource of type "animated cursor".
</descr>
<seealso>
<link id="RT_CURSOR"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RT_ANIICON">
<short>Resource type: Animated icon</short>
<descr>
This constant can be used to specify a resource of type "animated icon".
</descr>
<seealso>
<link id="RT_ICON"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RT_HTML">
<short>Resource type: HTML data</short>
<descr>
This constant can be used to specify a resource of type "HTML data".
</descr>
<seealso>
<link id="RT_MANIFEST"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RT_MANIFEST">
<short>Resource type: manifest</short>
<descr>
This constant can be used to specify a resource of type "Manifest".
</descr>
<seealso>
<link id="RT_HTML"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="EnumResTypeProc">
<short>Callback for resource type enumeration</short>
<descr>
<var>EnumResTypeProc</var> is used in the <link id="EnumResourceTypes"/>
call. It is called for all resources, and is passed the
<var>ModuleHandle</var>, <var>ResourceType</var> values for each 
resource encountered. Additionally, the <var>lParam</var> 
parameter from the <var>EnumResourceTypes</var> is passed unaltered.
</descr>
<seealso>
<link id="EnumResourceTypes"/>
<link id="EnumResNameProc"/>
<link id="EnumResLangProc"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="EnumResNameProc">
<short>Callback for resource name enumeration</short>
<descr>
<var>EnumResNameProc</var>s used in the <link id="EnumResourceNames"/> call.
It is called for all resources of the specified type, and is passed the <var>ModuleHandle</var>, 
<var>ResourceType</var>, <var>ResourceName</var> values for each resource encountered. Additionally, 
the <var>lParam</var> parameter from the <var>EnumResourceNames</var> is passed unaltered.
</descr>
<seealso>
<link id="EnumResourceNames"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="EnumResLangProc">
<short>Callback for language resource enumeration</short>
<descr>
<var>EnumResNameProc</var>s used in the <link id="EnumResourceLanguages"/> call.
It is called for all languages for a resource of the specified type and name, 
and is passed the <var>ModuleHandle</var>,
<var>ResourceName</var>, <var>ResourceName</var> and <var>IDLanguage</var> values for each
language encountered for the specified resource. Additionally,
the <var>lParam</var> parameter from the <var>EnumResourceLanguages</var> is
passed unaltered.
</descr>
<seealso>
<link id="EnumResourceLanguages"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Is_IntResource">
<short>Check whether a resource is an internal resource</short>
<descr>
<var>Is_IntResource</var> returns <var>True</var> if the resource type is
internal (system predefined) resource or false if it is a user-defined
resource type.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="MakeLangID">
<short>Create a langauge ID</short>
<descr>
<var>MakeLangID</var> creates a language ID from the <var>primary</var> and
<var>sub</var> language IDS. 
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="EnumResourceTypes">
<short>Enumerate available resource types</short>
<descr>
<var>EnumResourceTypes</var> enumerates the types of all resources in the
module <var>ModuleHandle</var>. For each resource available it calls
<var>EnumFunc</var> and passes it <var>ModuleHandle</var>, the type of
the resource, and <var>lParam</var>. It returns <var>False</var> if no
resources are available for the specified module, or <var>True</var> if
there are resources available.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="EnumResourceNames"/>
<link id="EnumResourceLanguages"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="EnumResourceNames">
<short>Enumerate available resource names for a specified resource type</short>
<descr>
<var>EnumResourceNames</var> enumerates the names of all resources of type
<var>ResourceType</var> in the module <var>ModuleHandle</var>. For each 
resource available it calls <var>EnumFunc</var> and passes it <var>ModuleHandle</var>, the type of
the resource <var>ResourceType</var>, the name of the resource, and <var>lParam</var>. 
It returns <var>False</var> if no resources are available for the specified resource
type and module, or <var>True</var> if there are resources available.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="EnumResourceTypes"/>
<link id="EnumResourceLanguages"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="EnumResourceLanguages">
<short>Enumerate available languages for a resource of given type and name</short>
<descr>
<var>EnumResourceLanguages</var> enumerates the available languages for a
resource of given <var>ResourceName</var> and type <var>ResourceType</var> 
in the module <var>ModuleHandle</var>.  
For each language availanle, it calls <var>EnumFunc</var> and passes it
<var>ModuleHandle</var>, the type of the resource <var>ResourceType</var>, the name of the resource
<var>ResourceName</var>, the language ID, and <var>lParam</var>.
It returns <var>False</var> if no resources are available for the specified
resource type and module, or <var>True</var> if there are resources available.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="EnumResourceTypes"/>
<link id="EnumResourceNames"/>
<link id="EnumResourceLanguages"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="FindResourceEx">
<short>Find a resource based on type, name, language</short>
<descr>
<p>
<var>FindResourceEx</var> looks in module <var>ModuleHandle</var> for a
resource of type <var>ResourceType</var> and name <var>ResourceName</var>
with languague ID <var>Language</var>. Both <var>Resourcename</var> and
<var>ResourceName</var> can be specified as a null-terminated array of
characters, or as an AnsiString.
</p>
<p>If the requested language/sublanguage  is not found, then the search is
conducted</p>
<ol>
<li>with only primary language.</li>
<li>with the neutral language (<var>LANG_NEUTRAL</var>)</li>
<li>with the english language</li>
</ol>
<p>
If none of these has returned a match, then the first available language is
returned.
</p>
<p>
If a match is found, a handle to the resource is returned. If none is found,
an empty handle (nil or 0) is returned.
</p>
</descr>
<errors>
None.
</errors>
</element>

<!-- record type Visibility: default -->
<element name="TResourceManager">
<short>Resource manager definition</short>
<descr>
<p>
<var>TResourceManager</var> is the record describing the resource manager.
Depending on the kind of resources (internal, external), another resource 
managing handler is installed by the system. The resource manager record is
used by all resource handling functions to do the actual work: for each
function in the API, a handler function is available. People wishing to
implement their own resource manager, must implement all handler functions
in their implementation.
</p>
<p>
As soon as resources are used, the compiler will install a resource manager,
depending on the platform, this may be an internal or an external resource
manager.
</p>
</descr>
<seealso>
<link id="GetResourceManager"/>
<link id="SetResourceManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.HINSTANCEFunc">
<short>Return the programs instance handle.</short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.EnumResourceTypesFunc">
<short>Handler for <link id="#rtl.system.EnumResourceTypes">EnumResourceTypes</link>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.EnumResourceNamesFunc">
<short>Handler for <link id="#rtl.system.EnumResourceNames">EnumResourceNames</link>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.EnumResourceLanguagesFunc">
<short>Handler for <link id="#rtl.system.EnumResourceLanguages">EnumResourceLanguages</link>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.FindResourceFunc">
<short>Handler for <link id="#rtl.system.FindResource">FindResource</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.FindResourceExFunc">
<short>Handler for <link id="#rtl.system.FindResourceEx">FindResourceEx</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.LoadResourceFunc">
<short>Handler for <link id="#rtl.system.LoadResource">LoadResource</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.SizeofResourceFunc">
<short>Handler for <link id="#rtl.system.SizeOfResource">SizeOfResource</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.LockResourceFunc">
<short>Handler for <link id="#rtl.system.LockResource">LockResource</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.UnlockResourceFunc">
<short>Handler for <link id="#rtl.system.UnLockResource">UnLockResource</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TResourceManager.FreeResourceFunc">
<short>Handler for <link id="#rtl.system.FreeResource">FreeResource</link></short>
</element>

<!-- procedure Visibility: default -->
<element name="GetResourceManager">
<short>Return the currently active resource manager</short>
<descr>
<var>GetResourceManager</var> returns the currently active resource manager record
in <var>Manager</var>. There is always an active resource manager record.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TResourceManager"/>
<link id="SetResourceManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetResourceManager">
<short>Set the resource manager</short>
<descr>
<p>
<var>SetResourceManager</var> sets the active resource manager to
<var>Manager</var>. After a call to <var>SetResourceManager</var>, the
functions in the <var>Manager</var> record will be used to handle resources.
</p>
<p>
Note that it is not supported to change resource managers on-the-fly: any
resources or information about resources obtained should be discareded prior
to a call to <var>SetResourceManager</var>. Typically,
<var>SetResourceManager</var> should be called once, at program startup.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TResourceManager"/>
<link id="GetResourceManager"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UnixGetModuleByAddrHook">
<short>(Unix only) callback for <var>GetModuleByAddr</var></short>
<descr>
<var>UnixGetModuleByAddrHook</var> is used on Unix systems to retrieve a
module name based on an address. It is used in the <link
id="#rtl.exeinfo">exeinfo</link> unit to map addresses to module (programs
or library) names.
</descr>
<seealso>
<link id="#rtl.exeinfo">exeinfo</link>
</seealso>
</element>

<element name="WriteStr">
<short>Write variables to a string</short>
<descr>
<p>
<var>WriteStr</var> behaves like <link id="Write"/>, except that it stores
its output in the string variable <var>S</var> instead of a file.
Semantically, the <var>WriteStr</var> call is equivalent to writing the
arguments to a file using the <var>Write</var> call, and then reading them
into <var>S</var> using the <var>Read</var> call from the same file:
</p>
<code>
var
  F : Text;
begin
  Rewrite(F);
  Write(F,Args);
  Close(F);
  Reset(F);
  Read(F,S);
  Close(F);
end;  
</code>
<p>
Obviously, the <var>WriteStr</var> call does not use a temporary file.
</p>
<p>
<var>WriteStr</var> is defined in the ISO Extended Pascal standard.
More information on the allowed arguments and the possible formatting can be
found in the description of <link id="Write"/>.
</p>
</descr>
<seealso>
<link id="Write"/>
<link id="ReadStr"/>
<link id="Read"/>
</seealso>
</element>

<element name="ReadStr">
<short>Read variables from a string</short>
<descr>
<p>
<var>ReadStr</var> behaves like <link id="Read"/>, except that it reads
its input from the string variable <var>S</var> instead of a file.
Semantically, the <var>ReadStr</var> call is equivalent to writing the
string to a file using the <var>Write</var> call, and then reading them
into the various arguments <var>Arg</var> using the <var>Read</var> call 
from the same file:
</p>
<code>
var
  F : Text;
begin
  Rewrite(F);
  Write(F,S);
  Close(F);
  Reset(F);
  Read(F,Args);
  Close(F);
end;  
</code>
<p>
Obviously, the <var>ReadStr</var> call does not use a temporary file.
</p>
<p>
<var>ReadStr</var> is defined in the ISO Extended Pascal standard.
More information on the allowed arguments and the behaviour of the arguments
can be found in the description of <link id="Read"/>.
</p>
</descr>
<seealso>
<link id="Read"/>
<link id="WriteStr"/>
<link id="Write"/>
</seealso>
</element>

<element name="pack">
<short>Create packed array from normal array</short>
<descr>
<p>
<var>Pack</var> will copy the elements of an unpacked array
(<var>A</var>) to a packed array (<var>Z</var>). 
It will start the copy at the index denoted by <var>StartIndex</var>.
The type of the index variable <var>StartIndex</var> must match the type
of the index of <var>A</var>. The elements are always transferred to the
beginning of the packed array <var>Z</var>. (i.e. it starts at <var>Low(Z)</var>).
</p>
<p>
Obviously, the type of the elements of the arrays <var>A</var> and <var>Z</var> must
match.
</p>
</descr>
<seealso>
<link id="unpack"/>
</seealso>
</element>

<element name="UnPack">
<short>Create unpacked array from packed array</short>
<descr>
<p>
<var>UnPack</var> will copy the elements of a packed array (<var>Z</var>)
to an unpacked array (<var>A</var>). All elements in <var>Z</var> are copied
to <var>A</var>, starting at index <var>StartIndex</var> in <var>A</var>. 
The type of the index variable <var>StartIndex</var> must match
the type of the index of <var>A</var>.
</p>
<p>
Obviously, the type of the elements of the arrays <var>A</var> and
<var>Z</var> must match.
</p>
</descr>
<seealso>
<link id="Pack"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPPChar">
<short>Pointer to <var>PPChar</var>.</short>
<descr>
<var>PPPChar</var> is a pointer to a <link id="PPChar"/>
</descr>
<seealso>
<link id="PPChar"/>
</seealso>
</element>

<!-- "type" alias type Visibility: default -->
<element name="TDate">
<short>Alias for <var>TDateTime</var> type.</short>
<descr>
<var>TDate</var> is defined for Delphi compatibility. This type is
deprecated, use <link id="TDateTime"/> instead.
</descr>
<seealso>
<link id="TDateTime"/>
<link id="TTime"/>
</seealso>
</element>

<!-- "type" alias type Visibility: default -->
<element name="TTime">
<short>Alias for <var>TDateTime</var> type.</short>
<descr>
<var>TTime</var> is defined for Delphi compatibility. This type is
deprecated, use <link id="TDateTime"/> instead.
</descr>
<seealso>
<link id="TDateTime"/>
<link id="TDate"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPDouble">
<short>Pointer to <var>PDouble</var> type.</short>
<descr>
<var>PPDouble</var> is a pointer to a <link id="PDouble"/> type.
</descr>
<seealso>
<link id="PDouble"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPByte">
<short>Pointer to <var>PByte</var> type.</short>
<descr>
<var>PPByte</var> is a pointer to a <link id="PByte"/> type.
</descr>
<seealso>
<link id="PByte"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPLongint">
<short>Pointer to <var>PLongint</var> type.</short>
<descr>
<var>PPLongint</var> is a pointer to a <link id="PLongint"/> type.          
</descr>
<seealso>
<link id="PLongint"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPPWideChar">
<short>Pointer to <var>PPWideChar</var> type.</short>
<descr>
<var>PPPWideChar</var> is a pointer to a <link id="PPWideChar"/> type.
</descr>
<seealso>
<link id="PPWideChar"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vmtDispatch">
<short>Offset to dispatch table</short>
<descr>
<var>vmtDispatch</var> is the offset from the VMT start, in bytes to the dispatch table for a
class.The dispatch table is used when dispatching messages in <link id="TObject.Dispatch"/>
</descr>
<seealso>
<link id="vmtDispatchStr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vmtDispatchStr">
<short>Offset to string dispatch table</short>
<descr>
<var>vmtDispatchStr</var> is the offset from the VMT start, in bytes to the dispatch table for a
class.The dispatch table is used when dispatching messages in <link id="TObject.DispatchStr"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vmtEquals">
<short>Offset to the <var>Equals</var> method pointer</short>
<descr>
<var>vmtEquals</var> contains the offset from the VMT start, of the location
of the <link id="TObject.Equals"/> method pointer.
</descr>
<seealso>
<link id="vmtGetHashCode"/>
<link id="vmtToString"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vmtGetHashCode">
<short>Offset to the <var>GetHashCode</var> method pointer</short>
<descr>
<var>vmtGetHashCode</var> contains the offset from the VMT start, of the location
of the <link id="TObject.GetHashCode"/> method pointer.
</descr>
<seealso>
<link id="vmtEquals"/>
<link id="vmtToString"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vmtToString">
<short>Offset to the <var>ToString</var> method pointer</short>
<descr>
<var>vmtToString</var> contains the offset from the VMT start, of the
location of the <link id="TObject.ToString"/> method pointer.      
</descr>
<seealso>
<link id="vmtGetHashCode"/>
<link id="vmtEquals"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDispatch">
<short><var>Dispatch</var> method pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vDispatchStr">
<short><var>DispatchStr</var> method pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vEquals">
<short><var>Equals</var> method pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vGetHashCode">
<short><var>GetHashCode</var> method pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmt.vToString">
<short><var>ToString</var> method pointer</short>
</element>

<!-- function Visibility: public -->
<element name="TObject.UnitName">
<short>Unit name</short>
<descr>
<var>UnitName</var> returns the unit name in which the class was defined.
The name is obtained from the class definition data the compiler generates
for each class.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TObject.Equals">
<short>Check if two objects are equal.</short>
<descr>
<p>
<var>Equals</var> returns <var>True</var> if the object instance
pointer (<var>Self</var>) equals the instance pointer <var>Obj</var>.
</p>
<p>
Descendent classes can override to check properties etc. in case the
instance pointers are different.
</p>
</descr>
<seealso>
<link id="TObject.GetHashCode"/>
<link id="TObject.ToString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.GetHashCode">
<short>Return a hash code for the object</short>
<descr>
<p>
<var>GetHashCode</var> should return a hash code for the object. By default,
the numerical (integer) address of <var>Self</var> is returned. 
</p>
<p>
Descendent classes can use this to generate better suitable values to be
used in a hash table.
</p>
</descr>
<seealso>
<link id="TObject.ToString"/>
<link id="TObject.Equals"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ToString">
<short>Return a string representation for the object</short>
<descr>
<p>
<var>ToString</var> returns by default the class name of the object.
It is useful during sending of debug messages.
</p>
<p>
Descendent classes can override this method to give a better description of
the object than just the class name. 
</p>
</descr>
<seealso>
<link id="TObject.GetHashCode"/>
<link id="TObject.Equals"/> 
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.System.IEnumerator
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IEnumerator">
<short>Enumerator support interface</short>
<descr>
<p>
<var>IEnumerator</var> is the interface needed by the <var>For ... in
...</var> language construct, when operating on classes. It contains all
methods that the compiler needs to implement a loop.
</p>
<p>
A <var>for in</var> loop like the following:
</p>
<code>
For O in MyObject do
  begin
  // do things
  end;
</code>
<p>
is treated by the compiler as equivalent to the following code:
</p>
<code>
Var
  I : IEnumerator;
  O : TObject;
    
begin
  I:=MyObject.GetEnumerator;
  While I.MoveNext do
    begin
    O:=I.GetCurrent;
    // Do things
    end; 
end.  
</code>
<p>
Any class that implements the <var>IEnumerable</var> interface must be able
to return an <var>IEnumerator</var> instance for the compiler to use in a
<var>For in</var> loop.
</p>
</descr>
<seealso>
<link id="IEnumerable"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IEnumerator.GetCurrent">
<short>Returns the current element in the iteration cycle</short>
<descr>
<p>
<var>getCurrent</var> should return the object instance representing the current value in the
<var>for in</var> loop. <var>GetCurrent</var> will always be called
immediately after <link id="IEnumerator.MoveNext"/> returned <var>True</var>. 
</p>
<remark>
The actual return type of the interface should not necessarily be
<var>TObject</var>, it can be any type. The compiler will check the 
actual return type with the type of the loop variable, and they should 
match.
</remark>
</descr>
<seealso>
<link id="IEnumerator.MoveNext"/>
<link id="IEnumerator.Reset"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IEnumerator.MoveNext">
<short>Move to the next value</short>
<descr>
<var>MoveNext</var> should move the current item pointer to the next
available item. It should return <var>True</var> if an item is available,
<var>False</var> if no more items are available. The first time it is called
It will be called at the beginning of the for loop, so it should position
the enumerator on the first value (if there is one). After
<var>MoveNext</var> has returned <var>True</var>, <link
id="IEnumerator.GetCurrent"/> will be called to retrieve the item.
</descr>
<seealso>
<link id="IEnumerator.Reset"/>
<link id="IEnumerator.GetCurrent"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IEnumerator.Reset">
<short>Reset the pointer</short>
<descr>
<var>Reset</var> can be implemented to put the pointer at the start of the
list. It is not mandatory to implement this method, the compiler does not
use it.
</descr>
<seealso>
<link id="IEnumerator.GetCurrent"/>
<link id="IEnumerator.MoveNext"/>
</seealso>
</element>

<!-- property Visibility: default -->
<element name="IEnumerator.Current">
<short>Return the current item</short>
<descr>
<var>Current</var> simply is the redefinition of  <link id="IEnumerator.GetCurrent"/> as
a property. It is read-only.
</descr>
<seealso>
<link id="IEnumerator.GetCurrent"/>
<link id="IEnumerator.MoveNext"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.System.IEnumerable
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IEnumerable">
<short>Interface to retrieve an enumerator from a class.</short>
<descr>
<var>IEnumerable</var> can be used to get an enumerator from a class.
If a class implements <var>IEnumerable</var>, it can return an enumerator
interface <link id="IEnumerator"/>.
</descr>
<seealso>
<link id="IEnumerator"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IEnumerable.GetEnumerator">
<short>Return an enumerator interface for this class</short>
<descr>
<var>GetEnumerator</var> returns a new <link id="IEnumerator"/> interface
for this class. This is called by the compiler whenever a <var>for in</var>
loop is encountered in the source code to retrieve the enumerator instance.
</descr>
<seealso>
<link id="IEnumerator"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator or(variant, variant): variant">
<short>Implement logical/binary <var>or</var> operation on variants</short>
<descr>
The implementation of the <var>or</var> operation is delegated to the variant manager
with operation <var>opor</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator and(variant, variant): variant"/>
<link id="operator xor(variant, variant): variant"/>
<link id="operator not(variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator and(variant, variant): variant">
<short>Implement logical/binary <var>and</var> operation on variants</short>
<descr>
The implementation of the <var>and</var> operation is delegated to the variant manager with operation
<var>opand</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator or(variant, variant): variant"/>
<link id="operator xor(variant, variant): variant"/>
<link id="operator not(variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator xor(variant, variant): variant">
<short>Implement logical/binary <var>xor</var> operation on variants</short>
<descr>
The implementation of the <var>xor</var> operation is delegated to the variant manager
with operation <var>opxor</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator or(variant, variant): variant"/>
<link id="operator and(variant, variant): variant"/>
<link id="operator not(variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator not(variant): variant">
<short>Implement logical/binary <var>not</var> operation on variants</short>
<descr>
The implementation of the <var>not</var> operation is delegated to the variant manager
with operation <var>opnot</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator and(variant, variant): variant"/>
<link id="operator or(variant, variant): variant"/>
<link id="operator xor(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator shl(variant, variant): variant">
<short>Implement binary <var>shl</var> operation on variants.</short>
<descr>
The implementation of the <var>shl</var> operation is delegated to the variant manager
with operation <var>opshiftleft</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator shr(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator shr(variant, variant): variant">
<short>Implement binary <var>shr</var> operation on variants.</short>
<descr>
The implementation of the <var>shr</var> operation is delegated to the
variant manager with operation <var>opshiftright</var>.     
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator shl(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator +(variant, variant): variant">
<short>Implement addition <var>(+)</var> operation on variants.</short>
<descr>
The implementation of the addition <var>+</var> operation is delegated to the
variant manager with operation <var>opadd</var>.
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator -(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator -(variant, variant): variant">
<short>Implement subtraction <var>(-)</var> operation on variants.</short>
<descr>
The implementation of the subtraction <var>-</var> operation is delegated to the  
variant manager with operation <var>opSubtract</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator -(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator *(variant, variant): variant">
<short>Implement multiplication <var>(*)</var> operation on variants.</short>
<descr>
The implementation of the multiplication <var>*</var> operation is delegated to the  
variant manager with operation <var>opMultiply</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator /(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator /(variant, variant): variant">
<short>Implement division <var>(/)</var> operation on variants.</short>
<descr>
The implementation of the division <var>/</var> operation is delegated to the  
variant manager with operation <var>opDivide</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator *(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator **(variant, variant): variant">
<short>Implement power <var>(**)</var> operation on variants.</short>
<descr>
The implementation of the power <var>**</var> operation is delegated to the  
variant manager with operation <var>opPower</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator *(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator div(variant, variant): variant">
<short>Implement <var>div</var> (integer division) operation on variants.</short>
<descr>
The implementation of the integer division <var>Div</var> operation is delegated to the  
variant manager with operation <var>opintdivide</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator mod(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator mod(variant, variant): variant">
<short>Implement <var>mod</var> (modulo) operation on variants.</short>
<descr>
The implementation of the modulo <var>Mod</var> operation is delegated to the  
variant manager with operation <var>opModulus</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator div(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator -(variant): variant">
<short>Implement <var>-</var> (unary minus, negation) operation on variants.</short>
<descr>
The implementation of the unary minus <var>(-)</var> operation is delegated to the  
variant manager with operation <var>varNeg</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator -(variant, variant): variant"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator =(variant, variant): Boolean">
<short>Implement <var>=</var> (equality) operation on variants.</short>
<descr>
The implementation of the equality <var>(=)</var> operation is delegated to the  
variant manager with operation <var>opcmpeq</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator &lt;(variant, variant): boolean"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator &lt;(variant, variant): Boolean">
<short>Implement <var>&lt;</var> (less than) operation on variants.</short>
<descr>
The implementation of the "less than" comparison <var>(&lt;)</var> operation is delegated to the  
variant manager with operation <var>opcmplt</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator &gt;(variant, variant): boolean"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator >(variant, variant): Boolean">
<short>Implement <var>&gt;</var> (greater than) operation on variants.</short>
<descr>
The implementation of the "greater than" comparison <var>(&gt;)</var> operation is delegated to the  
variant manager with operation <var>opcmpgt</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator &lt;(variant, variant): boolean"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator &gt;=(variant, variant): Boolean">
<short>Implement <var>&gt;=</var> (greater than or equal) operation on variants.</short>
<descr>
The implementation of the "greater than or equal" comparison <var>(&gt;=)</var> operation is delegated to the  
variant manager with operation <var>opcmpge</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator &lt;(variant, variant): boolean"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="operator &lt;=(variant, variant): Boolean">
<short>Implement <var>&lt;=</var> (less than or equal) operation on variants.</short>
<descr>
The implementation of the "less than or equal" comparison
<var>(&lt;=)</var> operation is delegated to the
variant manager with operation <var>opcmple</var>. 
</descr>
<errors>
Execution of this operator may result in an exception if no variant manager
is installed or if the types of the operand are not suitable for the
operation.
</errors>
<seealso>
<link id="operator &lt;(variant, variant): boolean"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TCriticalSectionHandlerTryEnter">
<short>Function prototype for <var>TryEnterCriticalsection</var></short>
<descr>
<var>TCriticalSectionHandlerTryEnter</var> is the function prototype for the 
<link id="TryEnterCriticalsection"/> function, in the <link
id="TThreadManager"/> record's <var>TryEnterCriticalSection</var> field.
</descr>
<seealso>
<link id="TryEnterCriticalsection"/>
<link id="GetThreadManager"/>
<link id="TThreadManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.CloseThread">
<short>Implements <var>CloseThread</var>.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.TryEnterCriticalSection">
<short>Implements <var>TryEnterCriticalsection</var>.</short>
</element>

<!-- function Visibility: default -->
<element name="CloseThread">
<short>Close a thread and free up resources used by the thread</short>
<descr>
<var>CloseThread</var> must be called on any thread started with <link
id="BeginThread"/>. It must be called after the thread has ended (either by
exiting the thread function or after calling <link id="EndThread"/>).
</descr>
<errors>
If no threadmanager is installed, an exception may be raised or runtime
error 232 may occur if no exceptions are used.
</errors>
<seealso>
<link id="BeginThread"/>
<link id="EndThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="TryEnterCriticalsection">
<short>Try entering a critical section</short>
<descr>
<var>TryEnterCriticalsection</var> attempts to enter critical section
<var>cs</var>. It returns at once. The return value is zero if another
thread owns the critical section, or nonzero if the current thread already
owns or succesfully obtained the critical section.
</descr>
<seealso>
If no threadmanager is installed, an exception may be raised or runtime
error 232 may occur if no exceptions are used.
</seealso>
</element>

<element name="mem">
<short>Direct memory access (DOS only) in bytes</short>
<descr>
<var>mem</var> is an array of bytes, representing the computer's memory.
This array is available only when compiling for the Dos Go32V2 target.
It's use is not recommended, and it is not even available on other
platforms.
</descr>
<seealso>
<link id="memw"/>
<link id="meml"/>
</seealso>
</element>
<element name="memw">
<short>Direct memory access (DOS only) in words</short>
<descr>
<var>memw</var> is an array of words, representing the computer's memory as
2-byte words. This array is available only when compiling for the Dos Go32V2 target
It's use is not recommended, and it is not even available on other
platforms.
</descr>
<seealso>
<link id="mem"/>
<link id="meml"/>
</seealso>
</element>
<element name="meml">
<short>Direct memory access (DOS only) in longints</short>
<descr>
<var>memw</var> is an array of longints, representing the computer's memory
as 32-bit signed integers.
This array is available only when compiling for the Dos Go32V2 target.
It's use is not recommended, and it is not even available on other
platforms.
</descr>
<seealso>
<link id="memw"/>
<link id="mem"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValReal">
<short>Largest available floating point type</short>
<descr>
<var>ValReal</var> is an alias for the largest available floating point type
on the architecture the program runs on. On most processors, it should be one of
<var>Double</var> or <var>Extended</var>.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="NativeInt">
<short>Alias for <var>PtrInt</var></short>
<descr>
<var>NativeInt</var> is defined for Delphi compatibility. It is a signed integer
with the size of a pointer, so 32-bit on 32-bit platforms, 64-bit on 64-bit
platforms.
</descr>
<seealso>
<link id="PtrInt"/>
<link id="NativeUint"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="NativeUint">
<short>Alias for <var>PtrUint</var></short>
<descr>
<var>NativeInt</var> is defined for Delphi compatibility. It is an unsigned integer  
with the size of a pointer, so 32-bit on 32-bit platforms, 64-bit on 64-bit
platforms. 
</descr>
<seealso>
<link id="PtrInt"/>
<link id="NativeInt"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PComp">
<short>Pointer to <var>Complex</var> type</short>
<descr>
<var>PComp</var> is a pointer to a complex type.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__status">
<short>Internal status field of critical section. Do not use</short>
</element>

<!-- variable Visibility: default -->
<element name="TRTLCriticalSection.__spinlock">
<short>Internal spinlock of critical section. Do not use</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_objc_protocol_x">
<short>FPC compiler internal procedure index: protocol</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_objc_encode_x">
<short>FPC compiler internal procedure index: encode</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sar_x_y">
<short>FPC compiler internal procedure index: sar_x_y</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sar_x">
<short>FPC compiler internal procedure index: sar_x</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_bsf_x">
<short>FPC compiler internal procedure index: bsf_x</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_bsr_x">
<short>FPC compiler internal procedure index: bsr_x</short>
</element>

<!-- function Visibility: default -->
<element name="SarShortint">
<short>8-bit Shift Arithmetic Right</short>
<descr>
<var>SarShortint</var> performs an arithmetic right shift for
<var>Shift</var> positions on an 8-bit integer <var>AValue</var> and returns the result. 
<var>Shift</var> is optional, and is 1 by default. The difference with the
regular <var>Shr</var> shift operation is that the leftmost bit is preserved 
during the shift operation.
</descr>
<seealso>
<link id="SarSmallint"/>
<link id="SarLongint"/>
<link id="SarInt64"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SarSmallint">
<short>16-bit Shift Arithmetic Right</short>
<descr>
<var>SarSmallint</var> performs an arithmetic right shift for
<var>Shift</var> positions on an 16-bit integer <var>AValue</var> and returns the result. 
<var>Shift</var> is optional, and is 1 by default. The difference with the
regular <var>Shr</var> shift operation is that the leftmost bit is preserved 
during the shift operation.
</descr>
<seealso>
<link id="SarShortint"/>
<link id="SarLongint"/>
<link id="SarInt64"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SarLongint">
<short>32-bit Shift Arithmetic Right</short>
<descr>
<var>SarLongint</var> performs an arithmetic right shift for
<var>Shift</var> positions on a 32-bit integer <var>AValue</var> and returns the result. 
<var>Shift</var> is optional, and is 1 by default. The difference with the
regular <var>Shr</var> shift operation is that the leftmost bit is preserved 
during the shift operation.
</descr>
<seealso>
<link id="SarShortInt"/>
<link id="SarSmallInt"/>
<link id="SarInt64"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SarInt64">
<short>64-bit Shift Arithmetic Right</short>
<descr>
<var>SarInt64</var> performs an arithmetic right shift for
<var>Shift</var> positions on a 64-bit integer <var>AValue</var> and returns the result. 
<var>Shift</var> is optional, and is 1 by default. The difference with the
regular <var>Shr</var> shift operation is that the leftmost bit is preserved 
during the shift operation.
</descr>
<seealso>
<link id="SarShortInt"/>
<link id="SarSmallInt"/>
<link id="SarLongInt"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsfByte">
<short>Return the position of the rightmost set bit in an 8-bit value</short>
<descr>
<p>
<var>BsfByte</var> scans the byte <var>AValue</var>, starting at position 0 (rightmost position)
and returns the index of the first set bit. The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255  (unsigned equivalent of -1).
</p>
</descr>
<seealso>
<link id="BsrByte"/>
<link id="BsfWord"/>
<link id="BsfDWord"/>
<link id="BsfQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsrByte">
<short>Return the position of the leftmost set bit in an 8-bit value</short>
<descr>
<p>
<var>BsfByte</var> scans the byte <var>AValue</var>, starting at the leftmost position and
working towards position 0, and returns the index of the first set bit.
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255  (unsigned equivalent of -1).
</p>
</descr>  
<seealso> 
<link id="BsfByte"/>
<link id="BsrWord"/>
<link id="BsrDWord"/>
<link id="BsrQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsfWord">
<short>Return the position of the rightmost set bit in a 16-bit value</short>
<descr>
<p>
<var>BsfWord</var> scans the word <var>AValue</var>, starting at position 0 (rightmost position)
, and returns the index of the first set bit. The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>
<seealso>
<link id="BsfByte"/>
<link id="BsrWord"/>
<link id="BsfDWord"/>
<link id="BsfQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsrWord">
<short>Return the position of the leftmost set bit in a 16-bit value</short>
<descr>
<p>
<var>BsrWord</var> scans the word <var>AValue</var>, starting at the leftmost position and
working towards position 0, and returns the index of the first set bit.
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>  
<seealso> 
<link id="BsrByte"/>
<link id="BsfWord"/>
<link id="BsrDWord"/>
<link id="BsrQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsfDWord">
<short>Return the position of the rightmost set bit in a 32-bit value</short>
<descr>
<p>
<var>BsfDWord</var> scans the DWord <var>AValue</var>, starting at position 0 (rightmost position)
, and returns the index of the first set bit.
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>
<seealso>
<link id="BsfByte"/>
<link id="BsfWord"/>
<link id="BsrDWord"/>
<link id="BsfQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsrDWord">
<short>Return the position of the leftmost set bit in a 32-bit value</short>
<descr>
<p>
<var>BsrDWord</var> scans the DWord <var>AValue</var>, starting at the leftmost position and
working towards position 0, and returns the index of the first set bit.
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>  
<seealso> 
<link id="BsrByte"/>
<link id="BsrWord"/>
<link id="BsfDWord"/>
<link id="BsrQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsfQWord">
<short>Return the position of the rightmost set bit in a 64-bit value</short>
<descr>
<p>
<var>BsfQWord</var> scans the QWord <var>AValue</var>, starting at position 0 (rightmost position)
, and returns the index of the first set bit.
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>
<seealso>
<link id="BsfByte"/>
<link id="BsfWord"/>
<link id="BsfDWord"/>
<link id="BsrQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BsrQWord">
<short>Return the position of the leftmost set bit in a 64-bit value</short>
<descr>
<p>
<var>BsfQWord</var> scans the QWord <var>AValue</var>, starting at the leftmost position and
working towards position 0, and returns the index of the first set bit. 
The position is measured from the 0-th, rightmost bit.
</p>
<p>
When the input is 0, the result is 255 (unsigned equivalent of -1).
</p>
</descr>
<seealso>
<link id="BsfByte"/>
<link id="BsfWord"/>
<link id="BsfDWord"/>
<link id="BsrQWord"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="FPower10">
<short>Fast multiply with a power of 10</short>
<descr>
<var>FPower10</var> multplies <var>val</var> with 10 to the power
<var>Power</var>. It uses a fast algorithm to calculate the result.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.CodePointLengthProc">
<short>Return the length of a code point</short>
<descr>
<var>CodePointLengthProc</var> will be called to calculate the length of a
code point.
</descr>
<seealso>
<link id="TUnicodeStringManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SysFlushStdIO">
<short>Flush all standard IO file descriptors</short>
<descr>
<var>SysFlushStdIO</var> calls <link id="flush"/> on all standard file descriptors:
<link id="output"/>, <link id="stdout"/>, <link id="stderr"/>, <link id="erroutput"/>
</descr>
<seealso>
<link id="output"/>
<link id="stdout"/>
<link id="stderr"/> 
<link id="erroutput"/>
<link id="flush"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etVirtualMethodClass">
<short>Interface provided by a virtual class method</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etStaticMethodClass">
<short>Interface provided by a static class method</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tinterfaceentrytype.etFieldValueClass">
<short>Interface provided by a class field</short>
</element>

<!-- function Visibility: public -->
<element name="TObject.GetInterfaceWeak">
<short>Get a reference to an interface, not increasing the reference count</short>
<descr>
<var>GetInterfaceWeak</var> performs the same function as <link
id="TObject.GetInterface">Getinterface</link>, but unlike the latter, it
will not increase the reference count of the interface.
</descr>
<seealso>
<link id="TObject.GetInterface"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vtUnicodeString">
<short>Unicode string argument</short>
<descr>
<var>vtUnicodeString</var> denotes a unicode string argument in the array of
const. The <var>TVarRec.VUnicodeString</var> field will contain the actual
value.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VUnicodeString">
<short>Unicode string value</short>
</element>

<!-- constant Visibility: default -->
<element name="IObjectInstance">
<short>GUID for the IObject interface</short>
<descr>
<var>IObjectInstance</var> is an internal GUID, which should not be used in
end-user code. It is used in the <var>as</var> operator.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="varustrarg">
<short>Unicode string argument value</short>
<descr>
<var>varustrarg</var>  denotes a unicode string argument in
<var>DispInvoke</var> call. It will be converted to varustring in a
variant.
</descr>
<seealso>
<link id="varustring"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="varustring">
<short>Unicode string value in Variant</short>
<descr>
<var>varustring</var> denotes a unicode string value in a variant. It is one
of the values found in the <var>VType</var> field of the variant record
<link id="tvardata"/>.
</descr>
<seealso>
<link id="tvardata"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="varuint64">
<short>Unsigned 64-bit value in a variant</short>
<descr>
<var>varuint64</var> denotes an unsigned 64-bit value in a variant. It is
one of the values found in the <var>VType</var> field of the variant record
<link id="tvardata"/>.
</descr>
<seealso>
<link id="tvardata"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_cmdline">
<short>Return the command-line as a null-terminated string</short>
<descr>
<var>get_cmdline</var> returns the complete command-line as a
null-terminated string. It is not recommended to use this function, since it
builds a complete value from the actual command-line arguments. Instead,
<link id="ParamCount"/> and <link id="ParamStr"/> should be used.
</descr>
<seealso>
<link id="ParamCount"/>
<link id="ParamStr"/> 
</seealso>
</element>

<!-- function Visibility: default -->
<element name="slice">
<short>Return part of an array</short>
<descr>
<var>Slice</var> returns the first <var>ACount</var> elements from the array
<var>A</var>. It returns an array with the same element type as
<var>A</var>, but this array is not assignment compatible to any other
array, and can therefor only be used in open array arguments to functions.
</descr>
<seealso>
<link id="Length"/>
<link id="SetLength"/>
</seealso>
<example file="refex/ex113"/>
</element>

<element name="UnicodeString">
<short>A string consisting of widechars.</short>
<descr>
<var>UnicodeString</var> is a string of WideChars. The main difference with
WideString is that unicodestring is reference counted, and WideString is not
reference counted on Windows.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="Int8">
<short>A signed 8-bits integer</short>
<seealso>
   <link id="ShortInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="Int16">
<short>A signed 16-bits integer</short>
<seealso>
   <link id="SmallInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="Int32">
<short>A signed 32-bits integer</short>
<seealso>
  <link id="Longint"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="IntPtr">
<short>A signed integer with the same size in bytes as pointer</short>
<seealso>
  <link id="PtrInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="UInt8">
<short>An unsigned 8-bits integer</short>
<seealso>
  Alias for <link id="Byte"/> type.
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="UInt16">
<short>An unsigned 16-bits integer</short>
<seealso>
  Alias for <link id="Word"/> type.
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="UInt32">
<short>An unsigned 32-bits integer</short>
<seealso>
   <link id="LongWord"/> 
   <link id="Cardinal"/> 
   <link id="DWord"/> 
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="LongWord">
<short>An unsigned 32-bits integer</short>
<descr> The base 32-bit unsigned type. See the reference
manual for more details</descr>
<seealso>
   <link id="Cardinal"/>  
   <link id="DWord"/> 
   <link id="UInt32"/> 
</seealso>
</element>


<!-- alias type Visibility: default -->
<element name="UIntPtr">
<short>An unsigned integer with the same size in bytes as pointer</short>
<descr>
  Alias for <link id="PtrUInt"/> type for compatibility with later Delphi
  versions.
</descr>
<seealso>
  <link id="PtrUInt"/> 
</seealso>
</element>

<!-- range type Visibility: default -->
<element name="WideChar">
<short>The base two byte character type</short>
<descr>
   This type is the base unit for all two byte character types,
   like <link id="UnicodeString"/>  and <link id="WideString"/> 
</descr>
<seealso>
  <link id="UnicodeChar"/> is an alias.
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PNativeInt">
<short>Pointer to <link id="#rtl.system.NativeInt">NativeInt</link> type</short>
<seealso>
<link id="NativeInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PNativeUInt">
<short>Pointer to <link id="#rtl.system.NativeUInt">NativeInt</link> type</short>
<seealso>
<link id="NativeUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pInt8">
<short>Pointer to <link id="#rtl.system.Int8">Int8</link> type</short>
<seealso>
<link id="Int8"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pInt16">
<short>Pointer to <link id="#rtl.system.Int16">Int16</link> type</short>
<seealso>
<link id="Int8"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pInt32">
<short>Pointer to <link id="#rtl.system.Int32">Int32</link> type</short>
<seealso>
<link id="Int32"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PIntPtr">
<short>Pointer to <link id="#rtl.system.IntPtr">IntPtr</link> type</short>
<seealso>
<link id="IntPtr"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pUInt8">
<short>Pointer to <link id="#rtl.system.Uint8">UInt8</link> type</short>
<seealso>
<link id="UInt8"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pUInt16">
<short>Pointer to <link id="#rtl.system.Uint16">UInt16</link> type</short>
<seealso>
<link id="UInt16"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="pUInt32">
<short>Pointer to <link id="#rtl.system.Uint32">UInt32</link> type</short>
<seealso>
<link id="UInt32"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PUintPtr">
<short>Pointer to <link id="#rtl.system.UintPtr">UIntPtr</link> type</short>
<seealso>
<link id="UIntPtr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CP_ACP">
<short>ANSI code page identifier</short>
<descr>
<var>CP_ACP</var> is the default Windows codepage identifier.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_OEMCP">
<short>OEM code page identifier</short>
<descr>
<var>CP_ACP</var> is the default Windows OEM (MS-DOS) codepage identifier.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_UTF16">
<short>UTF-16 code page identifier</short>
<descr>
<var>CP_UTF16</var> is the default Windows unicode codepage identifier (little endian).
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_UTF16BE">
<short>Big-endian UTF-16 code page identifier</short>
<descr>
<var>CP_UTF16BE</var> is the Windows unicode codepage identifier (big endian).
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_UTF7">
<short>UTF-7 code page identifier</short>
<descr>
<var>CP_UTF7</var> is the Windows unicode 7-Bit encoding codepage identifier.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_UTF8">
<short>UTF-8 code page identifier</short>
<descr>
<var>CP_UTF8</var> is the Windows unicode 8-Bit encoding codepage identifier.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_ASCII">
<short>US-ASCII code page identifier</short>
<descr>
<var>CP_ASCII</var> is the Windows ASCII encoding codepage identifier.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="CP_NONE">
<short>No known code page</short>
<descr>
<var>CP_NONE</var> is used when no code page information is available.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="FarPointer">
<short>Far pointer (8/16 bit targets)</short>
<descr>
<var>FarPointer</var> is used in 8/16-bit targets to indicate far pointers
(over segments). On all other platforms this equals <var>Pointer</var>.
</descr>
<seealso>
<link id="CodePointer"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="CodePointer">
<short>Code pointer (8/16 bit targets)</short>
<descr>
<var>CodePointer</var> is used in 8/16-bit targets to indicate  pointers to
code segments. On all other platforms this equals <var>Pointer</var>.
</descr>
<seealso>
</seealso>
<link id="FarPointer"/>
</element>

<!-- alias type Visibility: default -->
<element name="CodePtrInt">
<short>Signed Integer with same size as <var>CodePointer</var></short>
<descr>
<var>CodePtrInt</var> is a signed integer with the same size as <link id="CodePointer"/>
</descr>
<seealso>
<link id="CodePointer"/>
<link id="CodePtrUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="CodePtrUInt">
<short>Unsigned Integer with same size as <var>CodePointer</var></short>
<descr>
<var>CodePtrUInt</var> is an unsigned integer with the same size as <link id="CodePointer"/>
</descr>
<seealso>
<link id="CodePointer"/>
<link id="CodePtrInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PPPAnsiChar">
<short>Pointer to <var>PPAnsichar</var></short>
<descr>
<var>PPPAnsiChar</var> is a typed pointer to <link id="PPAnsichar"/>.
</descr>
<seealso>
<link id="PPAnsichar"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="RawByteString">
<short>Single-byte character string without specified codepage</short>
<descr>
<p>
<var>RawByteString</var> is a single-byte character string which does not
have any codepage associated with it.
</p>
<p> This means that assigning a single-byte character string to
this kind of string will not change the codepage of the string. 
</p>
<p>
Inversely, when assigning a <var>RawByteString</var> to a single-byte
string, the codepage of the destination is simply set to the codepage 
of the rawbytestring: no codepage conversion happens, the reference count is
simply increased.
</p>
</descr>
<seealso>
<link id="TSystemCodePage"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCodePointer">
<short>Pointer to <var>CodePointer</var></short>
<descr>
<var>PCodePointer</var> is a typed pointer to <link id="CodePointer"/>.
</descr>
<seealso>
<link id="PPCodePointer"/>
<link id="CodePointer"/>
<link id="PPointer"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPCodePointer">
<short>Pointer to <var>PCodePointer</var></short>
<descr>
<var>PPCodePointer</var> is a typed pointer to <link id="PCodePointer"/>.
</descr>
<seealso>
<link id="CodePointer"/>
<link id="PPointer"/>   
<link id="PCodePointer"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TSystemCodePage">
<short>System code page</short>
<descr>
<var>TSystemCodePage</var> is a type used to indicate code pages. It should
be treated as an opaque type.
</descr>
<seealso>
<link id="RawByteString"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TFileTextRecChar">
<short>Character type for the filename part in file records</short>
<descr>
<var>TFileTextRecChar</var> is the type of character used in <link
id="TextRec"/> or <link id="FileRec"/> file types. It is an alias type,
depending on platform and RTL compilation flags. No assumptions should be
made on the actual character type.
</descr>
<seealso>
<link id="TextRec"/> 
<link id="FileRec"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PFileTextRecChar">
<short>Pointer to <var>TFileTextRecChar</var></short>
<descr>
<var>PFileTextRecChar</var> is a typed pointer to <link id="TFileTextRecChar"/>.
</descr>
<seealso>
<link id="TFileTextRecChar"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="filerecnamelength">
<short>Maximum filename size</short>
<descr>
<var>filerecnamelength</var> is the maximum filename size for untyped files.
</descr>
<seealso>
<link id="TextRec"/>
<link id="FileRec"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="FileRec">
<short>Untyped file type</short>
<descr>
<var>FileRec</var> is the underlying type used in untyped files. It should
be treated as opaque and never manipulated directly.
</descr>
<seealso>
<link id="TextRec"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Close"/>
<link id="Rewrite"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="FileRec.Handle">
<short>OS file handle</short>
</element>

<!-- variable Visibility: default -->
<element name="FileRec.Mode">
<short>File open mode</short>
</element>

<!-- variable Visibility: default -->
<element name="FileRec.RecSize">
<short>Record size</short>
</element>

<!-- variable Visibility: default -->
<element name="FileRec._private">
<short>Private field</short>
</element>

<!-- variable Visibility: default -->
<element name="FileRec.UserData">
<short>User data for use in custom file types</short>
</element>

<!-- variable Visibility: default -->
<element name="FileRec.name">
<short>File name</short>
</element>

<!-- constant Visibility: default -->
<element name="TextRecNameLength">
<short>maximum filename size for text files.</short>
<descr>
<var>TextRecNameLength</var> is the maximum filename size for text files.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TextRecBufSize">
<short>Default buffer size for text files</short>
<descr>
<var>TextRecBufSize</var> is the default buffer size for text files. 
The actual buffer can be set to another size using <link id="SetTextBuf"/>.
</descr>
<seealso>
<link id="SetTextBuf"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TLineEndStr">
<short>Line ending string type</short>
<descr>
<var>TLineEndStr</var> is an alias for the actual line ending string type,
used in <link id="TextRec"/>. It should be treated as opaque.
</descr>
<link id="EOln"/>
<link id="TextRec"/>
</element>

<!-- array type Visibility: default -->
<element name="TextBuf">
<short>Text buffer</short>
<descr>
<var>TextBuf</var> is a type for the default buffer used in <link id="TextRec"/>.
</descr>
<seealso>
<link id="TextRec"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TTextBuf">
<short>Alias for <var>TextBuf</var></short>
<descr>
<var>TTextBuf</var> is an alias for <var>TextBuf</var>
</descr>
<seealso>
<link id="TextBuf"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TextRec">
<short>Text file type</short>
<descr>
<var>TextRec</var> is the underlying type used in text files. It should
be treated as opaque and never manipulated directly.
</descr>
<seealso>
<link id="FileRec"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Close"/>
<link id="Rewrite"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.Handle">
<short>Low-level OS file handle</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.Mode">
<short>Open mode</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.bufsize">
<short>Actual buffer size</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec._private">
<short>Private data</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.bufpos">
<short>Current buffer position</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.bufend">
<short>Current buffer end position</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.bufptr">
<short>Pointer to current buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.openfunc">
<short>File open function</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.inoutfunc">
<short>File I/O function</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.flushfunc">
<short>I/O flush function</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.closefunc">
<short>File close function</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.UserData">
<short>User data</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.name">
<short>File name</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.LineEnd">
<short>Line ending to use</short>
</element>

<!-- variable Visibility: default -->
<element name="TextRec.buffer">
<short>Default buffer</short>
</element>

<element name="TextRec.CodePage">
<short>Codepage used when writing to file</short>
</element>

<!-- variable Visibility: default -->
<element name="NoErrMsg">
<short>Unused, for Delphi compatibility</short>
</element>

<!-- variable Visibility: default -->
<element name="FirstDotAtFileNameStartIsExtension">
<short>Where does the extension start.</short>
<descr>
<var>FirstDotAtFileNameStartIsExtension</var> determines what happens if a
filename starts with a dot (.) character. If <var>True</var>, then the
whole file name will be treated as extension. If <var>False</var>, then the
extension is empty.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="DefaultSystemCodePage">
<short>Current system codepage.</short>
<descr>
<p>
<var>DefaultSystemCodePage</var> is used to determine how <var>CP_ACP</var> is
interpreted; it is what the program considers to be the current system
codepage.
</p>
<p>
It is initialized to the default system codepage.
</p>
<ul>
<li>On windows, this is the result of the  <var>GetACP</var> operating call, which returns the Windows ANSI code
page.</li>
<li>On iOS, this is UTF-8</li>
<li>on other Unixes this will be based on the currently 
set <var>LANG</var> or <var>LC_CTYPE</var> environment  variables. 
Normally this is UTF-8, but that is not guaranteed to be the case.</li>
<li>
For all other platforms it is set to CP_ACP, as these platforms currently do not support
multiple code pages, and are hardcoded to use their OS-specific code page in all cases.
</li>
</ul>
<p>
The <var>DefaultSystemCodePage</var> value may be set using <link id="SetMultiByteConversionCodePage"/>.
That means that it is not a good idea to use its value to determine the real OS "default system code
page".
</p>
</descr>
<seealso>
<link id="DefaultUnicodeCodePage"/>
<link id="DefaultFileSystemCodePage"/>
<link id="DefaultRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DefaultUnicodeCodePage">
<short>Code page for new unicode strings</short>
<descr>
<var>DefaultUnicodeCodePage</var> is the unicode code page for a new unicode string. 
On most platforms, this is <link id="CP_UTF16"/>.
</descr>
<seealso>
<link id="CP_UTF16"/>
<link id="DefaultSystemCodePage"/>
<link id="DefaultFileSystemCodePage"/>
<link id="DefaultRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DefaultFileSystemCodePage">
<short>Codepage to use for filenames</short>
<descr>
<p>
<var>DefaultFileSystemCodePage</var> determines the code page to which file/path names are translated
before they are passed to OS API calls, if the RTL uses a single byte OS API for this purpose on the 
current platform. 
</p>
<p>This code page is also used for intermediate operations on file paths inside the RTL before
making OS API calls.</p>
<p>
This variable does not exist in Delphi, and has  been introduced in FPC to make it possible to change 
the value of <var>DefaultSystemCodePage</var> without breaking RTL interfaces with the OS file system API calls.
</p>
<p>
The initiali value of this variable depends on the platform:
</p>
<ul>
<li>Windows: UTF-8, because the RTL uses UTF-16 OS API calls (so no data is lost in intermediate
operations).</li>
<li>OS X and iOS: UTF-8 (as defined by Apple)</li>
<li>Unix (excluding OS X and iOS): equals <link id="DefaultSystemCodePage"/>.
This is because the encoding of file names is undefined on Unix platforms:
it is an untyped array of bytes that can be interpreted in any way;
Specifically, it is  not guaranteed to be valid UTF-8.</li>
<li> Other platforms: same as <link id="DefaultSystemCodePage"/>.</li>
</ul>
<p>
The value of this variable may be changed using the
<link id="SetMultiByteFileSystemCodePage"/> procedure.
</p>
<remark>
The Unix/OS X/iOS settings only apply in case the cwstring widestring manager is installed,
otherwise <var>DefaultFileSystemCodePage</var> will have the same value as DefaultSystemCodePage after
program startup. 
</remark>
</descr>
<seealso>
<link id="DefaultSystemCodePage"/>
<link id="DefaultRTLFileSystemCodePage"/>
<link id="SetMultiByteFileSystemCodePage"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DefaultRTLFileSystemCodePage">
<short>Code page in which to return system-returned filenames</short>
<descr>
<p>
<var>DefaultRTLFileSystemCodePage</var> determines the code page to which 
file/path names are translated before they are returned from <link
id="RawByteString"/> file/path RTL routines.
</p>
<p>Examples include the file/path names returned by the
<var>RawbyteString</var> versions of <link id="SysUtils.FindFirst"/> and
<link id="GetDir"/>. 
</p>
<p>
The main reason for its existence is to enable the RTL to provide backward 
compatibility with earlier versions of FPC, as these always returned strings 
encoded in whatever the OS' single byte API used (normally <link id="DefaultSystemCodePage"/>).
</p>
<p>The initial value of this variable depends on the platform:</p>
<ul>
<li>Windows: <var>DefaultSystemCodePage</var>, for backward
compatibility.</li>
<li>OS X and iOS: UTF-8, for backward compatibility. It was already
always UTF-8 in the past, since that's what the OS file APIs returned, and
the data was never converted.
</li>
<li>Other Unixes: <var>DefaultSystemCodePage</var>, for the same reason as 
<link id="DefaultFileSystemCodePage"/>. Setting this to a different value 
than <var>DefaultFileSystemCodePage</var> is a bad idea on these platforms, 
since any code page conversion can corrupt these strings as their initial 
encoding is unknown.
</li>
<li>Other platforms: same as <var>DefaultSystemCodePage</var>.</li>
</ul>
<p>The value of this variable can be set using the
<link id="SetMultiByteRTLFileSystemCodePage"/> call.</p>
</descr>
<seealso>
<link id="DefaultSystemCodePage"/>
<link id="DefaultFileSystemCodePage"/>
<link id="SetMultiByteRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="UTF8CompareLocale">
<short>Unused, for Delphi compatibility only</short>
<descr>
<var>UTF8CompareLocale</var> is currently present for Delphi compatibility only, it is not used in FPC code.
</descr>
<seealso>
<link id="DefaultSystemCodePage"/>
<link id="DefaultFileSystemCodePage"/>
<link id="DefaultRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_default_x" skip="1">
<short>FPC compiler internal procedure index: default</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_box_x" skip="1">
<short>FPC compiler internal procedure index: box</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_unbox_x_y" skip="1">
<short>FPC compiler internal procedure index: unbox</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_popcnt_x" skip="1">
<short>FPC compiler internal procedure index: popcnt</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_aligned_x" skip="1">
<short>FPC compiler internal procedure index: aligned</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_setstring_x_y_z" skip="1">
<short>FPC compiler internal procedure index: setstring</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_fma_single" skip="1">
<short>FPC compiler internal procedure index: fma (single)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_fma_double" skip="1">
<short>FPC compiler internal procedure index: fma (double)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_fma_extended" skip="1">
<short>FPC compiler internal procedure index: fma (extended)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_fma_float128" skip="1">
<short>FPC compiler internal procedure index: fma  (float 128)</short>
</element>

<!-- function Visibility: default -->
<element name="fpc_SarInt64">
<short>SAR (int64)</short>
<descr>
<var>fpc_SarInt64</var> is a FPC helper function which should not be used directly.
</descr>
</element>

<!-- function Visibility: default -->
<element name="PopCnt">
<short>Count number of set bits</short>
<descr>
<var>PopCnt</var> (population count) counts the number of set bits in <var>AValue</var>.
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPURoundingMode">
<short>How to round floating point values</short>
<descr>
<var>TFPURoundingMode</var> enumerates the possible values for software floating
point math rounding. It has been moved here from the math unit.
</descr>
<seealso>
<link id="TFPUPrecisionMode"/>
<link id="softfloat_rounding_mode"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmNearest">
<short>Round to nearest integer</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmDown">
<short>Round to biggest integer smaller than value.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmUp">
<short>Round to smallest integer larger than value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPURoundingMode.rmTruncate">
<short>Cut off fractional part </short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPUPrecisionMode">
<short>Type describing the default precision for Floating Point math.</short>
<descr>
<var>TFPUPrecisionMode</var>  describes the possible default precisions for the
software Floating Point math routines.  It has been moved here from the math
unit.
</descr>
<seealso>
<link id="TFPURoundingMode"/>
</seealso>
</element>
 	  	  	  	  	
<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmSingle">
<short>Single-type precision</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmReserved">
<short>?</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmDouble">
<short>Double-type precision</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUPrecisionMode.pmExtended">
<short>Extended-type precision</short>
</element>

<element name="TFPUException">
<short>Type describing Floating Point processor exceptions.</short>
<descr>
<var>TFPUException</var> describes what floating point errors raise
exceptions. It has been moved here from the <var>Math</var> unit.
</descr>
<seealso>
<link id="TFPUExceptionMask"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exInvalidOp">
<short>Invalid operation error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exDenormalized">
<short></short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exZeroDivide">
<short>Division by zero error.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exOverflow">
<short>Float overflow error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exUnderflow">
<short>Float underflow error</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPUException.exPrecision">
<short>Precision error</short>
</element>


<!-- set type Visibility: default -->
<element name="TFPUExceptionMask">
<short>Set of <var>TFPUException</var></short>
<descr>
<var>TFPUExceptionMask</var> is a set of <var>TFPUException</var> constants
</descr>
<seealso>
<link id="softfloat_exception_mask"/>
<link id="softfloat_exception_flags"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFloatSpecial">
<short>Special floating point values</short>
<descr>
<var>TFloatSpecial</var> enumerates a series of floating point value properties.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsZero">
<short>Zero</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsNZero">
<short>Negative zero</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsDenormal">
<short>Denormal value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsNDenormal">
<short>Negative enormal value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsPositive">
<short>Positive value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsNegative">
<short>Negative value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsInf">
<short>Infinity</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsNInf">
<short>Negative infinity</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsNaN">
<short>Not a number</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFloatSpecial.fsInvalidOp">
<short>Invalid operation</short>
</element>

<!-- record type Visibility: default -->
<element name="TExtended80Rec">
<short>Extended value record</short>
<descr>
<var>TExtended80Rec</var> models the memory layout of an extended value when using software floating point math.
</descr>
<seealso>
<link id="TDoubleRec"/>
<link id="TSingleRec"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TExtended80Rec.Mantissa">
<short>Mantissa of the floating point value</short>
<descr>
<var>Mantissa</var> returns the Mantissa part (bit pattern of the significand, skipping the hidden bit) of the floating point value.
</descr>
<seealso>
<link id="TExtended80Rec.Fraction"/>
<link id="TExtended80Rec.Exponent"/>
<link id="TExtended80Rec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TExtended80Rec.Fraction">
<short>Fraction of the floating point value</short>
<descr>
<var>Fraction</var> returns the fraction (value after decimal) of the floating point value.
</descr>
<seealso>
<link id="TExtended80Rec.Mantissa"/>
<link id="TExtended80Rec.Exponent"/>
<link id="TExtended80Rec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TExtended80Rec.Exponent">
<short>Exponent of the floating point value</short>
<descr>
<var>Exponent</var> returns the exponent (the <var>X</var> in the <var>m*2^X</var> representation) of the floating point value.
</descr>
<seealso>
<link id="TExtended80Rec.Fraction"/>
<link id="TExtended80Rec.Mantissa"/>
<link id="TExtended80Rec.SpecialType"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TExtended80Rec.Sign">
<short>Sign of the floating point value</short>
</element>

<!-- property Visibility: public -->
<element name="TExtended80Rec.Exp">
<short>Exponent representation</short>
<descr>
<var>Exponent</var> returns the internal bit representation of the exponent  of the floating point value.
</descr>
<seealso>
<link id="TExtended80Rec.Sign"/>
<link id="TExtended80Rec.Exponent"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TExtended80Rec.SpecialType">
<short>Is the floating point value special ?</short>
<descr>
<var>SpecialType</var> returns special characteristics of the floating point value, if any.
See <link id="TFLoatSpecial"/> for an explanation of the various special values.
</descr>
<seealso>
<link id="TExtended80Rec.Fraction"/>
<link id="TExtended80Rec.Mantissa"/>
<link id="TExtended80Rec.Exponent"/>
<link id="TFLoatSpecial"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtended80Rec.Bytes">
<short>Value as bytes</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtended80Rec.Words">
<short>Value as words</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtended80Rec._Exp">
<short>Encoded exponent of value</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtended80Rec.Frac">
<short>Encoded fraction of value</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtended80Rec.Value">
<short>Value as <var>Extended</var></short>
</element>

<!-- record type Visibility: default -->
<element name="TDoubleRec">
<short>Double value memory layout</short>
<descr>
<var>TDoubleRec</var> models the memory layout of a double value when using software floating point math.
</descr>
<seealso>
<link id="TExtended80Rec"/>
<link id="TDoubleRec"/>
<link id="TSingleRec"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDoubleRec">
<short>Extended value record</short>
<descr>
<var>TDoubleRec</var> models the memory layout of a double value when using software floating point math.
</descr>
<seealso>
<link id="TDoubleRec"/>
<link id="TSingleRec"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TDoubleRec.Mantissa">
<short>Mantissa of the floating point value</short>
<descr>
<var>Mantissa</var> returns the Mantissa part (significand bitpattern without hidden bit) of the floating point value.
</descr>
<seealso>
<link id="TDoubleRec.Fraction"/>
<link id="TDoubleRec.Exponent"/>
<link id="TDoubleRec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TDoubleRec.Fraction">
<short>Fraction of the floating point value</short>
<descr>
<var>Fraction</var> returns the fraction (value after decimal) of the floating point value.
</descr>
<seealso>
<link id="TDoubleRec.Mantissa"/>
<link id="TDoubleRec.Exponent"/>
<link id="TDoubleRec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TDoubleRec.Exponent">
<short>Exponent of the floating point value</short>
<descr>
<var>Exponent</var> returns the exponent (<var>X</var> in <var>m*2^X</var> representation) of the floating point value.
</descr>
<seealso>
<link id="TDoubleRec.Fraction"/>
<link id="TDoubleRec.Mantissa"/>
<link id="TDoubleRec.SpecialType"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TDoubleRec.Sign">
<short>Sign of the floating point value</short>
</element>

<!-- property Visibility: public -->
<element name="TDoubleRec.Exp">
<short>Exponent bitpattern representation</short>
<descr>
<var>Exp</var> returns the internal bit representation of the exponent of the floating point value.
</descr>
<seealso>
<link id="TDoubleRec.Sign"/>
<link id="TDoubleRec.Exponent"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TDoubleRec.SpecialType">
<short>Is the floating point value special ?</short>
<descr>
<var>SpecialType</var> returns special characteristics of the floating point
value, if any.
See <link id="TFLoatSpecial"/> for an explanation of the various special values.
</descr>
<seealso>
<link id="TDoubleRec.Fraction"/>
<link id="TDoubleRec.Mantissa"/>
<link id="TDoubleRec.Exponent"/>
<link id="TFLoatSpecial"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDoubleRec.Bytes">
<short>Value as bytes</short>
</element>

<!-- variable Visibility: default -->
<element name="TDoubleRec.Words">
<short>Value as words</short>
</element>

<element name="TDoubleRec.Value">
<short>Value as <var>Double</var></short>
</element>

<!-- variable Visibility: default -->
<element name="TDoubleRec.Data">
<short>Value as <var>QWord</var></short>
</element>

<!-- record type Visibility: default -->
<element name="TSingleRec">
<short>Extended value record</short>
<descr>
<var>TsingleRec</var> models the memory layout of a double value when using software floating point math.
</descr>
<seealso>
<link id="TsingleRec"/>
<link id="TSingleRec"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TsingleRec.Mantissa">
<short>Mantissa of the floating point value</short>
<descr>
<var>Mantissa</var> returns the Mantissa part (significand bitpattern without hidden bit) of the floating point value.
</descr>
<seealso>
<link id="TsingleRec.Fraction"/>
<link id="TsingleRec.Exponent"/>
<link id="TsingleRec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TsingleRec.Fraction">
<short>Fraction of the floating point value</short>
<descr>
<var>Fraction</var> returns the fraction (after decimal) of the floating point value.
</descr>
<seealso>
<link id="TsingleRec.Mantissa"/>
<link id="TsingleRec.Exponent"/>
<link id="TsingleRec.SpecialType"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TsingleRec.Exponent">
<short>Exponent of the floating point value</short>
<descr>
<var>Exponent</var> returns the exponent (<var>X</var> in <var>m*2^X</var> representation) of the floating point value.
</descr>
<seealso>
<link id="TsingleRec.Fraction"/>
<link id="TsingleRec.Mantissa"/>
<link id="TsingleRec.SpecialType"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TsingleRec.Sign">
<short>Sign of the floating point value</short>
</element>

<!-- property Visibility: public -->
<element name="TsingleRec.Exp">
<short>Exponent bitpattern representation</short>
<descr>
<var>Exp</var> returns the internal bit representation of the exponent of the floating point value.
</descr>
<seealso>
<link id="TsingleRec.Sign"/>
<link id="TsingleRec.Exponent"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TsingleRec.SpecialType">
<short>Is the floating point value special ?</short>
<descr>
<var>SpecialType</var> returns special characteristics of the floating point value, if any.
See <link id="TFLoatSpecial"/> for an explanation of the various special values.
</descr>
<seealso>
<link id="TsingleRec.Fraction"/>
<link id="TsingleRec.Mantissa"/>
<link id="TsingleRec.Exponent"/>
<link id="TFLoatSpecial"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TsingleRec.Bytes">
<short>Value as bytes</short>
</element>

<!-- variable Visibility: default -->
<element name="TsingleRec.Words">
<short>Value as words</short>
</element>

<element name="TsingleRec.Value">
<short>Value as <var>single</var></short>
</element>

<!-- variable Visibility: default -->
<element name="TsingleRec.Data">
<short>Value as <var>QWord</var></short>
</element>



<!-- function Visibility: default -->
<element name="FMASingle">
<short>Internal function, do not use</short>
</element>

<!-- function Visibility: default -->
<element name="FMADouble">
<short>Internal function, do not use</short>
</element>

<!-- function Visibility: default -->
<element name="FMAExtended">
<short>Internal function, do not use</short>
</element>

<!-- function Visibility: default -->
<element name="StringCodePage">
<short>Get the code page of a string</short>
<descr>
<var>StringCodePage</var> returns the code page of a string (<var>S</var>), regardless of the string type.
It accesses the internal structures of the string to retrieve this
information. For an empty string, <link id="DefaultSystemCodePage"/> is
returned.
</descr>
<seealso>
<link id="DefaultSystemCodePage"/>
<link id="StringElementSize"/>
<link id="StringRefCount"/>
<link id="SetCodePage"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="StringElementSize">
<short>Get the character size of a string.</short>
<descr>
<var>StringCodePage</var> returns the character size of a string (<var>S</var>), regardless of the string type.
It accesses the internal structures of the string to retrieve this information. 
For an empty string, <var>SizeOf(AnsiChar)</var> (normally 1) is returned.
</descr>
<seealso>
<link id="StringCodePage"/>
<link id="StringRefCount"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="StringRefCount">
<short>Get the reference count of a string</short>
<descr>
<var>StringRefCount</var> returns the reference count of a string (<var>S</var>), regardless of the string type.
It accesses the internal structures of the string to retrieve this information.
For an empty string, 0 is returned.
</descr>
<seealso>
<link id="StringCodePage"/>
<link id="StringElementSize"/>                                    
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetCodePage">
<short>Set the codepage of a string</short>
<descr>
<var>SetCodePage</var> sets the codepage of a string <var>S</var> to
<var>CodePage</var>. 
If <var>Convert</var> is <var>True</var> then the string will be transcoded to the new codepage.
The resulting string will have reference count 1.
</descr>
<seealso>
<link id="StringCodePage"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetMultiByteConversionCodePage">
<short>Set codepage for conversions from multi-byte strings to single-byte strings</short>
<descr>
<p>
<var>SetMultiByteConversionCodePage</var> sets <link id="DefaultSystemCodePage"/> to <var>CodePage</var>.
The effect of this change is that the default codepage used to translate multi-byte (UTF-16)  strings to single-byte codepage-aware strings
changes, and code page conversions will be done to the new codepage.
</p>
<p>
Do not set <var>DefaultSystemCodePage</var> directly, as additional actions may need to be done when changing the code page.
</p>
</descr>
<seealso>
<link id="DefaultSystemCodePage"/>
<link id="SetMultiByteFileSystemCodePage"/>
<link id="SetMultiByteRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetMultiByteFileSystemCodePage">
<short>Set codepage used when passing strings to OS single-byte filesystem APIs</short>
<descr>
<p>
<var>SetMultiByteFileSystemCodePage</var> sets the codepage used in single-byte OS filesystem APIs to <var>CodePage</var>.
The effect of this change is that the default codepage used to translate multi-byte (UTF-16)  strings 
to single-byte codepage-aware strings used in Filesystem APIs changes, and
strings passed to the codepage-aware filesystem APIs will be passed using the new codepage.
</p>
<p>
This constant is not used if the filesystem API of the OS is multi-byte (such as on Windows).
</p>
<p> 
Do not set <var>DefaultFileSystemCodePage</var> directly, as additional actions
may need to be done when changing the code page.
</p>    
</descr>
<seealso>
<link id="DefaultFileSystemCodePage"/>
<link id="SetMultiByteConversionCodePage"/>
<link id="SetMultiByteRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetMultiByteRTLFileSystemCodePage">
<short>Set codepage used when interpreting strings from OS single-byte filesystem APIs</short>
<descr>
<p>
<var>SetMultiByteRTLFileSystemCodePage</var> sets the codepage used to interprete
strings returned by single-byte OS filesystem APIs to <var>CodePage</var>.
</p>
<p>
The effect of this change is that the default codepage used to translate single byte strings
obtained from the OS to single-byte codepage-aware strings or multi-byte strings changes, and
strings obtained from  the codepage-aware filesystem APIs will be interpreted using the new codepage.
</p>
<p>
his constant is not used if the filesystem API of the OS is multi-byte (such
as on Windows).
</p>
<p> 
Do not set <var>DefaultRTLFileSystemCodePage</var> directly, as additional actions
may need to be done when changing the code page.
</p>    
</descr>
<seealso>
<link id="SetMultiByteFileSystemCodePage"/>
<link id="SetMultiByteConversionCodePage"/>
<link id="SetMultiByteRTLFileSystemCodePage"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TStandardCodePageEnum">
<short>Description of standard used codepages</short>
<descr>
<var>TStandardCodePageEnum</var> describes several types of standard used codepages, which can 
be queried by the unicode string manager <link id="TUnicodeStringManager"/>.
</descr>
<seealso>
<link id="TUnicodeStringManager"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStandardCodePageEnum.scpAnsi">
<short>Ansi codepage (CP_ACP)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStandardCodePageEnum.scpConsoleInput">
<short>Console input codepage</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStandardCodePageEnum.scpConsoleOutput">
<short>Console output codepage</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStandardCodePageEnum.scpFileSystemSingleByte">
<short>File system single byte codepage.</short>
</element>

<!-- variable Visibility: default -->
<element name="TUnicodeStringManager.GetStandardCodePageProc">
<short>Callback to query for standard used codepages</short>
</element>

<!-- function Visibility: default -->
<element name="ToSingleByteFileSystemEncodedFileName">
<short>Convert string to encoding for use in single-byte filesystem API</short>
<descr>
<p>
<var>ToSingleByteFileSystemEncodedFileName</var> converts the argument
(<var>Str</var> or <var>Arr</var>) to a single-byte string, encoded using
the codepage used by the single-byte filesystem API.
</p>
<p>
This routine is simply an auxiliary routine, which converts the argument to
a single-byte string using <link id="DefaultFileSystemCodePage"/> as a
codepage.
</p>
</descr>
<seealso>
<link id="DefaultFileSystemCodePage"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetTextCodePage">
<short>Get the codepage used in a text file.</short>
<descr>
<var>GetTextCodePage</var> returns the codepage that the text file <var>T</var> uses. 
All strings written to the file will be converted to the indicated codepage.
By default, the codepage is set to <var>CP_ACP</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TextRec"/>
<link id="SetTextCodePage"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetTextCodePage">
<short>Set the codepage used in a text file.</short>
<descr>
<var>GetTextCodePage</var> sets the codepage that the text file <var>T</var> uses.
All strings written to the file will be converted to the indicated codepage.
By default, the codepage is set to <var>CP_ACP</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TextRec"/>
<link id="GetTextCodePage"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Get_pc_addr">
<short>Get Program Counter address</short>
<descr>
<var>Get_pc_addr</var> returns the program counter address (current execution address).
</descr>
<seealso>
<link id="CaptureBacktrace"/>
<link id="get_caller_stackinfo"/>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CaptureBacktrace">
<short>Return stack trace</short>
<descr>
<var>CaptureBacktrace</var> will fill the array pointed to by
<var>frames</var> with the addresses of a backtrace. It will skip
<var>skipframes</var> frames, and will write at most <var>count</var>
addresses. <var>Frames</var> must point to enough memory to hold the
stacktrace, which is <var>count*sizeof(codepointer)</var> bytes.
</descr>
<seealso>
<link id="Get_pc_addr"/>
<link id="get_caller_stackinfo"/>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="get_caller_stackinfo">
<short>Return caller stack infomation</short>
<descr>
<var>get_caller_stackinfo</var> returns caller address in
<var>addr</var> and frame base pointer in <var>framebp</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="CaptureBacktrace"/>
<link id="Get_pc_addr"/>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="EmptyMethod">
<short>Empty method alias</short>
<descr>
<var>Emptymethod</var> is meant for the compiler only. It should not be used directly.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ExceptObjProc">
<short>Callback used to convert OS exceptions to FPC exceptions </short>
<descr>
<var>ExceptObjProc</var> is used in SEH (Structured Exception Support) to convert OS exception information to FPC exceptions.
It is set e.g. by the sysutils unit. If it is not set, a run-time error results
when OS exceptions are intercepted.
</descr>
<seealso>
<link id="ExceptClsProc"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ExceptClsProc">
<short>Callback used to determine the exception class for an OS exception</short>
<descr>
<var>ExceptClsProc</var> is used in SEH (Structured Exception Support) to
convert OS exception information to FPC exception classes when filtering
exceptions.
It is set e.g. by the sysutils unit. If it is not set, the exception is not handled.
</descr>
<seealso>
<link id="ExceptObjProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="InitializeArray">
<short>Initialize managed-type elements in array</short>
<descr>
<p>
<var>InitializeArray</var> initializes managed types in the array pointed to
by <var>p</var>. For this, it uses the type information of the elements as
specified in <var>typeinfo</var>.
</p>
<p>
Under normal circumstances, this procedure should not be used, it is called
automatically by the compiler when an array-typed variable is declared and
the array contains elements with managed types.
</p>
</descr>
<seealso>
<link id="FinalizeArray"/>
<link id="CopyArray"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="FinalizeArray">
<short>Finalize managed-type elements in array</short>
<descr>
<p>
<var>FinalizeArray</var> dereferences and clears managed types in the array pointed to
by <var>p</var>. For this, it uses the type information of the elements as
specified in <var>typeinfo</var>.
</p>
<p>
Under normal circumstances, this procedure should not be used, it is called
automatically by the compiler when an array-typed variable containing
managed types goes out of scope.
</p>
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayDim"/>
<link id="DynArrayBounds"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="CopyArray">
<short>Copy managed-type elements in array</short>
<descr>
<p>
<var>CopyArray</var> copies <var>count</var> elements containing managed types from the array pointed to
by <var>source</var> to the array pointed to by <var>dest</var>. 
For this, it uses the type information of the elements as specified in <var>typeinfo</var>.
</p>
<p> 
Under normal circumstances, this procedure should not be used, it is called
automatically by the compiler when an array-typed variables are assigned to
each other.
</p>
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayDim"/>
<link id="DynArrayBounds"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DynArraySize">
<short>Return length of dynamic array</short>
<descr>
<var>DynArraySize</var> gets the number of elements in the array
(<var>a</var>) the result is equal to <link id="Length"/> for dynamic arrays.
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>  
<link id="CopyArray"/>
<link id="DynArrayClear"/>
<link id="DynArrayDim"/>
<link id="DynArrayBounds"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DynArrayClear">
<short>Clear dynamical array</short>
<descr>
<var>DynArrayClear</var> clears the array (<var>a</var>) using its
type info (<var>typeInfo</var>). It is equal to setting the length to zero.
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayDim"/>
<link id="DynArrayBounds"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DynArrayDim">
<short>Return the number of dimensions in a dynamic array</short>
<descr>
<var>DynArrayDim</var> returns the number of dimensions in a dynamic array,
using the type information (<var>typeInfo</var>) of the array.
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayBounds"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DynArrayBounds">
<short>Return the bounds of the dynamic array</short>
<descr>
<p>
<var>DynArrayBounds</var> returns the bounds of all the dimensions of the
dynamic array <var>a</var> with type information <var>typeInfo</var>.
</p>
<p>
The result is an array (zero-based) with the maximum valid index for each dimension in
the array: the lower bound is not present in the result, it is always zero.
</p>
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>  
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayDim"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsDynArrayRectangular">
<short>Check whether all dimensions have the same size</short>
<descr>
<var>IsDynArrayRectangular</var> returns <var>True</var> if all dimensions
of the dynamic array <var>a</var> with type information <var>typinfo</var>
have the same bounds. It returns <var>True</var> if the array is empty. 
</descr>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayBounds"/>
<link id="DynArrayDim"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DynArrayIndex">
<short>Return pointer to indicated element</short>
<descr>
<var>DynArrayIndex</var> returns a pointer to the element indicated by
<var>indices</var> in dynamic array <var>a</var> with type information <var>typinfo</var>. 
The length of <var>indices</var> must equal the number of dimensions of the array 
(as returned by  <link id="DynArrayDim"/>).
</descr>
<errors>
No bounds checking is performed, it is therefor possible to get an access
violation if one of the indexes is out of range.
</errors>
<seealso>
<link id="InitializeArray"/>
<link id="FinalizeArray"/>  
<link id="CopyArray"/>
<link id="DynArraySize"/>
<link id="DynArrayClear"/>
<link id="DynArrayBounds"/>
<link id="DynArrayDim"/>   
<link id="IsDynArrayRectangular"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="fpc_dynarray_rangecheck" skip="1">
<short>Auxiliary compiler routine</short>
<descr>
<var>fpc_dynarray_rangecheck</var> is an auxiliary routine for checking
whether an array index is in range for the array.
</descr>
</element>

<!-- function Visibility: default -->
<element name="GetCPUCount">
<short>Return the number of cores on the system</short>
<descr>
<var>GetCPUCount</var> returns the number of CPU cores on the system.
Whether these are physically separate CPUs or cores on a single CPU is
deliberately undefined. 
</descr>
<seealso>
<link id="CPUCount"/>
</seealso>
</element>

<!-- property Visibility: default -->
<element name="CPUCount">
<short>Number of cores on the system</short>
<descr>
<var>CPUCount</var> contains the number of CPU cores on the system.
Whether these are physically separate CPUs or cores on a single CPU is
deliberately undefined. It can be used as a measure for the maximum 
 number of threads that can run concurrently.
</descr>
<seealso>
<link id="GetCPUCount"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SemaphoreInit">
<short>Create a new semaphore</short>
<descr>
<p>
<var>SemaphoreInit</var> creates a new semaphore, which can be used in thread synchronization.
The semaphore can be used with <link id="SemaphoreWait"/> and <link
id="SemaphorePost"/>, and must be destroyed with <link
id="SemaphoreDestroy"/>.
</p>
<p>
The result is an untyped pointer (thread support is platform dependent).
</p>
<p>
The use of semaphores requires thread support (use <link id="#rtl.cthreads"/> unit on unices).
</p>
</descr>
<errors>
On error, <var>Pointer(-1)</var> is returned. 
If no thread support is compiled in, then calling this function will result in a run-time error 232.
</errors>
<seealso>
<link id="#rtl.cthreads"/>
<link id="SemaphoreWait"/>
<link id="SemaphorePost"/>
<link id="SemaphoreDestroy"/>.
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SemaphoreDestroy">
<short>Destroy a semaphore</short>
<descr>
<p>
<var>SemaphoreDestroy</var> destroys a semaphore, created with  <link id="SemaphoreInit"/>.
</p>
<p>
The use of semaphores requires thread support (use <link id="#rtl.cthreads"/> unit on unices).
</p>
</descr>
<errors>
If no thread support is compiled in, then calling this function will result in a run-time error 232.
</errors>
<seealso>
<link id="#rtl.cthreads"/>
<link id="SemaphoreWait"/>
<link id="SemaphorePost"/>
<link id="SemaphoreInit"/>.
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SemaphoreWait">
<short>Wait for semaphore to become available</short>
<descr>
<p>
<var>SemaphoreWait</var> waits (indefinitely) for the semaphore <var>FSem</var> to become available.
</p>
<p> 
The use of semaphores requires thread support (use <link id="#rtl.cthreads"/> unit on unices).
</p>
</descr>
<errors>
If no thread support is compiled in, then calling this function will result in a run-time error 232.
</errors>
<seealso>
<link id="#rtl.cthreads"/>
<link id="SemaphoreInit"/>
<link id="SemaphorePost"/>
<link id="SemaphoreDestroy"/>.
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SemaphorePost">
<short>Make semaphore available</short>
<descr>
<p>
<var>SemaphorePost</var> makes the semaphore <var>FSem</var> to available.
Any threads that were waiting for the semaphore <var>FSem</var> to become
available (using <link id="SemaphoreWait"/>, will continue to execute.
</p>
<p> 
The use of semaphores requires thread support (use <link
id="#rtl.cthreads"/> unit on unices).
</p>
</descr>
<errors>
If no thread support is compiled in, then calling this function will result
in a run-time error 232.
</errors>
<seealso>
<link id="#rtl.cthreads"/>
<link id="SemaphoreInit"/>
<link id="SemaphoreWait"/>
<link id="SemaphoreDestroy"/>.
</seealso>
</element>

<!-- range type Visibility: default -->
<element name="Char">
<short>Character type (1 byte)</short>
<descr>
<var>Char</var> is the basic ANSI character type, with a range of [#0..#255].
</descr>
<seealso>
</seealso>
</element>

<!-- range type Visibility: default -->
<element name="Int64">
<short>64-bit, signed integer</short>
<descr>
<var>Int64</var> is a 64-bit, signed integer type, with range [-9223372036854775808..9223372036854775807].
</descr>
<seealso>
<link id="QWord"/>
<link id="Longint"/>
<link id="Longword"/>
</seealso>
</element>

<!-- range type Visibility: default -->
<element name="QWord">
<short>64-bit unsigned integer</short>
<descr>
<var>QWord</var> is a 64-bit, unsigned integer type, with range [0..18446744073709551615].
</descr>
<seealso>
<link id="Int64"/>
<link id="Longint"/>
<link id="Longword"/>
</seealso>
</element>

<element name="Default">
<short>Return Default initialized value</short>
<descr>
<p>
<var>Default</var> is a compiler intrinsic: it returns for every type
<var>T</var> a default value. In essence, this is a block of memory that is zeroed
out. It can be used to correctly initialize any type, and more importantly,
a managed type. It also works using a generic type template.
</p>
<p>
This function cannot be used on any of the file types or complex types that
contain a file type.
</p>
</descr>
<seealso>
<link id="TypeInfo"/>
<link id="Initialize"/>
<link id="Finalize"/>
</seealso>
</element>

<element name="TypeInfo">
<short>Return pointer to type information for type</short>
<descr>
<var>TypeInfo</var> is a compiler intrinsic: it returns a pointer to the
generated type information (RTTI) for the type <var>T</var>. If no type
information was yet generated for the type, this statement will ensure that
type information is available, i.e. the result is always non-nil.
</descr>
<seealso>
<link id="Default"/>
<link id="TypeOf"/>
<link id="Initialize"/>
<link id="Finalize"/>
</seealso>
</element>

<element name="TypeOf">
<short>Return pointer to VMT of an object</short>
<descr>
<var>TypeOf</var> is a compiler intrinsic: it returns a pointer to the VMT of the object type <var>T</var>. 
</descr>
<seealso>
<link id="Default"/>
<link id="TypeInfo"/>
</seealso>
</element>

<element name="Fail">
<short>Fail a constructor</short>
<descr>
<var>Fail</var> can be used in a constructor for an object or class. It will
exit the constructor at once, and the memory allocated for the constructor is
freed. This mean that for objects allocated with <link id="New"/>, the resulting pointer is <var>Nil</var>
and for classes, the object instance will be <var>Nil</var>.
</descr>
<seealso>
<link id="TypeOf"/>
<link id="New"/>
<link id="Initialize"/>
<link id="Finalize"/>
</seealso>
<example file="refex/ex116.pp"/>
</element>

<element name="Initialize">
<short>Initialize memory block using RTTI</short>
<descr>   
<p>
<var>Initialize</var> is a compiler intrinsic: it initializes a memory area
<var>T</var> for any kind of managed variable. Initializing means zeroeing out
the memory area. In this sense it is close in functionality to <link id="Default"/>, 
but <var>Default</var> requires an already initialized variable.
It performs the opposite operation of <link id="finalize"/>, which should be
used to clean up the memory block when it is no longer needed.
</p>
<p>
The optional <var>ACount</var> parameter can be used to initialize an array.
It then specifies the number of elements in the array.
</p>
</descr>
<seealso>
<link id="finalize"/>
<link id="Default"/>
<link id="TypeInfo"/>
</seealso>
<example file="refex/ex117.pp"/>
<example file="refex/ex118.pp"/>
</element>

<element name="Finalize">
<short>Finalize (clean up) memory block using RTTI</short>
<descr>   
<p>
<var>Finalize</var> is a compiler intrinsic: it cleans up (finalizes) a memory area
<var>T</var> for any kind of managed variable. Finalizing means decreasing
reference counts where necessaru and generally zeroeing out the memory area. 
It performs the opposite operation of <link id="initialize"/>.
</p>
<p>
The optional <var>ACount</var> parameter can be used to initialize an array.
</p>
<p>
For examples, see <link id="initialize"/>.
</p>
</descr>
<seealso>
<link id="initialize"/>
<link id="Default"/>
<link id="TypeInfo"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUInt64">
<short>Pointer to <var>UInt64</var></short>
<descr>
<var>PUInt64</var> is a pointer to a <link id="UInt64"/>, an unsigned 64-bit
integer.
</descr>
<seealso>
<link id="UInt64"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PSizeUInt">
<short>Pointer to <var>SizeUint</var></short>
<descr>
<var>PSizeUInt64</var> is a pointer to a <link id="SizeUInt"/>, an unsigned
integer of architecture-dependent size.
</descr>
<seealso>
<link id="SizeUInt"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="WriteErrorsToStdErr">
<short>Write errors to StdErr</short>
<descr>
<var>WriteErrorsToStdErr</var> can be set to <var>True</var> to write error
messages (run-time errors, exceptions) to <var>StdErr</var> instead of to
standard output. This is the default behaviour. When set to
<var>False</var>, error message will be written to standar output.
</descr>
<seealso>
<link id="Halt"/>
<link id="RunError"/>
</seealso>
</element>

<!-- operator Visibility: default -->
<element name="assign(real48):extended">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TDoubleRec.Frac">
<short>Fractional part of double</short>
<descr>
<var>Frac</var> is the fractional part of the Double. This is the bit pattern
representing the fractional part including the preceding 1. (The mantissa is
that bit pattern without the preceding 1)
</descr>
<seealso>
<link id="Frac"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TSingleRec.Frac">
<short>Fractional part of single</short>
<descr>
<var>Frac</var> is the fractional part of the Single. his is the bit pattern
representing the fractional part including the preceding 1. (The mantissa is
that bit pattern without the preceding 1)
</descr>
<seealso>
<link id="Frac"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCompareOption">
<short>How to compare strings</short>
<descr>
<p>
<var>TCompareOption</var> indicates how 2 strings should be compared. This
option is used in the <link id="TWideStringManager">WideStringManager</link>
implementation when comparing 2 strings. The following options exist:
</p>
<dl>
<dt></dt><dd><printshort id="TCompareOption.coLingIgnoreCase"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coLingIgnoreDiacritic"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreCase"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreKanaType"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreKanaType"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreNonSpace"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreSymbols"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coIgnoreWidth"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coLingCasing"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coDigitAsNumbers"/></dd>
<dt></dt><dd><printshort id="TCompareOption.coStringSort"/></dd>
</dl>
<p>
Not all platforms will support all possibilities.
</p>
</descr>
<seealso>
<link id="TWideStringManager"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coLingIgnoreCase">
<short>Ignore case linguistically (usually identical to coIgnoreCase)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coLingIgnoreDiacritic">
<short>Ignore diacritic caharacters</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coIgnoreCase">
<short>Ignore case (usually identical to coLingIgnoreCase)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coIgnoreKanaType">
<short>Corresponding hiragana and katakana characters compare as equal.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coIgnoreNonSpace">
<short>Ignore nonspace characters (usually identical to coLingIgnoreDiacritic) </short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coIgnoreSymbols">
<short>Ignore symbols and punctuation characters</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coIgnoreWidth">
<short>Ignore half-width and full width characters (used in Chinese and Japanese)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coLingCasing">
<short>Use linguistic rules for casing, instead of file system rules</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coDigitAsNumbers">
<short>Treat digits as numbers (20 before 120)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCompareOption.coStringSort">
<short>Handle punctuation as symbols</short>
</element>

<!-- set type Visibility: default -->
<element name="TCompareOptions">
<short>Set of <var>TCompareOption</var></short>
<descr>
<var>TCompareOptions</var> is simply a set of <link id="TCompareOption"/>
enumeration values.
</descr>
<seealso>
<link id="TCompareOption"/>
</seealso>
</element>

<!-- operator Visibility: default -->
<element name="assign(UTF8String):variant">
<short>Assign an UTF-8 string to a variant, performing the necessary conversions</short>
<descr> 
The resulting variant is a widestring.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(UCS4String):variant">
<short>Assign UCS4String to a variant, performing the necessary conversions</short>
<descr> 
The resulting variant is a widestring.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(UnicodeString):variant">
<short>Assign UnicodeString to a variant, performing the necessary conversions</short>
<descr> 
The resulting variant is a widestring.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(single):variant">
<short>Assign a single-precision float to a variant</short>
<descr> 
The resulting variant is a double-precision value
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(extended):variant">
<short>Assign an extended-precision float to a variant</short>
<descr> 
The resulting variant is a double-precision value
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(comp):variant">
<short>Assign a comp-precision float to a variant</short>
<descr> 
The resulting variant is a double-precision value.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(Real):variant">
<short>Assign a real-precision float to a variant</short>
<descr> 
The resulting variant is a double-precision value.
</descr>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):UTF8String">
<short>Assign a variant to an UTF8String</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):unicodestring">
<short>Assign a variant to a unicodestring</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):single">
<short>Assign a variant to a single-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):extended">
<short>Assign a variant to a extended-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):comp">
<short>Assign a variant to a comp-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(variant):Real">
<short>Assign a variant to a real-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(olevariant):UnicodeString">
<short>Assign an ole-variant to a unicode string</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(olevariant):single">
<short>Assign an ole- variant to a single-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(olevariant):extended">
<short>Assign an ole- variant to an extended-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(olevariant):comp">
<short>Assign an ole- variant to a comp-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(olevariant):Real">
<short>Assign an ole- variant to a real-precision float</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(UnicodeString):olevariant">
<short>Assign a unicodestring to an ole-variant</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(single):olevariant">
<short>Assign a single-precision float to an ole-variant</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(extended):olevariant">
<short>Assign an extended-precision float to an ole-variant</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(comp):olevariant">
<short>Assign a comp-precision float to an ole-variant</short>
</element>

<!-- operator Visibility: default -->
<element name="assign(Real):olevariant">
<short>Assign a real-precision float to an ole-variant</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VType">
<short>Data type</short>
</element>

<!-- alias type Visibility: default -->
<element name="WideString">
<short>UTF-16 widechar encoded unicode string</short>
<descr>
<var>WideString</var> is an alias for <var>UnicodeString</var> on unix. On
windows, it is a different type wich has no reference counting.
</descr>
</element>

</module>
</package>
</fpdoc-descriptions>
